\part{Yaf}


\chapter{Overview}

Yaf（Yet Another Framework）扩展是一个用来开发Web应用程序的PHP框架，执行速度更快，内存占用更少。

\begin{lstlisting}[language=bash]
$ sudo pecl install yaf
\end{lstlisting}

Yaf需要SPL和PCRE的支持\footnote{SPL和PCRE都是PHP默认启用的扩展模块。}，除此之外构建Yaf扩展不需要其他扩展，而且Yaf并未与PHP进行捆绑，需要开发者自己单独安装。




\begin{example}
编译安装Yaf
\begin{lstlisting}[language=bash]
$ /path/to/phpize
$ ./configure --with-php-config=/path/to/php-config
$ make && make install
\end{lstlisting}
\end{example}

Yaf有着和Zend Framework相似的API，相似的理念，而同时又保持着对Bingo的兼容，以此来提高开发效率，规范开发习惯。

本着对性能的追求，Yaf把框架中不易变的部分抽象出来，采用PHP扩展实现(C语言)来保证性能。

\begin{compactitem}
\item 扩展逻辑相对比较稳定，一般不易变化。

如果使用扩展实现逻辑不会带来额外的维护负担。
\item 框架逻辑复杂，自检耗时耗内存都比较可观。

如果使用扩展来实现，就能大幅减少这部分对资源的消耗。
\end{compactitem}

在同样功能下，Yaf和原生的PHP的性能损失小于10\%，同时Yaf的性能是Zend Framework的50～60倍，而且Yaf框架本身禁止了用户的危险的操作习惯。

\begin{example}
原生的PHP测试代码
\begin{lstlisting}[language=PHP]
<?php
class IndexController {
    public function actionIndex(){
        echo 'Laruence';
    }
}
$controller = new IndexController();
$controller->actionIndex();
\end{lstlisting}
\end{example}


\begin{example}
Yaf入口测试文件
\begin{lstlisting}[language=PHP]
<?php
$conf = array(
    'application.directory'=>'/home/laruence/local/www/htdocs/ap'
);

$app = new Yaf_Application($conf);
$app->run();
\end{lstlisting}
\end{example}

\begin{example}
Yaf默认的控制器测试文件
\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function actionIndex() {
         $this->disableView();
         echo 'Laruence';
    }
}
\end{lstlisting}
\end{example}

下面使用Apache的ab工具来执行并发1,100,200的测试。

\begin{example}
1个并发，原生PHP请求1000次
\begin{lstlisting}[language=bash]
$ ./ab -n1000 -c1 http://127.0.0.1/orig.php

Document Path:          orig.php
Document Length:        8 bytes

Concurrency Level:      1
Time taken for tests:   0.463 seconds
Complete requests:      1000
Failed requests:        0
Write errors:           0
Total transferred:      130000 bytes
HTML transferred:       8000 bytes
Requests per second:    2159.41 [#/sec] (mean)
Time per request:       0.463 [ms] (mean)
Time per request:       0.463 [ms] (mean, across all concurrent requests)
Transfer rate:          274.14 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.0      0       0
Processing:     0    0   0.2      0       5
Waiting:        0    0   0.2      0       5
Total:          0    0   0.2      0       5

Percentage of the requests served within a certain time (ms)
  50%      0
  66%      0
  75%      0
  80%      0
  90%      0
  95%      0
  98%      0
  99%      1
 100%      5 (longest request)
\end{lstlisting}
\end{example}


\begin{example}
1个并发，Yaf请求1000次
\begin{lstlisting}[language=bash]
$ ./ab -n1000 -c1 http://127.0.0.1/ap/index.php

Document Path:          /ap/index.php
Document Length:        8 bytes

Concurrency Level:      1
Time taken for tests:   0.525 seconds
Complete requests:      1000
Failed requests:        0
Write errors:           0
Total transferred:      130000 bytes
HTML transferred:       8000 bytes
Requests per second:    1906.24 [#/sec] (mean)
Time per request:       0.525 [ms] (mean)
Time per request:       0.525 [ms] (mean, across all concurrent requests)
Transfer rate:          242.00 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.0      0       0
Processing:     0    0   0.3      0       7
Waiting:        0    0   0.3      0       7
Total:          0    0   0.3      1       7
ERROR: The median and mean for the total time are more than twice the standard
       deviation apart. These results are NOT reliable.

Percentage of the requests served within a certain time (ms)
  50%      1
  66%      1
  75%      1
  80%      1
  90%      1
  95%      1
  98%      1
  99%      1
 100%      7 (longest request)
\end{lstlisting}
\end{example}



\begin{example}
100个并发，原生PHP请求1000次
\begin{lstlisting}[language=bash]
$ ./ab -n1000 -c100 http://127.0.0.1/orig.php

Document Path:          orig.php
Document Length:        8 bytes

Concurrency Level:      100
Time taken for tests:   0.287 seconds
Complete requests:      1000
Failed requests:        0
Write errors:           0
Total transferred:      130000 bytes
HTML transferred:       8000 bytes
Requests per second:    3478.82 [#/sec] (mean)
Time per request:       28.745 [ms] (mean)
Time per request:       0.287 [ms] (mean, across all concurrent requests)
Transfer rate:          441.65 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   1.0      0       6
Processing:     5   27   4.8     27      35
Waiting:        5   27   4.8     27      35
Total:          6   27   4.6     27      36

Percentage of the requests served within a certain time (ms)
  50%     27
  66%     28
  75%     29
  80%     31
  90%     35
  95%     35
  98%     35
  99%     35
 100%     36 (longest request)
\end{lstlisting}
\end{example}



\begin{example}
100个并发，Yaf请求1000次
\begin{lstlisting}[language=bash]
$ ./ab -n1000 -c100 http://127.0.0.1/ap/index.php

Document Path:          /ap/index.php
Document Length:        8 bytes

Concurrency Level:      100
Time taken for tests:   0.316 seconds
Complete requests:      1000
Failed requests:        0
Write errors:           0
Total transferred:      130000 bytes
HTML transferred:       8000 bytes
Requests per second:    3165.24 [#/sec] (mean)
Time per request:       31.593 [ms] (mean)
Time per request:       0.316 [ms] (mean, across all concurrent requests)
Transfer rate:          401.84 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   1.0      0       6
Processing:     6   30   5.6     27      44
Waiting:        6   30   5.6     27      44
Total:          6   30   5.6     27      44

Percentage of the requests served within a certain time (ms)
  50%     27
  66%     32
  75%     34
  80%     36
  90%     37
  95%     40
  98%     42
  99%     42
 100%     44 (longest request)
\end{lstlisting}
\end{example}

\section{Memory}

Yaf相比原生的PHP带来的额外的性能开销非常小，而且Yaf的框架类无需编译。



Yaf的框架类在PHP启动时加载，并且常驻内存，因此Yaf可以通过更短的内存周转周期来提高内存利用率，降低内存占用率。

虽然Yaf必须有一次IO操作（载入Controller），原生的PHP并不需要这一步，不过实际上框架的时间和真正应用逻辑的耗时相比只是很小的一部分。

\section{Autoload}


Yaf提供了灵活的自动加载，并且支持全局加载和局部加载两种加载规则，方便类库共享。

Yaf在自启动的时候会通过SPL注册一个自己的Autoloader，出于性能的考虑，Yaf对于框架相关的MVC类——Yaf Autoloader只以目录映射的方式尝试一次。

现在Yaf支持在PHP脚本中触发对Controller的自动加载，不过Controller的定位需要根据Module路由结果来判断，这就造成了 在Bootstrap或者RouteStarrup之前无法确定，所以对于Controller的加载，Yaf将只会尝试去加载默认Module的Controller，也就是只在\texttt{"\{项目路径\}/controllers"}目录下寻找。

在use\_spl\_autoload关闭的情况下，Yaf Autoloader在一次找不到的情况下会立即返回，这样就剥夺了其后的自动加载器的执行机会。


具体的目录映射规则如下:



\zihao{6}
\begin{longtable}{|m{50pt}|m{140pt}|m{140pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
类型&后缀(或者前缀, 可以通过php.ini中yaf.name\_suffix来切换)&映射路径
\endhead
%endhead

%firsthead
\caption{Yaf目录映射规则}\\
\hline
类型&后缀(或者前缀, 可以通过php.ini中yaf.name\_suffix来切换)&映射路径
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
控制器	&Controller	&默认模块下为\texttt{\{项目路径\}/controllers/},否则为\texttt{\{项目路径\}/modules/\{模块名\}/controllers/}\\
\hline
数据模型	&Model		&\texttt{\{项目路径\}/models/}\\
\hline
插件		&Plugin		&\texttt{\{项目路径\}/plugins/}\\
\hline
\end{longtable}
\zihao{5}

对于非框架MVC相关的类，Yaf支持全局类和自身类的两种加载方式，并且Yaf支持大小写敏感和不敏感两种方式来处理文件路径。

\subsection{Global Class}

Yaf为了方便在一台服务器上部署的不同产品之间共享公司级别的共享库，支持全局类和本地类两种加载方式。

全局类是指所有产品之间共享的类，这些类库的路径是通过yaf.library在php.ini（当然,如果PHP在编译的时候, 支持了with-config-file-scan-dir，那么也可以写在单独的yaf.ini中）。



\subsection{Local Class}

本地类是指产品自身的类库，这些类库的路径是通过在产品的配置文件中通过yaf.library配置的。

在Yaf中，可以通过调用Yaf\_Loader的registerLocalNamespace()方法来申明哪些类前缀是本地类。



\section{Directory}


一个典型的Yaf应用程序的目录结构如下：

\begin{lstlisting}[language=bash]
|— .htaccess // rewrite rules
|— public
|       `— .htaccess
|       `— css
|       `— js
|       `— img
|       `— index.php // application entry
|— conf
|        `— application.ini // application config
|— application
|        |— Bootstrap.php
|        |— controllers
|        |       `— Index.php // default controller
|        |— views
|        |       `— index
|        |                 `— index.phtml // view template for default action
|        |— library // 本地类库
|        `— modules // 其他模块
|— library // 全局类库
|— models // Models
|— plugins // Plugins
\end{lstlisting}

在Yaf应用程序的目录结构中，开发者需要把DocumentRoot指向application/public，而且只有public目录是可以公开访问的。

Yaf提供了一个代码生成工具——yaf\_cg来生成Yaf应用程序的脚手架。


\begin{lstlisting}[language=bash]
$ cd /var/www/html
$ php yaf_cg Sample
$ ls output/Sample/
$ application/  conf/  index.php  readme.txt
\end{lstlisting}

用户可以把上述生成的sample目录下的内容移动到Web服务器的documentRoot目录下，从而从脚手架开始Yaf应用程序的开发。


\section{Intry Script}


Yaf应用程序根目录（或public目录）下的index.php是整个Yaf应用程序的所有请求的唯一入口，应该把所有请求都重定向到这个文件（在Apache+php\_mod模式下可以使用.htaccess）。


\begin{example}
public/index.php入口文件的配置（仅供参考）
\begin{lstlisting}[language=PHP]
<?php
define("APPLICATION_PATH",dirname(dirname(__FILE__)));

$app = new Yaf_Application(APPLICATION_PATH . "/conf/application.ini");
$app->bootstrap() // call bootstrap methods defined in Bootstrap.php
     ->run();
?>
\end{lstlisting}
\end{example}

\begin{example}
入口文件
\begin{lstlisting}[language=PHP]
<?php
define("APPLICATION_PATH",dirname(dirname(__FILE__)));

$app = new Yaf_Application(APPLICATION_PATH . "/conf/application.ini");
$app->bootstrap() // call bootstrap methods defined in Bootstrap.php
     ->run();
?>
\end{lstlisting}
\end{example}


Yaf\_Application代表一个产品/项目，是Yaf运行的主导者，真正执行的主体，因此在入口脚本中会创建Yaf\_Application的一个单例。

具体来说，Yaf\_Application负责接收请求，协调路由，分发，执行并输出，而且打开yaf.use\_namespace的情况下还可以使用 Yaf\_Application.


\section{Constant}

Yaf扩展定义了下面的预定义常量，这些常量在Yaf扩展编译进PHP核心或在运行时动态载入时可用。

\zihao{6}
\begin{longtable}{|m{130pt}|m{125pt}|m{140pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
常量名字&启用命名空间后的常量名&默认
\endhead
%endhead

%firsthead
\caption{Yaf的预定义常量}\\
\hline
常量名字&启用命名空间后的常量名&默认
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
YAF\_VERSION&Yaf\textbackslash VERSION&Yaf框架的三位版本信息（例如3.0.4）\\
\hline
YAF\_ENVIRON&Yaf\textbackslash ENVIRON& Yaf的环境常量, 指明了要读取的配置的节, 默认的是product\\
\hline
YAF\_ERR\_STARTUP\_FAILED&Yaf\textbackslash ERR\textbackslash STARTUP\_FAILED)&Yaf的错误代码常量, 表示启动失败, 值为512\\
\hline
YAF\_ERR\_ROUTE\_FAILED&Yaf\textbackslash ERR\textbackslash ROUTE\_FAILED& Yaf的错误代码常量, 表示路由失败, 值为513\\
\hline
YAF\_ERR\_DISPATCH\_FAILED&Yaf\textbackslash ERR\textbackslash DISPATCH\_FAILED& Yaf的错误代码常量, 表示分发失败, 值为514\\
\hline
YAF\_ERR\_NOTFOUND\_MODULE&Yaf\textbackslash ERR\textbackslash NOTFOUD\textbackslash MODULE& Yaf的错误代码常量, 表示找不到指定的模块, 值为515\\
\hline
YAF\_ERR\_NOTFOUND\_CONTROLLER&Yaf\textbackslash ERR\textbackslash NOTFOUND\textbackslash CONTROLLER& Yaf的错误代码常量, 表示找不到指定的Controller, 值为516\\
\hline
YAF\_ERR\_NOTFOUND\_ACTION&Yaf\textbackslash ERR\textbackslash NOTFOUD\textbackslash ACTION&Yaf的错误代码常量, 表示找不到指定的Action, 值为517\\
\hline
YAF\_ERR\_NOTFOUND\_VIEW&Yaf\textbackslash ERR\textbackslash NOTFOUD\textbackslash VIEW&Yaf的错误代码常量, 表示找不到指定的视图文件, 值为518\\
\hline
YAF\_ERR\_CALL\_FAILED&Yaf\textbackslash ERR\textbackslash CALL\_FAILED&Yaf的错误代码常量, 表示调用失败, 值为519\\
\hline
YAF\_ERR\_AUTOLOAD\_FAILED&Yaf\textbackslash ERR\textbackslash AUTOLOAD\_FAILED& Yaf的错误代码常量, 表示自动加载类失败, 值为520\\
\hline
YAF\_ERR\_TYPE\_ERROR&Yaf\textbackslash ERR\textbackslash TYPE\_ERROR&Yaf的错误代码常量, 表示关键逻辑的参数错误, 值为521\\
\hline
\end{longtable}
\zihao{5}


\section{Runtime}

Yaf提供的下面的这些函数的行为受到php.ini中的配置项的影响。

\zihao{6}
\begin{longtable}{|m{80pt}|m{20pt}|m{60pt}|m{225pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
配置选项&默认&可修改范围&说明
\endhead
%endhead

%firsthead
\caption{Yaf 配置选项}\\
\hline
配置选项&默认&可修改范围&说明
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
\texttt{yaf.library}	 		&NULL&PHP\_INI\_ALL&全局类库的目录路径\\
\hline
\texttt{yaf.action\_prefer}	&0	&PHP\_INI\_ALL 	&\\
\hline
\texttt{yaf.lowcase\_path}	&0	&PHP\_INI\_ALL 	&\\
\hline
\texttt{yaf.use\_spl\_autoload}&0	&PHP\_INI\_ALL&开启的情况下, Yaf在加载不成功的情况下, 会继续让PHP的自动加载函数加载, 从性能考虑, 除非特殊情况, 否则保持这个选项关闭\\
\hline
\texttt{yaf.forward\_limit}	&5	&PHP\_INI\_ALL&forward最大嵌套深度\\
\hline
\texttt{yaf.name\_suffix}	&1	&PHP\_INI\_ALL&在处理Controller, Action, Plugin, Model的时候, 类名中关键信息是否是后缀式, 比如UserModel, 而在前缀模式下则是ModelUser\\
\hline
\texttt{yaf.name\_separator}&\texttt{""}&PHP\_INI\_ALL&在处理Controller, Action, Plugin, Model的时候, 前缀和名字之间的分隔符, 默认为空, 也就是UserPlugin, 加入设置为\texttt{"\_"}, 则判断的依据就会变成\texttt{"User\_Plugin"}, 这个主要是为了兼容已有的命名规范\\
\hline
\texttt{yaf.cache\_config}	&0	&PHP\_INI\_SYSTEM&是否缓存配置文件(只针对INI配置文件生效), 打开此选项可在复杂配置的情况下提高性能\\
\hline	
\texttt{yaf.environ}		&product	&PHP\_INI\_SYSTEM&环境名称, 当用INI作为Yaf的配置文件时, 这个指明了Yaf将要在INI配置中读取的节的名字 \\
\hline
\texttt{yaf.use\_namespace}	&0	&PHP\_INI\_ALL&开启的情况下, Yaf将会使用命名空间方式注册自己的类, 比如Yaf\_Application将会变成Yaf\textbackslash Application\\
\hline
\end{longtable}
\zihao{5}

在开启yaf.cache\_config的情况下，Yaf会使用INI文件路径作为Key——这就有一个陷阱——如果在一台服务器上同时运行两个应用, 那么它们必须不能使用同一个路径名下的INI配置文件，否则就会出现Application Path混乱的问题，所以尽量不要使用相对路径。


\subsection{yaf.library}

yaf.library(string)-全局库路径，Yaf\_loader将在此目录中搜索全局库。

\subsection{yaf.action\_prefer}


yaf.action\_prefer(integer)-如果PATH\_INFO中的一个部分，则应将其视为控制器（controller）或动作（action），而且如果此配置为On，它将被视为一个Action名称。

\subsection{yaf.lowcase\_path}

yaf.lowcase\_path(integer)-定义在类自动加载期间是否小写所有路径。

\subsection{yaf.use\_spl\_autuload}

yaf.use\_spl\_autoload(integer)-当这个值为On时，如果Yaf\_Loader找不到一个类，它将返回FALSE，然后调用其他自动加载函数。

当此值为Off（默认值）时，Yaf\_Loader :: autoload()将始终返回TRUE。

\subsection{yaf.forward\_limit}

yaf.forward\_limit(integer)-最大转发计数（默认为5），这意味着可以在转发堆栈中的最大值为5。

这是一个保护，防止递归调用\texttt{Yaf\_Controller\_Abstract::forward()}。

\subsection{yaf.name\_suffix}

yaf.name\_suffix(integer)-当这个On，Yaf\_Loader将通过它的后缀来识别一个类，以决定它是否是一个MVC类。

当此关闭时，Yaf\_Loader将查看类名的前缀。

\subsection{yaf.name\_separator}

yaf.name\_separator(string)-当这不为空时，Yaf\_Loader将标识该类的后缀和字符串值。例如，当此值为“\_”时，Yaf\_Loader将Index\_Controller用作Controller类，IndexController用作普通类。

\subsection{yaf.cache\_config}

yaf.cache\_config(string)-如果这是On，并且在此期间使用ini配置文件作为Yaf\_Application()的参数，那么ini配置文件的编译结果将缓存在PHP进程中。

Yaf检查ini文件的mtime，如果它从上次编译以来已经被更改，那么Yaf将重新加载它。

Yaf使用ini文件路径作为缓存项key，所以使用ini文件路径中的绝对路径，否则如果两个应用程序使用相同的ini config相对路径，可能会有一些冲突。


\subsection{yaf.environ}

yaf.environ(string)-默认情况下，此值为“product”，用于Yaf获取ini配置文件的config部分。

也就是说，如果这个值是“product”，Yaf将使用ini配置文件中的“product”部分（Yaf\_Application的第一个参数）作为Yaf\_Application的最终配置。

\subsection{yaf.use\_namespace}

yaf.use\_namespace(integer)-如果此值为On，则Yaf的所有类都将在命名空间样式中命名。例如，Yaf\_Route\_Rewrite => \textbackslash Yaf\textbackslash Route\textbackslash Rewrite，Yaf\_Controller\_Abstract =>\textbackslash Yaf\textbackslash Controller\_Abstract（Abstract是关键字，不能用作类名）。






\section{Configuration}

Yaf提供了强大而又高度灵活的配置文件支持，并支持缓存配置文件来避免复杂的配置结构带来的性能损失。

Yaf默认的应用配置文件是application.ini，INI配置文件支持继承，支持分节。

INI配置文件还支持常量，因此INI支持直接使用PHP中的已定义常量（例如下面的APPLICATION\_PATH）。

\begin{lstlisting}[language=bash]
[yaf]
;APPLICATION_PATH is the constant defined in index.php
application.directory = APPLICATION_PATH "/application"

;product section inherit from yaf section
[product:yaf]
foo=bar
\end{lstlisting}

开发者无需担心配置文件太大造成性能问题，Yaf会在运行的第一时间在载入配置文件，并且把格式化后的内容存储在内存中，直到配置文件再次被修改才会重新载入配置文件。

Yaf默认的Bootstrap.php的内容如下：

\begin{lstlisting}[language=PHP]
<?php
/* Bootstrap class should be define under ./application/Bootstrap.php */
class Bootstrap extends Yaf_Bootstrap_Abstract {
   public function _initConfig(Yaf_Dispatcher $dispatcher) {
      var_dump(__METHOD__);
   }
   
   public function _initPlugin(Yaf_Dispatcher $dispatcher) {
      var_dump(__MATHOD__);
   }
}
\end{lstlisting}


在实践中，开发者需要传递一个config数组或ini配置文件作为Yaf应用程序的配置，而且Yaf的配置文件会和用户的配置文件合并。

\begin{example}
使用数组向Yaf传递配置
\begin{lstlisting}[language=PHP]
<?php
$configs = array(
    "application" => array(
         "directory" => dirname(__FILE__),
         "dispatcher" => array(
              "catchException" => 0,
         ),
         "view" => array(
              "ext" => "phtml",
          ),
    ),
);
$app = new Yaf_Application($config);
\end{lstlisting}
\end{example}

Yaf的配置文件和用户的配置文件的区别在于，Yaf的配置文件是以\texttt{yaf.}或\texttt{application.}开头，如果两项都存在，则\texttt{application.}生效。

\begin{example}
使用ini向Yaf传递配置
\begin{lstlisting}[language=bash]
[yaf]
yaf.directory = APPLICATION_PATH "/appliation"
yaf.dispatcher.catchException = 0

[product : yaf]
; user configuration list here
\end{lstlisting}
\end{example}


\zihao{6}
\begin{longtable}{|m{150pt}|m{40pt}|m{220pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
名字&类型&默认
\endhead
%endhead

%firsthead
\caption{Yaf Application配置选项}\\
\hline
名字&类型&默认
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
\texttt{application.directory} 		&string			&				\\
\hline
\texttt{application.ext} 				&string			&\texttt{"php"}	\\
\hline
\texttt{application.view.ext} 			&string			&\texttt{"phtml"}	\\
\hline
\texttt{application.modules} 		&string			&\texttt{"index"}	\\
\hline
\texttt{application.library} 			&string			&\texttt{application.directory . "/library"}	\\
\hline
\texttt{application.library.directory} 	&string			&\texttt{application.directory . "/library"}	\\
\hline
\texttt{application.library.namespace} &string			&\texttt{""}	\\
\hline
\texttt{application.bootstrap} 		&string			&\texttt{application.directory . "/Bootstrap" . application.ext}	\\
\hline
\texttt{application.baseUri} 			&string			&\texttt{""}	\\
\hline
\texttt{application.dispatcher.defaultRoute} & string		&	\\
\hline
\texttt{application.dispatcher.throwException} &bool	&1	\\
\hline
\texttt{application.dispatcher.catchException} &bool		&0	\\
\hline
\texttt{application.dispatcher.defaultModule} &string	&\texttt{"index"	}\\
\hline
\texttt{application.dispatcher.defaultController}&string	&\texttt{"index"}	\\
\hline
\texttt{application.dispatcher.defaultAction} &string		&\texttt{"index"}	\\
\hline
\texttt{application.system} 			&string			&\\
\hline
\end{longtable}
\zihao{5}



\subsection{application.directory}


application.directory(string)-应用程序的目录，包含``controllers", ``views", ``models", ``plugins"等子目录。

application.directory是Yaf中唯一一个没有默认值的配置项，需要手动指定它。

\subsection{application.ext}

application.ext(string)-PHP脚本的扩展名（默认为php），类的自动加载需要用到它( Yaf\_Loader)。

\subsection{application.view.ext}

application.view.ext(string)-视图模板扩展名。

\subsection{application.modules}


application.modules(string)-注册的模块列表（以逗号分隔），用于路由处理，特别是当PATH\_INFO超过三段的时候，Yaf需要用它来判断第一段是否是一个模块。

开发者只能申明存在的模块名，而且如果要定义这个值，一定要定义Index Module。

\subsection{application.library}

application.library(string)-本地（自身）类库的目录（参见Yaf\_Loader 和 yaf.library）的绝对目录地址，而且该配置项也可以是一个数组。

当application.library是数组的时候，类库的路径将尝试使用application.library.directory的值。

\subsection{application.library.directory}

application.library.directory是application.library的别名。

\subsection{application.library.namespace}

application.library.namespace(string)-逗号分隔的本地类库命名空间前缀。


\subsection{application.bootstrap}

application.bootstrap(string)-Bootstrap类脚本文件的绝对路径（默认为\$document\_root/application/Bootstrap.php）。

\subsection{application.baseUri}

application.baseUri(string)-路由处理中需要忽略的路径前缀，一般不需要设置，Yaf会自动判断.。例如，请求``/prefix/controller/action"时，如果将application.baseUri设置为``/prefix"，那么只有``/controller/action"会被当做路由路径。

通常情况下，不需要设置application.baseUri的值。

\subsection{application.dispatcher.throwException}

application.dispatcher.throwException(bool)-在出错的时候是否抛出异常。开启此项时，Yaf会在发生错误的地方抛出异常（参见Yaf\_Dispatcher::throwException()）。


\subsection{application.dispatcher.catchException}


application.dispatcher.catchException(bool)-是否使用默认的异常捕获Controller。开启此项，如果有未捕获的异常，Yaf将会把控制权交给ErrorController中的errorAction()方法（参见Yaf\_Dispatcher::catchException()）。

开发者可以使用\texttt{\$request->getException()}获得此异常对象。



\subsection{application.dispatcher.defaultRoute}

application.dispatcher.defaultRoute(string)-默认路由，如果未指定，静态路由会被当做是默认路由（参见Yaf\_Router::addRoute()）。

\subsection{application.dispatcher.defaultModule}


application.dispatcher.defaultModule(string)-默认模块名，参见Yaf\_Dispatcher::setDefaultModule()。


\subsection{application.dispatcher.defaultController}

application.dispatcher.defaultController-默认控制器名（参见Yaf\_Dispatcher::setDefaultController()）。

\subsection{application.dispatcher.defaultAction}

application.dispatcher.defaultAction(string)-默认Action名（参见 Yaf\_Dispatcher::setDefaultAction()）。

\subsection{application.system}



application.system(string)-在application.ini中设置Yaf运行时配置，注意仅有PHP\_INI\_ALL配置项可以这样设置。

开发者可以通过application.system.*属性来自定义Yaf的运行时配置选项（例如application.system.lowcase\_path等）。

\section{Rewrite Rule}


除非使用基于Query String的路由协议（Yaf\_Route\_Simple和Yaf\_Route\_Supervar），否则需要使用Apache或Nginx提供的URL Rewrite规则把所有的请求都重定向到Yaf应用程序的入口文件。


Yaf使用的URL重写规则如下：


\begin{lstlisting}[language=bash]
# apache(.htaccess)
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule .* index.php

# for nginx(nginx.conf)
server {
   listen 80;
   server_name _;
   root document_root;
   index index.php index.html index.htm;
   
   if ( !-e $request_filename ) {
      rewrite ^/(.*) /index.php/$1 last;
   }
}

# for lighttpd(lighttpd.conf)
$HTTP["host"] =~ "(www.)?domain.com$" {
   url.rewrite = (
       "^/(.+)/?$" => "/index.php/$1",
   )
}

# for sae(config.yaml)
name: your_app_name
varsion: 1
handle: 
  - rewrite: if(!is_dir() && !is_file() && path ~ "^(.*)$" ) goto "/index.php"
\end{lstlisting}

另外，在LNMP架构中使用Nginx和PHP-FPM时，可以使用如下的URL重写配置：

\begin{lstlisting}[language=bash]
server {
   listen 80;
   server_name _;
   root document_root;
   index index.php index.html index.htm;
   
   location / {
      try_files $uri $uri/ /index.php$is_args$args;
   }
   
   location ~ \.php$ {
       fastcgi_pass 127.0.0.1:9000;
       #fastcgi_pass unix:/tmp/php-cgi.sock;
       fastcgi_index index.php;
       fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
       include fastcgi_params;  
   }
}
\end{lstlisting}


\subsection{PATH\_INFO}

在使用Nginx作为单一入口的PHP框架的反向代理时，需要使用Nginx向Yaf/ThinkPHP等应用程序传递PATH\_INFO请求参数才能正常运行，例如：


\begin{lstlisting}[language=bash]
server {
   listen 80;
   server_name _;
   root document_root;
   index index.php index.html index.htm;
   
   location / {
      try_files $uri $uri/ @path_rw;
   }
   
   location @path_rw {
      rewrite ^/(.*)$ /index.php/$1 last;
   }
   
   location ~ \.php {
       fastcgi_pass 127.0.0.1:9000;
       #fastcgi_pass unix:/tmp/php-cgi.sock;
       fastcgi_index index.php;
       include fastcgi.conf;
       
       fastcgi_split_path_info ^(.+?\.php)(/.+)$;
       fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
       fastcgi_param SCRIPT_NAME $fastcgi_script_name;
       fastcgi_param PATH_INFO $fastcgi_path_info;
       #include fastcgi_params;  
   }
}
\end{lstlisting}



\section{Resource Type}

Yaf没有定义自己的资源类型。


\section{View Engine}


Yaf提供了一个高性能的视图引擎——Yaf\_View\_Simple，同时Yaf的高度灵活可扩展的框架结构支持自定义视图引擎、插件以及自定义路由等。

\section{Route Engine}

Yaf内置多种路由，可以兼容目前常见的路由协议。

\chapter{Yaf Workflow}

Yaf提供了完善的API并且支持Bootstrap和插件机制，其整体流程图如下：

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{yaf_sequence.png}
\caption{Yaf的整体执行流程}
\end{figure}


\chapter{Yaf Hook}


Yaf定义了6个Hook，分别是routerStartup、routerShutdown、dispatchLoopStartup、preDispatch、postDispatch和dispatchLoopShutdown。


\zihao{6}
\begin{longtable}{|m{40pt}|m{80pt}|m{80pt}|m{160pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
触发顺序&Hook名称&触发时机&说明
\endhead
%endhead

%firsthead
\caption{Yaf Hook}\\
\hline
触发顺序&Hook名称&触发时机&说明
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
1& routerStartup&在路由之前触发&routerStartup是7个事件中最早的一个，但是一些全局自定义的操作还是应该放在Bootstrap中完成。\\
\hline
2&routerShutdown&在路由结束后触发&要求此时路由一定必须正确完成，否则这个事件不会被触发\\
\hline
3&dispatchLoopStartup&分发循环开始之前被触发&\\
\hline
4&preDispatch&分发之前触发&如果在一个请求处理过程中发生了forward，那么这个事件会被触发多次\\
\hline
5&postDispatch&分发结束之后触发&此时动作已经执行结束，视图也已经渲染完成，而且和preDispatch类似，这个事件也可能被触发多次\\
\hline
6&dispatchLoopShutDown&分发循环结束之后触发&此时表示所有的业务逻辑都已经运行完成，但是响应还没有发送。\\
\hline
\end{longtable}
\zihao{5}



\chapter{Yaf Environment}


Yaf和用户共用一个配置空间, 也就是在Yaf\_Application初始化时给出的配置文件中的配置。

作为区别, Yaf的配置项都以ap开头，Yaf的核心必不可少的配置项只有一个（也就是application.directory），而且这个也可以有默认参数。

\begin{compactitem}
\item application.directory - Yaf应用程序的绝对目录路径
\end{compactitem}



Yaf通过在不同的环境中, 选取不同的配置节, 再结合配置可继承, 来实现一套配置适应多种环境（线上、测试和开发）。

\chapter{Yaf Namespace}

Yaf\_Loader 类为Yaf提供了自动加载(autoload)功能的全面解决方案，这样Yaf就可以根据类名中包含的路径信息实现类的定位和自动加载。

在打开yaf.use\_namespace的情况下，可以使用名字空间。例如，Yaf\_Loader在名字空间中是Yaf\textbackslash Loader。




\chapter{Yaf Class}


Yaf的类的加载规则都是一样的——Yaf规定类名中必须包含路径信息，也就是以下划线\texttt{"\_"}分割的目录信息，Yaf将依照类名中的目录信息来完成自动加载。

默认情况下，在没有申明本地类的情况下，Yaf把Foo\_Dummy\_Bar类会映射到/Foo/Dummy/Bar.php

\begin{example}
Yaf按照路径查找类Foo\_Dummy\_Bar
\begin{lstlisting}[language=bash]
//Yaf将在如下路径寻找类Foo_Dummy_Bar
{类库路径(php.ini中指定的yaf.library)}/Foo/Dummy/Bar.php
\end{lstlisting}
\end{example}

如果通过如下方式调用了registerLocalNamespace()注册了本地类，那么就会在指定的路径中查找Foo\_Dummy\_Bar类。

\begin{example}
使用registerLocalNamespace()注册本地类
\begin{lstlisting}[language=PHP]
<?php
// 申明凡是以Foo和Local开头的类都是本地类
$loader = Yaf_Loader::getInstance();
$loader->registerLocalNamespace(array("Foo","Local"));
\end{lstlisting}
\end{example}

在通过申明注册本地类后，Yaf会按照类库路径来查找Foo\_Dummy\_Bar类，例如：

\begin{example}
Yaf按照本地类库路径查找类Foo\_Dummy\_Bar
\begin{lstlisting}[language=PHP]
//Yaf将在如下路径寻找类Foo_Dummy_Bar
{类库路径(conf/application.ini中指定的yaf.library)}/Foo/Dummy/Bar.php
\end{lstlisting}
\end{example}



\chapter{Yaf MVC}

MVC（Model-View-Controller）软件架构模式可以把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.4]{ModelViewControllerDiagram.png}
\caption{MVC设计模式}
\end{figure}

在最初的JSP网页中，数据库查询语句等数据层代码是和HTML表示层代码混杂在一起的，虽然可以将数据从表示层分离开来，但是这样的良好设计通常并不是很容易做到的。

MVC可以从根本上强制性地将数据层和表示层代码分开，尽管构造MVC应用程序需要一些额外的工作，但是MVC带来的好处是毋庸置疑的。

MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。

首先，多个 View 能共享一个 Model，这样同一个Web应用程序会提供多种用户界面。例如，用户希望既能够通过浏览器来收发电子邮件，还希望通过手机来访问电子邮箱，因此要求Web网站同时能提供Internet界面和WAP界面。

在MVC设计模式中， Model 响应用户请求并返回响应数据，View 负责格式化数据并把它们呈现给用户，业务逻辑和表示层分离，同一个 Model 可以被不同的 View 重用的做法提高了代码的可重用性。

其次，Controller 是自包含（self-contained）的高独立内聚的对象，与 Model 和 View 保持相对独立，所以可以方便的改变应用程序的数据层和业务规则。例如，把数据库从MySQL移植到Oracle，或者把RDBMS数据源改变成LDAP数据源，只需改变 Model 即可。

Controller 提高了应用程序的灵活性和可配置性。例如，Controller 可以用来连接不同的 Model 和 View 去完成用户的需求，也可以为构造应用程序提供强有力的手段，开发者给定一些可重用的 Model 、 View 和Controller就可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 将处理结果显示给用户。

在正确地实现了控制器之后，不管数据来自数据库还是LDAP服务器，View 都会正确地显示它们。

除此之外，MVC模式通过对复杂度的简化，使程序结构更加直观，而且软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。例如，开发者可以通过自身的专长分组：

\begin{compactitem}
\item 控制器（Controller）- 负责对请求进行处理并转发请求。
\item 视图（View） - 图形界面设计。
\item 模型（Model） - 算法实现、数据管理和数据库设计等具体的功能。
\end{compactitem}

MVC将应用程序划分为三种组件后，开发者就可以设计并定义它们之间的相互作用，因此MVC模式的三个模块是相互独立的，改变其中一个不会影响其他两个，所以依据这种设计思想能构造出良好的少互扰性的构件。

在概念上，MVC模式强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责数据显示的职责分离原则，因此MVC 模式的 Framework在实现上通常会将 MVC 三个部分分离实现：

\begin{compactitem}
\item Model 负责数据访问，现代的 Framework 都会建议使用独立的数据对象 (DTO, POCO, POJO 等) 来替代弱类型的集合对象。

数据访问的代码会使用 Data Access Object或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的依赖性。

\item Controller 负责处理消息，较高级的 Framework 会有一个默认的实现（例如Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等）来作为 Controller 的基础。

在职责分离原则的基础上，每个 Controller 负责的部分不同，因此会将各个 Controller 切割成不同的文件以利于维护。

\item View 负责显示数据，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model、集合或状态等) 交给 View，然后由 View 来决定怎么显示。例如 Spring Framework 使用 JSP 或相应技术，ASP.NET MVC 则使用 Razor 处理数据的显示。


\end{compactitem}


MVC 模式强调职责分离会产生很多文件，需要IDE基于类别对象的信息来组织代码编辑，而且 MVC 模式会要求开发者进一步思考应用程序的架构，而非用大杂烩的方式开发应用程序，对于应用程序的生命周期以及后续的可扩充与可维护性而言有相当正面的帮助。

MVC 职责分离也带来了一个现代软件工程要求的重要特性—可测试性 (Testability)，基于MVC的应用程序在良好的职责分离的设计下，各个部分都可以独立进行单元测试，因此有利于与企业内的自动化测试、持续集成与持续发布流程的集成，减少应用程序改版部署所需的时间。

MVC 模式的应用程序的目的就是希望打破以往应用程序使用的大杂烩程序开发方式，并间接促使开发人员以更高的架构导向思维来思考应用程序的设计，因此MVC（或是其他的设计模式）都是有助于应用程序长远的发展，大杂烩式的程序在可扩充性和可维护性 (尤其是可测试性) 上远比 MVC 复杂很多。

MVC 模式的应用程序是在初始开发时期必须先思考并使用软件架构，结果就是可扩充性、可维护性和可测试性会因为 MVC 的特性而变得容易。

下面的示例使用JavaScript实现了一个基础的完整MVC示例。

\begin{lstlisting}[language=JavaScript]
/** 模拟Model，View和Controller **/
var M = {}, V = {}, C = {};

/** Model负责存储数据 **/
M.data = "Hello world.";

/** View负责把数据输出到网页上 **/
V.ender = (M) => {alert(M.data)};

/** Controller是Model和View的桥梁 **/
C.handleOnload = () => { V.render(M); }

/** 在网页读取时调用Controller **/
window.onload = C.handleOnload;
\end{lstlisting}

MFC Document/View架构是早期对于MVC模式的实现，MFC将程序分成CView以及CDocument两大类别，其中的Document对应MVC中的 Model ，View 相当于MVC中的 View＋Controller，再加上CWinApp类别，合成三大项。


Java EE除了直接以Servlet来编写Controller之外，也可以使用Struts2或Spring Framework等，Model 则是由一个实体Bean来实现，视图（View）可能由JSP来实现。

Java Swing是一个标准的MVC架构，其中ComponentUI代表 View，负责渲染组件，Model 层包括JTextField的Document、JTable的TableModel和JTree的TreeModel等，Event机制可以看作是Controller。

Ruby on Rails的Model 部分使用 Active Record 概念实现，并使用Migration机制来控制Model的结构。

JavaScript的Backbone.js、Angular.js和Ember.js都实现了MVC模式。

PHP的Yaf、CakePHP、CodeIgniter、Symfony、Yii、Phalcon、Laravel和Zend Framework都是MVC框架。


\section{Controller}

控制器（Controller）可以在不同层面间发挥组织作用，从而控制应用程序的流程。

Controller处理事件并作出响应，这里的“事件”包括用户的行为和数据 Model 上的改变等。



Yaf默认的控制器为controllers/Index.php，其内容如下：

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    /* default action name */
    public function indexAction() {
        $this->_view->content = "hello world, yaf";
        // or
        // $this->getView()->content = "hello world, yaf";
        // $this->getView()->assign("content","Hello world, yaf");
    }
}
\end{lstlisting}

Yaf中的默认的模块、控制器和动作都是以Index命名的，也可以通过配置文件进行修改。例如，默认模块的控制器在application目录下的controllers目录下，Action的命名规则是“名字+Action”。

\section{Model}

模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。

“Model”有对数据直接访问的权力（例如对数据库的访问），而且“Model”不依赖“View”和“Controller”。

也就是说， Model 不关心它会被如何显示或是如何被操作，但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而View就可以了解在数据 Model 上发生的改变。




\section{View}

虽然理论上并不是必需的，但是视图（View）能够实现数据有目的的显示。

在 View 中一般不包含程序上的逻辑，因此为了实现 View 上的数据刷新功能，View 需要访问它监视的数据模型（Model），应该事先在被它监视的数据那里注册。




Yaf默认模块的视图文件为application/views/index/index.phtml，Yaf提供了一个默认的模板引擎——Yaf\_View\_Simple来支持使用PHP编码的视图模板。

\begin{lstlisting}[language=HTML]
<html>
  <head>
    <title>Hello world</title>
  </head>
  <body>
     <?php echo $content; ?>
  </body>
</html>
\end{lstlisting}

运行上述的Yaf示例应用程序的输出类似于：


\begin{lstlisting}[language=bash]
<html>
  <head>
    <title>Hello world</title>
  </head>
  <body>
     hello world, yaf
  </body>
</html>
\end{lstlisting}

除了默认的视图引擎之外，Yaf也支持用户自定义自己的视图引擎（例如Smarty）。

\chapter{Yaf Router}

路由主要负责解析一个请求并且决定哪个module、哪个controller以及哪个action被请求，而且Yaf路由同时还定义自己的方式来实现用户自定义路由，因此路由是MVC模式中的重要组件。

为了方便自定义路由，Yaf采用了一种将路由器和路由协议分离的灵活的模式，也就是一个固定不变的路由器配合各种可自定义的路由协议来实现灵活多变的路由策略。

\section{Router Abstract}

作为一个应用中的路由组件是很重要的，理所当然的路由组件是抽象的，这样允许开发者很容易的设计出符合需求的自定义的路由协议。

虽然默认的路由组件其实足够好了，如果开发者需要一个非标准的路由协议时，仍然可以自定义一个自己的路由协议，无需采用默认的路由协议。

事实上，Yaf路由组件有两个部分：路由器(Yaf\_Router)和路由协议(Yaf\_Route\_Abstract)。

\subsection{Yaf\_Route\_Abstract}


路由协议主要负责匹配预先定义好的路由协议，也就是说，虽然只有一个路由器，但是可以有许多路由协议。

\subsection{Yaf\_Router}


路由器主要负责管理和运行路由链，并根据路由协议栈倒序依次调用各个路由协议，一直到某一个路由协议返回成功就说明匹配成功。

路由注册的顺序很重要，最后注册的路由协议——最先尝试路由，这就有个陷阱，请注意。

路由的过程发生派发过程的最开始，并且路由解析仅仅发生一次。

路由过程在任何控制器动作(Controller, Action)被派发之前被执行，一旦路由成功，路由器将会把解析出得到的信息传递给请求对象(Yaf\_Request\_Abstract object)，这些信息包括moduel、controller、action、用户params等，然后派发器(Yaf\_Dispatcher)就会按照这些信息派发正确的控制器动作。

路由器也有插件钩子，就是routerStartup和routerShutdown，它们在路由解析前后分别被调用。




\section{HTTP Routing}

\subsection{Yaf\_Router}

默认情况下的路由器是Yaf\_Router，默认使用的路由协议是Yaf\_Route\_Static。

\subsection{Yaf\_Router\_Static}


Yaf\_Router\_Static是基于HTTP路由的，它期望一个请求是HTTP请求并且请求对象是使用Yaf\_Request\_Http。





\section{URL Routing}

使用路由既可以很复杂，同时也能很简单，主要视应用而定。

配置一个基本的路由是很简单的，只要添加用户自己的路由协议给路由器即可，不同的路由协议如下所示：

\begin{compactitem}
\item Yaf\_Route\_Simple
\item Yaf\_Route\_Supervar
\item Yaf\_Route\_Static
\item Yaf\_Route\_Map
\item Yaf\_Route\_Rewrite
\item Yaf\_Route\_Regex
\end{compactitem}


首先来看路由器是如何让路由协议与之一起工作的，在用户添加任何路由协议之前必须要得到一个路由器(Yaf\_Router)实例，可以通过派发器的getRouter方法来得到默认的路由器：





\begin{example}
通过派遣器得到默认的路由器
\begin{lstlisting}[language=PHP]
<?php
$router = Yaf_Dispatcher::getInstance()->getRouter();
\end{lstlisting}
\end{example}


在得到路由器实例就可以向其添加自定义的一些路由协议，例如：

\begin{example}
添加自定义路由协议
\begin{lstlisting}[language=PHP]
<?php
$router = Yaf_Dispatcher::getInstance()->getRouter();
$router->addRoute('myRoute',$route);
$router->addRoute('myRoute1',$route);
\end{lstlisting}
\end{example}

除此之外，还可以直接在配置中定义自己的路由协议，例如



\begin{example}
在配置中定义自己的路由协议
\begin{lstlisting}[language=PHP]
[common]
; 自定义路由，注意顺序很重要
routes.regex.type = 'regex'
routes.regex.match = '#^/list/([^/]*)/([^/]*)$#'''
routes.regex.route.controller = Index
routes.regex.route.action = action
routes.regex.map.1 = name
routes.regex.map.2 = value
; 添加一个名字为simple的路由协议
routes.simple.type = 'simple'
routes.simple.controller = c
routes.simple.module = m
routes.simple.action = a
; 添加一个名字为supervar的路由协议
routes.supervar.type = 'supervar'
routes.supervar.varname = r

[product : common]
; product节是Yaf默认关心的节
; 添加一个名字为rewrite的路由协议
routes.rewrite.type = 'rewrite'
routes.rewrite.match = '/product/:name/:value'
\end{lstlisting}
\end{example}

路由协议的顺序很重要，Yaf保证添加顺序和在配置文件中的顺序相同。



\begin{example}
在Bootstrap中通过调用Yaf\_Router::addConfig添加定义在配置中的路由协议
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initRoute(Yaf_Dispatcher $dispatcher) {
        $router = Yaf_Dispatcher::getInstance()->getRouter();
        // 添加配置文件中的路由
        $router->addConfig(Yaf_Register::get('config')->routes);
    }
}
\end{lstlisting}
\end{example}

另外，路由器也可以提供给用户不同的方法来得到和设置包含在它内部的信息，例如一些重要的方法如下：

\begin{compactitem}
\item getCurrentRoute() - 在路由结束后获取起作用的路由协议
\item getRoute()
\item getRoutes()
\end{compactitem}

\subsection{Yaf\_Route\_Static}

默认的路由协议Yaf\_Route\_Static就是分析请求中的request\_uri，在去除掉base\_uri以后，获取到真正的负载路由信息的request\_uri片段。

具体的策略是, 根据\texttt{"/"}对request\_uri分段, 依次得到Module,Controller,Action, 在得到Module以后, 还需要根据Yaf\_Application::\$modules来判断Module是否是合法的Module, 如果不是, 则认为Module并没有体现在request\_uri中, 而把原Module当做Controller, 原Controller当做Action。


\begin{example}
默认的路由协议Yaf\_Route\_Static
\begin{lstlisting}[language=PHP]
<?php
/**
 * 对于请求request_uri为"/ap/foo/bar/dummy/1"
 * base_uri为"/ap"
 * 则最后参加路由的request_uri为"/foo/bar/dummy/1"
 * 然后, 通过对URL分段, 得到如下分节
 * foo, bar, dummy, 1
 * 然后判断foo是不是一个合法的Module, 如果不是, 则认为结果如下:
 */
array(
    'module' => '默认模块',
    'controller' => 'foo',
    'action' => 'bar',
    'params' => array(
        'dummy' => 1,
    )
);

/**
 * 而如果在配置文件中定义了ap.modules="Index,Foo",
 * 则此处就会认为foo是一个合法模块, 则结果如下
 */
array(
    'module' => 'foo',
    'controller' => 'bar',
    'action' => 'dummy',
    'params' => array(
        1 => NULL,
    )
);
\end{lstlisting}
\end{example}

当只有一段路由信息的时候，比如对于上面的例子, 请求的URI为/ap/foo，则默认路由和下面要提到的Yaf\_Route\_Supervar会首先判断ap.action\_prefer, 如果为真, 则把foo当做Action, 否则当做Controller。

\subsection{Yaf\_Route\_Simple}

Yaf\_Route\_Simple是基于请求中的query string来做路由的。

在初始化一个Yaf\_Route\_Simple路由协议的时候, 需要给出3个参数，这3个参数分别代表在query string中Module, Controller, Action的变量名。

\begin{example}
 Yaf\_Route\_Simple
\begin{lstlisting}[language=PHP]
<?php
/**
 * 指定3个变量名
 */
$route = new Yaf_Route_Simple("m", "c", "a");
$router->addRoute("name", $route);
/**
 * 对于如下请求: "http://domain.com/index.php?c=index&a=test
 * 能得到如下路由结果
 */
array(
    'module' => '默认模块',
    'controller' => 'index',
    'action' => 'test',
);
     
\end{lstlisting}
\end{example}

只有在query string中不包含任何3个参数之一的情况下, Yaf\_Route\_Simple才会返回失败, 将路由权交给下一个路由协议.

\subsection{Yaf\_Route\_Supervar}

Yaf\_Route\_Supervar和Yaf\_Route\_Simple相似, 都是在query string中获取路由信息, 不同的是, 它获取的是一个类似包含整个路由信息的request\_uri。


\begin{example}
Yaf\_Route\_Supervar
\begin{lstlisting}[language=PHP]
<?php
/**
 * 指定supervar变量名
 */
$route = new Yaf_Route_Supervar("r");
$router->addRoute("name", $route);
/**
 * 对于如下请求: "http://domain.com/index.php?r=/a/b/c
 * 能得到如下路由结果
 */
array(
    'module' => 'a',
    'controller' => 'b',
    'action' => 'c',
)
\end{lstlisting}
\end{example}

在query string中不包含supervar变量的时候, Yaf\_Route\_Supervar会返回失败, 将路由权交给下一个路由协议。

\subsection{Yaf\_Route\_Map}

Yaf\_Route\_Map议是一种简单的路由协议, 它将REQUEST\_URI中以\texttt{'/'}分割的节, 组合在一起, 形成一个分层的控制器或者动作的路由结果。

Yaf\_Route\_Map的构造函数接受两个参数，其中：

第一个参数表示路由结果是作为动作的路由结果,还是控制器的路由结果. 默认的是动作路由结果。

第二个参数是一个字符串, 表示一个分隔符, 如果设置了这个分隔符, 那么在REQUEST\_URI中, 分隔符之前的作为路由信息载体, 而之后的作为请求参数。

\begin{example}
映射路由协议
\begin{lstlisting}[language=PHP]
<?php
/**
 * 对于请求request_uri为"/ap/foo/bar"
 * base_uri为"/ap"
 * 则最后参加路由的request_uri为"/foo/bar"
 * 然后, 通过对URL分段, 得到如下分节
 * foo, bar
 * 组合在一起以后, 得到路由结果foo_bar
 * 然后根据在构造Yaf_Route_Map的时候, 是否指明了控制器优先,
 * 如果没有, 则把结果当做是动作的路由结果
 * 否则, 则认为是控制器的路由结果
 * 默认的, 控制器优先为FALSE
 */
\end{lstlisting}
\end{example}


\subsection{Yaf\_Route\_Rewrite}

Yaf\_Route\_Rewrite是一个强大的路由协议, 它能满足我们绝大部分的路由需求:




\begin{example}
Yaf\_Route\_Rewrite
\begin{lstlisting}[language=PHP]
<?php
//创建一个路由协议实例
$route = new Yaf_Route_Rewrite(
    'product/:ident', 
    array('controller' => 'products', 'action' => 'view')
);
//使用路由器装载路由协议
$router->addRoute('product', $route);
\end{lstlisting}
\end{example}

在这个例子中, 我们试图匹配Url指定到一个单一的产品, 就像\url{http://domain.com/product/choclolat-bar}。

为了实现这点, 我们在路由协议中传递了2个变量到路由协议Yaf\_Route\_Rewrite的构造函数，其中：

第一个变量\texttt{('product/:indent')}就是匹配的路径, 第二个变量(array变量)是路由到的动作控制器。

路径使用一个特别的标识来告诉路由协议如何匹配到路径中的每一个段，这个标识有两种，可以帮助我们创建我们的路由协议，如下所示：

\begin{compactitem}
\item \texttt{:}

冒号(:)指定了一个段,这个段包含一个变量用于传递到我们动作控制器中的变量,我们要设置好事先的变量名,比如在上面我们的变量名就是\texttt{'ident'},因此倘若访问\url{http://domian.com/product/chocoloate-bar}将会创建一个变量名为ident并且其值是\texttt{'chocoloate-bar'}的变量,然后就可以在动作控制器ProductsController/viewAction下获取到它的值：\texttt{\$this->getRequest()->getParam('ident');}


\item \texttt{*}

星号(*)被用做一个通配符, 意思就是在Url中它后面的所有段都将作为一个通配数据被存储. 例如,如果我们有路径\texttt{'path/product/:ident/*'}(就是路由协议中设置的第一个变量), 并且我们访问的Url为\url{http://domain.com/product/chocolate-bar/test/value1/another/value2},那么所有的在\texttt{'chocolate-bar'}后面的段都将被做成变量名/值对,因此这样会给我们下面的结果：

\begin{lstlisting}[language=PHP]
ident = chocolate-bar
test = value1
another = value2
\end{lstlisting}
\end{compactitem}

这种行为也就是我们平常默认使用的路由协议的行为,记住变量名/值要成对出现,否则像/test/value1/这样的将不会这种另一个变量,我们有静态的路由协议部分,这些部分简单地被匹配来满足我们的路由协议,在我们的例子中,静态部分就是product，就像现在看到的那样，Yaf\_Route\_Rewrite路由协议提供给我们极大的灵活性来控制我们的路由。

\subsection{Yaf\_Route\_Regex}

基本的路由操作虽然可以满足需求，然而它们会有一些限制，这就是我们为什么要引进正则路由(Yaf\_Route\_Regex)的原因。

正则路由给予Yaf应用程序preg正则的全部力量，同时也使得我们的路由协议变得更加复杂了一些，不过正则路由协议比其他路由协议要灵活一点。

之前的示例改用使用正则路由改写为如下的形式：

\begin{example}
Yaf\_Route\_Regex
\begin{lstlisting}[language=PHP]
<?php
$route = new Yaf_Route_Regex(
   'product/([a-zA-Z-_0-9]+)',
   array(
        'controller'=>'products',
        'action' => 'view'
   )
);
$router->addRoute('product',$route);
\end{lstlisting}
\end{example}

可以看到，现在移动正则到path(构造函数的第一个参数)中，这个正则路由协议现在应该是匹配是一个数字、字母、-和\_组成的ident变量的字符提供给我们。

但是，你一定会问，ident变量在哪呢？如果使用了这个正则路由协议,我们可以通过变量1(one)来获取其值，即可以在控制器里通过\texttt{\$this->getRequest()->getParam(1)}来获取，其实这里就是反向引用中的\texttt{\textbackslash 1}。

使用正则路由时，无法记住或者弄清每一个数字代表的是什么变量，因此为了改变这点,正则路由协议的构造函数提供了第3个参数来完成数字到变量名的映射，例如：




\begin{example}
Yaf\_Route\_Regex的构造函数的第三个参数可以完成数字到变量名的映射
\begin{lstlisting}[language=PHP]
<?php
$route = new Yaf_Route_Regex(
    'product/[a-zA-Z-_0-9]+',
    array(
        'controller'=>'products',
        'action'=>'view'
   ),
   array(
        // 完成数字到字符变量的映射
        1=>'ident'
   )
);
$router->addRoute('product',$route);
\end{lstlisting}
\end{example}


上述的示例将变量1映射到了ident变量名,这样就设置了ident变量,同时开发者也可以在控制器里面获取到它的值。

\subsection{Yaf\_Route\_Interface}

这个世界上没有绝对的事情，所以万一现在所有的路由协议都不能满足需求, 那么可以自己实现你自己的路由协议，只要申明自定义路由协议实现了Yaf\_Route\_Interface接口即可。



\chapter{Yaf Plugin}

Yaf支持用户自己定义插件来扩展Yaf的功能。

Yaf插件本身都是一些类，它们必须继承自Yaf\_Plugin\_Abstract，而且插件必须在Yaf中显式地注册才能发挥功效，才能让Yaf在合适的时机调用插件来发挥作用。

Yaf\_Plugin\_Abstract是Yaf的插件基类，所有的插件类都需要继承自这个基类，而且Yaf\_Plugin\_Abstract定义的7个方法会依次在合适的时机被调用。

对于Yaf插件类来说，不需要全部关心Yaf自己内置的Hook，用户只需要在插件类中定义和Yaf Hook事件同名的方法，那么这个方法就会在该事件触发的时候被调用。

Yaf插件的方法可以接受两个参数——Yaf\_Request\_Abstract的实例和Yaf\_Response\_Abstract的实例。

下面是一个Yaf插件类的例子：

\begin{lstlisting}[language=PHP]
<?php
class UserPlugin extends Yaf_Plugin_Abstract {
    public function routerStartup(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response) {
    
    }
    
    public function routerShutdown(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response){
    
    }
}
\end{lstlisting}

在上述的示例中，Yaf插件只关心两个事件，所以就只定义了两个方法。

默认情况下，Yaf插件应该放置在APPLICATION\_PATH下的plugins目录中，这样如果加载器在自动加载过程中发现插件类就会在这个目录下查找。

开发者同样也可以把插件类保存到其他位置，只要可以把这个类加载进来即可。


\section{Yaf\_Request\_Abstract}



\section{Yaf\_Response\_Abstract}



\section{Yaf\_Bootstrap\_Abstract}

如果需要Yaf插件生效，还需要向Yaf\_Dispatcher注册，因此一般的插件注册都会在Bootstrap中进行。

\begin{example}
注册插件
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initPlugin(Yaf_Dispatcher $dispatcher){
         $user = new UserPlugin();
         $dispacher->registerPlugin($user);
    }
}
\end{lstlisting}
\end{example}

插件有两种部署方式，一种是部署在plugins目录下，通过名称中的后缀(可通过yaf.name\_suffix和yaf.name\_separator来改变具体命名形式)来使得自动加载器可以正确加载。

另外一种部署插件的方式是放置在类库，由普通加载规则加载，但是无论哪种方式，用户定义的插件都需要继承自Yaf\_Plugin\_Abstract。


\chapter{Yaf\_Application}

Yaf\_Application为应用提供了一个辅助设施。



Yaf\_Application提供了可重用的资源、常见的和模块化的引导类以及依赖检查。

和Yii框架的CApplication类一样，Yaf的Yaf\_Application类也实现了单例模式，而且Yaf\_Application不能被序列化和反序列化， 否则当尝试使用PHPUnit来为Yaf写一些测试用例的时候会造成一些不必要的麻烦。

开发者可以使用PHPUnit的@backupGlobals注释来控制全局变量的备份和恢复操作， 从而可以解决上述这个问题。

\section{Synopsis}



\begin{lstlisting}[language=PHP]
final Yaf_Application {
  /* 属性 */
  protected Yaf_Config $config ;
  protected Yaf_Dispatcher $dispatcher ;
  protected static Yaf_Application $_app ;
  protected string $_modules ;
  protected bool $_running = FALSE ;
  protected string $_environ ;
  protected int $_err_no;
  protected string $_err_msg;
  /* 方法 */
  public static void app ( void )
  public Yaf_Application bootstrap ([ Yaf_Bootstrap_Abstract $bootstrap ] )
  public Yaf_Application clearLastError ( void )
  private void __clone ( void )
  public __construct ( mixed $config [, string $envrion = yaf.environ ] )
  public void __destruct ( void )
  public string environ ( void )
  public void execute ( callable $entry , string $... )
  public Yaf_Application getAppDirectory ( void )
  public Yaf_Config_Abstract getConfig ( void )
  public Yaf_Dispatcher getDispatcher ( void )
  public string getLastErrorMsg ( void )
  public int getLastErrorNo ( void )
  public array getModules ( void )
  public Yaf_Response_Abstract run ( void )
  public Yaf_Application setAppDirectory ( string $directory )
  private void __sleep ( void )
  private void __wakeup ( void )
}
\end{lstlisting}



\section{Property}


\subsection{\$config}

全局配置实例。

\subsection{\$dispatcher}

Yaf\_Dispatcher实例。

\subsection{\$\_app}

Yaf\_Application实现了单例模式来保存当前实例。

\subsection{\$\_modules}

已存在的模块名（从配置文件的application.modules读取）。


\subsection{\$\_running}

指明当前的Yaf\_Application实例是否已经运行。

\subsection{\$\_environ}

当前的环境名（也就是Yaf\_Application在读取配置时获得的配置节名字）。

\section{Method}


\subsection{Yaf\_Application::app()}

Yaf\_Application::app()方法没有参数，可以获取当前的Yaf\_Application实例。

\begin{lstlisting}[language=PHP]
public static void Yaf_Application::app ( void )
\end{lstlisting}

返回值为当前的Yaf\_Application实例（一个单例模式的对象）， 如果在调用之前没有初始化一个Yaf\_Application实例的话，它将返回NULL。

也可以使用Yaf\_Dispatcher::getApplication()来得到Yaf\_Application的实例。


\begin{lstlisting}[language=PHP]
<?php
$config = array(
        "ap" => array(
                "directory" => "/usr/local/www/ap",
        ),
);
$app = new Yaf_Application($config);
assert($app === Yaf_Application::app());
\end{lstlisting}








\subsection{Yaf\_Application::bootstrap()}

调用bootstrap()，可以传入一个Yaf\_Bootstrap\_Abstract对象作为可选参数，并返回一个Yaf\_Application实例化对象。

\begin{lstlisting}[language=PHP]
public void Yaf_Application::bootstrap ([ Yaf_Bootstrap_Abstract $bootstrap ] )
\end{lstlisting}

具体来说，Yaf\_Application::bootstrap()方法会指示Yaf\_Application去寻找Bootstrap.php（默认为application.directory/Bootstrap.php），并按照申明的顺序，执行所有在Bootstrap类中定义的以\_init开头的方法。 

如果没有提供变量bootstrap，Yaf默认会去application.directory中寻找Bootstrap。

\begin{lstlisting}[language=PHP]
<?php
/**
 * This file should be under the APPLICATION_PATH . "/application/"
 * (which was defined in the config passed to Yaf_Application).
 * and named Bootstrap.php,  so the Yaf_Application can find it 
 */
class Bootstrap extends Yaf_Bootstrap_Abstract {
   function _initConfig(Yaf_Dispatcher $dispatcher) {
      echo "1st called\n";
   }
   function _initPlugin($dispatcher) {
      echo "2nd called\n";
   }
}
\end{lstlisting}

\begin{example}
Yaf\_Application::bootstrap()示例
\begin{lstlisting}[language=PHP]
defined('APPLICATION_PATH')  // APPLICATION_PATH will be used in the ini config file
   || define('APPLICATION_PATH', __DIR__); // __DIR__
$app = new Yaf_Application(APPLICATION_PATH.'/conf/application.ini');
$app->bootstrap();
// 以上例程的输出类似于：
1st called
2nd called
\end{lstlisting}
\end{example}

Bootstrap类中定义的方法一般用作在处理请求之前，做一些个性化定制。


\begin{example}
Yaf\_Application::bootstrap()载入Session类和Database类
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract 
{
   public function _initSession(Yaf_Dispatcher $dispatcher) {
       $session = new Vender\Session();
       $session->start();
   }
   public function _initDatabase(Yaf_Dispatcher $dispatcher) {
       $config = Yaf_Application::app()->getConfig()->application->database;
       Yaf_Registry::set('db', Vendor\Database($config));
   }
}
\end{lstlisting}
\end{example}

Bootstrap本身不会去调用run()，因此还需要在bootstrap()之后调用Yaf\_Application::run()来运行Yaf\_Application实例，并返回Yaf\_Application实例。



\subsection{Yaf\_Application::clearLastError()}

clearLastError()方法没有参数。

\begin{lstlisting}[language=PHP]
public Yaf_Application Yaf_Application::clearLastError ( void )
\end{lstlisting}

清除最后的错误信息，开发者可以自定义错误处理器。


\begin{lstlisting}[language=PHP]
<?php
function error_handler($errno,$errstr,$errfile,$errline) {
   Yaf_Application::app()->clearLastError();
   var_dump(Yaf_Application::app()->getLastErrorNo());
}
$config = array(
   "application"=>array(
      "directory"=>"/tmp/notexists",
      "dispatcher"=>array(
          // trigger error instead of throw exception when error occure
          "throwException"=>0,
      ),
   ),
);
$app = new Yaf_Application($config);
$app->getDispatcher()->setErrorHandler("error_handler",E_RECOVERABLE_ERROR);
$app->run();
// 以上例程的输出类似于：
// int(0)
\end{lstlisting}





\subsection{Yaf\_Application::\_\_clone()}

Yaf\_Application类不允许被克隆，而且\_\_clone()函数没有参数。






\begin{lstlisting}[language=PHP]
private void Yaf_Application::__clone ( void )
\end{lstlisting}





\subsection{Yaf\_Application::\_\_construct(mixed \$config,string \$section = yaf.environ)}

构造函数可以初始化一个 Yaf\_Application实例，如果传入的\$config是一个INI文件，那么需要在\$section中指明要读取的配置节。




\begin{lstlisting}[language=PHP]
public Yaf_Application::__construct ( mixed $config [, string $envrion ] )
\end{lstlisting}

\$config是一个包含关联数组的配置, 或者是一个指向ini格式的配置文件的路径的字符串，或者是一个Yaf\_Config\_Abstract的实例。

\begin{compactitem}
\item \$config包含关联数组的配置, 或者一个指向ini格式的配置文件的路径的字符串。
\item \$environ则指示应该载入product还是dev段的配置信息。
\end{compactitem}




如果是一个ini配置文件，那么配置文件中应该有一个定义了yaf.environ 的配置节，这个在生产环境中是默认的。

如果使用了ini配置文件作为应用配置的容器，可以打开yaf.cache\_config 来提升性能。

\begin{lstlisting}[language=PHP]
[product]
;this one should alway be defined, and have no default value
application.directory=APPLICATION_PATH

;following configs have default value, you may no need to define them
application.library = APPLICATION_PATH . "/library"
application.dispatcher.throwException=1
application.dispatcher.catchException=1

application.baseUri=""

;the php script ext name
ap.ext=php

;the view template ext name
ap.view.ext=phtml

ap.dispatcher.defaultModuel=Index
ap.dispatcher.defaultController=Index
ap.dispatcher.defaultAction=index

;defined modules
ap.modules=Index
\end{lstlisting}


\begin{lstlisting}[language=PHP]
<?php
defined('APPLICATION_PATH')                  // APPLICATION_PATH will be used in the ini config file
    || define('APPLICATION_PATH', __DIR__)); //__DIR__ 

$app = new Yaf_Application(APPLICATION_PATH.'/conf/application.ini');
$app->bootstrap()->run();
\end{lstlisting}

向Yaf\_Application传入的配置也可以是一个数组，例如：

\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);

/** Yaf_Application */
$app = new Yaf_Application($config);
// 输出类似如下：
// object(Yaf_Application)#1 (6) {
// ...
// }
$app->bootstrap()->run();
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::\_\_destruct()}

析构函数（没有参数）






\begin{lstlisting}[language=PHP]
public void Yaf_Application::__destruct ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::environ()}

获取当前Yaf\_Application的环境名（例如product或dev），它被定义在yaf.environ（相当于\texttt{ini\_get("yaf.environ")}），默认为product。






\begin{lstlisting}[language=PHP]
public void Yaf_Application::environ ( void )
\end{lstlisting}

environ()方法没有参数。

\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);

/** Yaf_Application */
$app = new Yaf_Application($config);
print_r($app->environ());
// 以上例程的输出类似于：
// product
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::execute()}

运行回调函数






\begin{lstlisting}[language=PHP]
public void Yaf_Application::execute ( callable $entry , string $... )
\end{lstlisting}

或者

\begin{lstlisting}[language=PHP]
public void Yaf_Application::execute ( callable $entry ,  mixed  $parameter = NULL,$parameter  $... = NULL )
\end{lstlisting}


execute()方法通常用于在cron任务中运行Yaf\_Application，而且在cron任务中也可以使用autoloader和Bootstrap机制。

\begin{compactitem}
\item \$entry是一个有效的回调函数
\item \texttt{\$...}是零个或多个要传递给函数的参数
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
function main($argc,$argv) {

}
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);
/* Yaf_Application */
$app = new Yaf_Application($config);
$app->execute("main", $argc,  $argv);
\end{lstlisting}

在Yaf\_Application的环境下, execute()可以运行一个用户自定义函数过程，主要用在使用Yaf做简单的命令行脚本的时候应用Yaf的外围环境（例如自动加载、配置和视图引擎等）。

如果需要使用Yaf的路由分发，也就是说如果是需要在CLI下全功能运行Yaf，则需要进行手动进行路由派发。

\texttt{\$entry}是要运行的函数或方法，可以通过\texttt{array(\$obj,"method\_name")}来定义。

execute()允许传入一个或多个要传递给函数的参数，而且execute()可以把被调用函数或者方法的返回值的返回给调用方。

\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::getAppDirectory()}

获取Yaf应用程序所在的目录






\begin{lstlisting}[language=PHP]
public Yaf_Application Yaf_Application::getAppDirectory ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::getConfig()}

获取Yaf\_Config\_Abstract的实例（也就是Yaf\_Application读取的配置项）。






\begin{lstlisting}[language=PHP]
public Yaf_Config_Abstract Yaf_Application::getConfig ( void )
\end{lstlisting}

getConfig()方法没有参数，返回值是一个Yaf\_Config\_Abstract类的实例。

\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);

/** Yaf_Application */
$app = new Yaf_Application($config);
print_r($app->getConfig());
// 以上例程的输出类似于：
// Yaf_Config_Simple Object
// (
//    [_config:protected] => Array
//        (
//            [application] => Array
//                (
//                    [directory] => /home/laruence/local/www/htdocs/application
//                )
//
//        )
//
//    [_readonly:protected] => 1
// )
\end{lstlisting}






\subsection{Yaf\_Application::getDispatcher()}

获取当前Yaf\_Dispatcher的实例（派发器实例）。



\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Application::getDispatcher ( void )
\end{lstlisting}


\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);

/** Yaf_Application */
$app = new Yaf_Application($config);
print_r($app->getDispatcher());
// 以上例程的输出类似于：
// Yaf_Dispatcher Object
// (
//     [_router:protected] => Yaf_Router Object
//         (
//             [_routes:protected] => Array
//                 (
//                     [_default] => Yaf_Route_Static Object
//                         (
//                         )
//                 )
//             [_current:protected] => 
//         )
//     [_view:protected] => 
//     [_request:protected] => Yaf_Request_Http Object
//         (
//             [module] => 
//             [controller] => 
//             [action] => 
//             [method] => Cli
//             [params:protected] => Array
//                 (
//                 )
//             [language:protected] => 
//             [_exception:protected] => 
//             [_base_uri:protected] => 
//             [uri:protected] => 
//             [dispatched:protected] => 
//             [routed:protected] => 
//         )
//     [_plugins:protected] => Array
//         (
//         )
//     [_auto_render:protected] => 1
//     [_return_response:protected] => 
//     [_instantly_flush:protected] => 
//     [_default_module:protected] => Index
//     [_default_controller:protected] => Index
//     [_default_action:protected] => index
//     [_response] => Yaf_Response_Cli Object
//         (
//             [_header:protected] => Array
//                 (
//                 )
//             [_body:protected] => 
//             [_sendheader:protected] => 
//         )
// )

// 可以继续设置Bootstrap并执行相关设置
$app->getDispatcher()->setAppDirectory(APPLICATION_PATH."/action/")->getApplication()->bootstrap()->run();

// 或者，可以通过派发器进行相关设置
$dispatcher = Yaf_Dispatcher::getInstance()->setAppDirectory(APPLICATION_PATH."/action/")->getApplication()->bootstrap()->run();
\end{lstlisting}



\subsection{Yaf\_Application::getLastErrorMsg()}

获取最近产生的错误的错误信息。






\begin{lstlisting}[language=PHP]
public string Yaf_Application::getLastErrorMsg ( void )
\end{lstlisting}

\begin{example}
getLstErrorMsg()示例
\begin{lstlisting}[language=PHP]
<?php
function error_handler($errno, $errstr, $errfile, $errline) {
   var_dump(Yaf_Application::app()->getLastErrorMsg());
}

$config = array(                   
 "application" => array(
   "directory" => "/tmp/notexists",
     "dispatcher" => array(
       "throwException" => 0, //trigger error instead of throw exception when error occure
      ),
  ),
);

$app = new Yaf_Application($config);
$app->getDispatcher()->setErrorHandler("error_handler", E_RECOVERABLE_ERROR);
$app->run();
// 以上例程的输出类似于：
// string(69) "Could not find controller script /tmp/notexists/controllers/Index.php"
\end{lstlisting}
\end{example}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::getLastErrorNo()}

获取最近产生的错误的错误代码。






\begin{lstlisting}[language=PHP]
public int Yaf_Application::getLastErrorNo ( void )
\end{lstlisting}


\begin{example}
getLstErrorNo()示例
\begin{lstlisting}[language=PHP]
<?php
function error_handler($errno, $errstr, $errfile, $errline) {
   var_dump(Yaf_Application::app()->getLastErrorNo());
   var_dump(Yaf_Application::app()->getLastErrorNo() == YAF_ERR_NOTFOUND_CONTROLLER);
}

$config = array(
  "application" => array(
   "directory" => "/tmp/notexists",
     "dispatcher" => array(
       "throwException" => 0, //trigger error instead of throw exception when error occure
      ),
  ),
);

$app = new Yaf_Application($config);
$app->getDispatcher()->setErrorHandler("error_handler", E_RECOVERABLE_ERROR);
$app->run();
// 以上例程的输出类似于：
// int(516)
// bool(true)
\end{lstlisting}
\end{example}





\subsection{Yaf\_Application::getModules()}

获取在配置文件中申明的模块，如果没有申明，它的默认值将是``Index"。





\begin{lstlisting}[language=PHP]
public array Yaf_Application::getModules ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "application" => array(
        "directory" => realpath(dirname(__FILE__)) . "/application",
    ),
);

/** Yaf_Application */
$app = new Yaf_Application($config);
print_r($app->getModules());
// 以上例程的输出类似于：
// Array
// (
//     [0] => Index
// )
\end{lstlisting}


\subsection{Yaf\_Application::run()}

运行Yaf\_Application()，run()方法本身没有参数。





\begin{lstlisting}[language=PHP]
public void Yaf_Application::run ( void )
\end{lstlisting}

具体来说，run()方法运行一个Yaf\_Application，开始接受并处理请求、分发路由并做出相应的响应，最终将响应返回给客户端。

run()方法只能调用一次，多次调用并不会有特殊效果。

\begin{lstlisting}[language=PHP]
<?php
$config = array(
        "application" => array(
                "directory" => "/usr/local/www/yaf",
        ),
);
$app = new Yaf_Application($config);
$app->run();
\end{lstlisting}


\subsection{Yaf\_Application::setAppDirectory()}

改变Yaf应用程序的目录到指定的目录。






\begin{lstlisting}[language=PHP]
public Yaf_Application Yaf_Application::setAppDirectory ( string $directory )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Application::\_\_sleep()}

Yaf\_Application不能被序列化。






\begin{lstlisting}[language=PHP]
private void Yaf_Application::__sleep ( void )
\end{lstlisting}



\subsection{Yaf\_Application::\_\_wakeup()}

Yaf\_Application不能被反序列化。







\begin{lstlisting}[language=PHP]
private void Yaf_Application::__wakeup ( void )
\end{lstlisting}

\chapter{Yaf\_Bootstrap}

Bootstrap是Yaf提供的一个全局配置的入口，开发者可以在Bootstrap.php中进行全局自定义操作。

\begin{lstlisting}[language=PHP]
$app = new Yaf\_Application($config);
$app
->bootstrap() // 可选的调用
->run();
\end{lstlisting}


默认情况下，在一个Yaf\_Application被实例化之后，运行Yaf\_Application::run()之前，Yaf允许开发者可选的运行Yaf\_Application::bootstrap()。

\begin{compactitem}
\item 运行Bootstrap


\begin{lstlisting}[language=PHP]
$app = new Yaf_Application($config);
$app->boostrap()
       ->run();
\end{lstlisting}

\item 不运行Bootstrap

\begin{lstlisting}[language=PHP]
$app = new Yaf\_Application($config);
$app->run();
\end{lstlisting}

\end{compactitem}



\chapter{Yaf\_Bootstrap\_Abstract}

Yaf\_Bootstrap\_Abstract提供了一个可以定制Yaf\_Application的最早的时机，它相当于一段引导或入口程序。

Yaf\_Bootstrap\_Abstract本身没有定义任何方法，但是任何继承自Yaf\_Bootstrap\_Abstract的类中的以\_init开头的方法都会在Yaf\_Application::bootstrap()时刻被调用，调用的顺序和这些方法在类中的定义顺序相同，Yaf保证这种调用顺序。

具体来说，Bootstrap是用来在Application运行(run)之前做一些初始化工作的机制，开发者可以通过继承Yaf\_Bootstrap\_Abstract 来定义自己的Bootstrap类。

当bootstrap()方法被调用的时刻，Yaf\_Application就会默认的在APPLICATION\_PATH下寻找Bootstrap.php，开发者也可以通过在配置文件中修改application.bootstrap来变更Bootstrap类的位置。

application.bootstrap(string)-Bootstrap类脚本文件的绝对路径（默认为\$document\_root/application/Bootstrap.php）。


在Bootstrap.php中必须定义一个Bootstrap类，而且这个类也必须继承自Yaf\_Bootstrap\_Abstract。

实例化成功之后, 所有在Bootstrap类中定义的，以\_init开头的方法都会被依次调用，而且这些方法都可以接受一个Yaf\_Dispatcher实例作为参数。

在Bootstrap类中所有以``\_init"开头的公有的方法，都会被按照定义顺序依次在Yaf\_Application::bootstrap()方法被调用的时刻进行调用和执行。

Boostrap类中定义的\_init开头的方法都可以接受一个Yaf\_Dispatcher参数。

下面是一个Bootstrap.php的例子。

\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
   public function _initConfig(Yaf_Dispatcher $dispatcher) {
       var_dump(__METHOD__);
   }
   public function _initPlugin(Yaf_Dispatcher $dispatcher) {
       var_dump(__METHOD__);
   }
}
$config = array(
   "application"=>array(
       "directory"=>dirname(__FILE__)."/application";
   ),
);
$app=new Yaf_Application($config);
$app->bootstrap();

// 以上例程的输出类似于：
// string(22) "Bootstrap::_initConfig"
// string(22) "Bootstrap::_initPlugin"
\end{lstlisting}

\begin{example}
Bootstrap按定义顺序执行\_init开头的方法
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
   public function _initConfig() {
        $config = Yaf_Application::app()->getConfig();
        Yaf_Registry::set('config',$config);
   }
   
   public function _initDefaultName(Yaf_Dispatcher $dispatcher){
        $dispatcher->setDefaultModule('Index')->setDefaultController('Index')->setDefaultAction('index');
   }
}
\end{lstlisting}
\end{example}


方法在Bootstrap类中的定义出现顺序，决定了它们的被调用顺序。例如，对于上面的例子，\_initConfig会第一个被调用。

\begin{lstlisting}[language=PHP]
<?php
/**
 * 所有在Bootstrap类中, 以_init开头的方法, 都会被Yaf调用,
 * 这些方法, 都接受一个参数:Yaf_Dispatcher $dispatcher
 * 调用的次序, 和申明的次序相同
 */
class Bootstrap extends Yaf_Bootstrap_Abstract {
    /**
     * 注册一个插件
     * 插件的目录是在application_directory/plugins
     */
    public function _initPlugin(Yaf_Dispatcher $dispatcher) {
        $user = new UserPlugin();
        $dispatcher->registerPlugin($user);
    }

    /**
     * 添加配置中的路由
     */
    public function _initRoute(Yaf_Dispatcher $dispatcher) {
        $router = Yaf_Dispatcher::getInstance()->getRouter();
        $router->addConfig(Yaf_Registry::get("config")->routes);
        /**
         * 添加一个路由
         */
        $route = new Yaf_Route_Rewrite(
            "/product/list/:id/",
            array(
                "controller" => "product",
                "action" => "info",
            )
        );
        $router->addRoute('dummy', $route);
    }

    /**
     * 自定义视图引擎
     */
    public function _initSmarty(Yaf_Dispatcher $dispatcher) {
        $smarty = new Smarty_Adapter(null, Yaf_Registry::get("config")->get("smarty"));
        Yaf_Dispatcher::getInstance()->setView($smarty);
    }
}


//在默认的入口文件index.php中,Yaf_Application将会读取配置文件中在php.ini中设置的application.environ的配置节
$application = new Yaf_Application("conf/sample.ini");

/* 如果没有关闭自动response(通过Yaf_Dispatcher::getInstance()->autoResponse(FALSE)),
 * 则$response会被自动输出, 此处也不需要再次输出Response
 */
$response = $application->bootstrap()/*实例化Bootstrap, 依次调用Bootstrap中所有_init开头的方法*/
    ->run();
\end{lstlisting}

\chapter{Yaf\_Command}

Yaf支持在命令行下运行，以此来方便开发人员调试。

为了让Yaf在命令行模式下运行, 有两种方式，其中：

第一种方式是专门为用Yaf开发Contab等任务脚本设计的方式, 对Yaf的唯一要求就是能自动加载所需要的Model或者类库，所以可以简单的通过Yaf\_Application::execute()来实现。

第二种方式是为了在命令行下模拟请求, 运行和Web请求一样的流程, 从而可以用来在命令行下测试Yaf应用。

\section{Yaf\_Request\_Simple}


对于第二种方式, 唯一的关键点就是请求体, 默认的请求是由Yaf\_Application实例化, 并且交给Yaf\_Dispatcher的, 而在命令行模式下, Yaf\_Application并不能正确的实例化一个命令行请求, 所以需要变更一下, 请求需要手动实例化。

\begin{example}
实例化一个Yaf\_Request\_Simple
\begin{lstlisting}[language=PHP]
<?php
$request = new Yaf_Request_Simple();
print_r($request);
\end{lstlisting}
\end{example}

Yaf\_Request\_Simple类的构造函数最多接受5个可选参数，也可以不接受任何参数。


\begin{lstlisting}[language=PHP]
$ php request.php
Yaf_Request_Simple Object
(
    [module] => 
    [controller] => 
    [action] => 
    [method] => CLI
    [params:protected] => Array
        (
        )

    [language:protected] => 
    [_exception:protected] => 
    [_base_uri:protected] => 
    [uri:protected] => 
    [dispatched:protected] => 
    [routed:protected] => 
)
\end{lstlisting}



如果未指定构造函数参数，那么Yaf\_Request\_Simple就会在命令行参数中寻找一个字符串参数，如果找到了就会把请求的request\_uri置为这个字符串。


\begin{example}
向Yaf\_Request\_Simple实例传入命令行参数
\begin{lstlisting}[language=PHP]
$ php request.php "request_uir=/index/hello"
Yaf_Request_Simple Object
(
[module] =>
[controller] =>
[action] =>
[method] => CLI
[params:protected] => Array
(
)

[language:protected] =>
[_base_uri:protected] =>
[uri:protected] => index/hello  //注意这里
[dispatched:protected] =>
[routed:protected] =>
)
\end{lstlisting}
\end{example}





也可以完全指定Yaf\_Request\_Simple::\_\_construct()的5个参数，例如：

\begin{example}
完全指定Yaf\_Request\_Simple::\_\_construct()的5个参数
\begin{lstlisting}[language=PHP]
<?php
$request = new Yaf_Request_Simple("CLI", "Index", "Controller", "Hello", array("para" => 2));
print_r($requst);
\end{lstlisting}
\end{example}

上述示例的输出如下：

\begin{lstlisting}[language=PHP]
$ php request.php
Yaf_Request_Simple Object
(
[module] => Index
[controller] => Controller
[action] => Hello
[method] => CLI
[params:protected] => Array
(
[para] => 2
)

[language:protected] =>
[_base_uri:protected] =>
[uri:protected] =>
[dispatched:protected] =>
[routed:protected] => 1    //注意这里
)
\end{lstlisting}

可以看到，一个比较特别的地方就是，routed属性变为了TRUE, 这就代表着如果手动指定了构造函数的参数，那么这个请求不会再经过路由, 而直接是路由完成状态。

在命令行中的请求已经改造完成后接下来还需要把传统的入口文件修改为手动分发请求的模式。

\begin{example}
Yaf传统的入口文件
\begin{lstlisting}[language=PHP]
<?php
$app = new Yaf_Application("conf.ini");
$app->bootstrap()->run();
\end{lstlisting}
\end{example}

通过手动分发请求可以通过在命令行中运行Yaf。

\begin{example}
Yaf在命令行中分发请求
\begin{lstlisting}[language=PHP]
<?php
$app = new Yaf_Application("conf.ini");
$app->getDispatcher()->dispatch(new Yaf_Request_Simple());
\end{lstlisting}
\end{example}


\chapter{Yaf\_Dispatcher}

Yaf\_Dispatcher用于初始化处理请求的运行环境，并实现了MVC中的C分发。

Yaf\_Dispatcher由Yaf\_Application负责初始化, 然后由Yaf\_Application::run启动, Yaf\_Dispatcher实例协调路由来的请求，并分发和执行发现的动作，然后收集动作产生的响应，输出响应给请求者，并在整个过程完成以后返回响应。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Dispatcher。

Yaf\_Dispatcher是单例模式运行的，也就是说自始至终只生成一个Yaf\_Dispatcher实例，因此可以把它看成是在分发过程中生成的对象的注册表，可以从中获取到分发过程中产生的对象。

\section{Synopsis}


\begin{lstlisting}[language=PHP]
final Yaf_Dispatcher {
  /* 属性 */
  protected $_router ;
  protected $_view ;
  protected $_request ;
  protected $_plugins ;
  protected static $_instance ;
  protected $_auto_render ;
  protected $_return_response ;
  protected $_instantly_flush ;
  protected $_default_module ;
  protected $_default_controller ;
  protected $_default_action ;
  /* 方法 */
  public Yaf_Dispatcher autoRender ( bool $flag )
  public Yaf_Dispatcher catchException ([ bool $flag ] )
  private void __clone ( void )
  private __construct ( void )
  public bool disableView ( void )
  public Yaf_Response_Abstract dispatch ( Yaf_Request_Abstract $request )
  public Yaf_Dispatcher enableView ( void )
  public Yaf_Dispatcher flushInstantly ( bool $flag )
  public Yaf_Application getApplication ( void )
  public static Yaf_Dispatcher getInstance ( void )
  public Yaf_Request_Abstract getRequest ( void )
  public Yaf_Router getRouter ( void )
  public Yaf_View_Interface initView ( string $templates_dir [, array $options ] )
  public Yaf_Dispatcher registerPlugin ( Yaf_Plugin_Abstract $plugin )
  public Yaf_Dispatcher returnResponse ( bool $flag )
  public Yaf_Dispatcher setDefaultAction ( string $action )
  public Yaf_Dispatcher setDefaultController ( string $controller )
  public Yaf_Dispatcher setDefaultModule ( string $module )
  public Yaf_Dispatcher setErrorHandler ( call $callback , int $error_types )
  public Yaf_Dispatcher setRequest ( Yaf_Request_Abstract $request )
  public Yaf_Dispatcher setView ( Yaf_View_Interface $view )
  private void __sleep ( void )
  public Yaf_Dispatcher throwException ([ bool $flag ] )
  private void __wakeup ( void )
}
\end{lstlisting}



\section{Property}





\subsection{\$\_router}

当前的路由器，而且随着路由器和路由协议的分离, 各种路由都可以通过配置路由协议来实现, 也就取消了自定义路由器的功能。

\subsection{\$\_view}

当前的视图引擎, 可以通过Yaf\_Dispatcher::setView来替换视图引擎为自定义视图引擎(比如Smary/Firekylin等常见引擎)

\subsection{\$\_request}

当前请求

\subsection{\$\_plugins}

已经注册的插件, 插件一经注册, 就不能更改和删除

\subsection{\$\_instance}

Yaf\_Dispatcher实现了单例模式，此属性保存当前实例。

\subsection{\$\_auto\_render}

是否在动作执行完成后, 调用视图引擎的render方法, 产生响应. 可以通过Yaf\_Dispatcher::disableView和Yaf\_Dispatcher::enableView来切换开关状态。

\subsection{\$\_return\_response}

是否在产生响应以后, 不自动输出给客户端, 而是返回给调用者. 可以通过Yaf\_Dispatcher::returnResponse来切换开关状态。


\subsection{\$\_instantly\_flush}

是否在有输出的时候, 直接响应给客户端, 不写入Yaf\_Response\_Abstract对象。

如果\$\_instantly\_flush属性为TRUE, 那么将忽略Yaf\_Dispatcher::\$\_return\_response。




\subsection{\$\_default\_module}

默认的模块名。

在路由的时候, 如果没有指明模块, 则会使用这个值, 也可以通过配置文件中的ap.dispatcher.defaultModule来指定。


\subsection{\$\_default\_controller}

默认的控制器名。

在路由的时候, 如果没有指明控制器, 则会使用这个值, 也可以通过配置文件中的ap.dispatcher.defaultController来指定

\subsection{\$\_default\_action}

默认的动作名, 在路由的时候, 如果没有指明动作, 则会使用这个值, 也可以通过配置文件中的ap.dispatcher.defaultAction来指定。



\section{Method}


\subsection{Yaf\_Dispatcher::autoRender()}

开启/关闭自动渲染功能（接受bool型参数）

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::autoRender ( bool $flag )
\end{lstlisting}

Yaf默认开启自动渲染功能，在开启的情况下，action执行完成以后，Yaf\_Dispatcher 会自动调用view引擎去渲染该action对应的视图模板。 

开发者也可以通过调用这个函数并将 flag 参数的值设为TRUE来进行人工干预。例如，可以在一个action中仅返回FALSE来阻止当前action对应视图的自动渲染。


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    /* init method will be called as soon as a controller is initialized */ 
    public function init() {
         if($this->getRequest()->isXMLHttpResquest()) {
             //do not call render for ajax request
             //we will outpu a json string
             Yaf_Dispatcher::getInstance()->autoRender(FLASE);
         }
    }
}
\end{lstlisting}





\subsection{Yaf\_Dispatcher::catchException()}

在开启抛出异常的状态下，开启/关闭自动异常捕获功能（接受bool型参数）


\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::catchException ([ bool $flag ] )
\end{lstlisting}

在application.dispatcher.throwException 开启的时候（也可以通过调用 Yaf\_Dispatcher::throwException(TRUE)() 来开启它）：

\begin{lstlisting}[language=PHP]
<?php
$app = new Yaf_Application("conf.ini");
/**
 * 开启捕获异常
 */
Yaf_Dispatcher::getInstance()->catchException(TRUE);
\end{lstlisting}

\begin{compactitem}
\item 如果\$flag为TRUE，则会在有未捕获的异常时，由Error Controller的Error Action处理。
\item 如果\$flag为FALSE，则不会捕获异常，而是由Yaf抛出异常而不是触发异常处理逻辑。
\end{compactitem}




如果开启了 Yaf\_Dispatcher::catchException() （可以通过设置application.dispatcher.catchException来开启），并且在定义了异常处理的controller的情况下，Yaf会将所有未捕获的异常交给Error Controller的Error Action来处理。例如，捕获异常后可以根据异常代码来渲染指定的异常页面并显示给用户。

\begin{lstlisting}[language=PHP]
<?php
class ErrorController extends Yaf_Controller_Abstract {
    public function init() {}
    /** 
      * you can also call to Yaf_Request_Abstract::getException to  
      * get the un-caught exception.
      */
    public function error($exception) {
        // error occurs
        switch ($exception->getCode()) {
            case YAF_ERR_NOTFOUND_MODULE:
            case YAF_ERR_NOTFOUND_CONTROLLER:
            case YAF_ERR_NOTFOUND_ACTION:
            case YAF_ERR_NOTFOUND_VIEW:
                echo 404, ":",$exception->getMessage();
                break;
            default:
                $message=$exception->getMessage();
                echo 0,":",$exception->getMessage();
                break;
        }
    }
}
// 以上例程的输出类似于：
/* now if some error occur, assuming access a non-exists controller
 * (or you can throw a exception yourself): 
 */
404:Could not find controller script **/application/controllers/No-exists-controller.php
\end{lstlisting}



\subsection{Yaf\_Dispatcher::\_\_clone()}

 Yaf\_Dispatcher 不能被克隆


\begin{lstlisting}[language=PHP]
private void Yaf_Dispatcher::__clone ( void )
\end{lstlisting}




\subsection{Yaf\_Dispatcher::\_\_construct()}

Yaf\_Dispatcher 构造函数

\begin{lstlisting}[language=PHP]
publicYaf_Dispatcher::__construct ( void )
\end{lstlisting}



\subsection{Yaf\_Dispatcher::disableView()}

关闭自动渲染， 默认是开启的, 在动作执行完成以后, Yaf会自动render以动作名命名的视图模板文件。


\begin{lstlisting}[language=PHP]
public bool Yaf_Dispatcher::disableView ( void )
\end{lstlisting}

在一些用户自己会输出信息的情况下使用关闭自动渲染。例如，可以在一个action中仅仅返回FALSE来阻止当前action对应视图的自动渲染。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    /**
     * Controller的init方法会被自动首先调用
     */
    public function init() {
        /**
         * 如果是Ajax请求, 则关闭HTML输出
         */
        if ($this->getRequest()->isXmlHttpRequest()) {
            Yaf_Dispatcher::getInstance()->disableView();
        }
    }
}
\end{lstlisting}


\subsection{Yaf\_Dispatcher::dispatch()}

分发请求


\begin{lstlisting}[language=PHP]
public Yaf_Response_Abstract Yaf_Dispatcher::dispatch ( Yaf_Request_Abstract $request )
\end{lstlisting}

一般情况下，不需要开发者手动调用Yaf\_Dispatcher::dispatch()方法，Yaf\_Application::run()方法会自动调用这个方法。

Yaf\_Dispatcher 的dispatch()方法的工作非常繁重，而且它还需要一个request对象，一旦出错则抛出异常。

分发请求的过程有三个不同的事件：

\begin{compactitem}
\item 路由
\item 分发
\item 响应
\end{compactitem}

路由只发生一次，当dispatch()被调用的时候，需要使用请求对象中的值（例如PATH\_INFO）。

分发发生在一个循环中，一个请求可能会分发出多个action， 或者controller或者一个plugin可能重置请求对象来强制分发其他的action。 

当所有分发的步骤都执行完毕，Yaf\_Dispatcher 会返回一个响应，因此如果中途出错，可以执行exit()来直接返回输出，其他未指定的操作就不需要再继续执行。





\subsection{Yaf\_Dispatcher::enableView()}

开启自动渲染，默认是开启的, 在动作执行完成以后, Yaf会自动render以动作名命名的视图模板文件。


\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::enableView ( void )
\end{lstlisting}

如果前面的步骤禁用了自动渲染，在后面的步骤中还可以通过调用enableView()方法来重新开启自动渲染。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    /**
     * Controller的init方法会被自动首先调用
     */
    public function init() {
        /**
         * 如果不是Ajax请求, 则开启HTML输出
         */
        if (!$this->getRequest()->isXmlHttpRequest()) {
            Yaf_Dispatcher::getInstance()->enableView();
        }
    }
}
\end{lstlisting}


\subsection{Yaf\_Dispatcher::flushInstantly()}

打开关闭自动响应。

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::flushInstantly ( bool $flag )
\end{lstlisting}

在Yaf\_Dispatcher::enableView()的情况下, 会使得Yaf\_Dispatcher调用Yaf\_Controller\_Abstract::display()方法，并直接输出响应给请求端。


\begin{lstlisting}[language=PHP]
<?php
$application = new Yaf_Application("config.ini");

/* 立即输出响应 */
Yaf_Dispatcher::getInstance()->flushInstantly(TRUE);

/* 此时会调用Yaf_Controller_Abstract::display()方法 */
$application->run();
\end{lstlisting}



\subsection{Yaf\_Dispatcher::getApplication()}

\begin{lstlisting}[language=PHP]
public Yaf_Application Yaf_Dispatcher::getApplication ( void )
\end{lstlisting}

和Yaf\_Application::app()的执行结果相同，二者都是获取当前的Yaf\_Application实例。



\begin{lstlisting}[language=PHP]
<?php
$application = Yaf_Dispatcher::getInstance()->getApplication();
//不过, 还是推荐大家使用
$application = Application::app();
\end{lstlisting}





\subsection{Yaf\_Dispatcher::getInstance()}


获取当前的Yaf\_Dispatcher实例

\begin{lstlisting}[language=PHP]
public static Yaf_Dispatcher Yaf_Dispatcher::getInstance ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]
<?php
$dispatcher = Yaf_Dispatcher::getInstance();
\end{lstlisting}

\subsection{Yaf\_Dispatcher::getRequest()}

\begin{lstlisting}[language=PHP]
public Yaf_Request_Abstract Yaf_Dispatcher::getRequest ( void )
\end{lstlisting}

获取当前的请求实例



\begin{lstlisting}[language=PHP]
<?php
$request = Yaf_Dispatcher::getInstance()->getRequest();
\end{lstlisting}



\subsection{Yaf\_Dispatcher::getRouter()}

\begin{lstlisting}[language=PHP]
public Yaf_Router Yaf_Dispatcher::getRouter ( void )
\end{lstlisting}

获取路由器


\begin{lstlisting}[language=PHP]
<?php
$router = Yaf_Dispatcher::getInstance()->getRouter();
\end{lstlisting}





\subsection{Yaf\_Dispatcher::initView()}

初始化视图引擎并返回它，\$templates\_dir是视图的模板目录的绝对路径。

\$templates\_dir的默认值由Yaf\_Dispatcher保证, 可以通过Yaf\_Controller\_Abstract::setViewPath来改变这个值。




\begin{lstlisting}[language=PHP]
public Yaf_View_Interface Yaf_Dispatcher::initView ( string $templates_dir [, array $options ] )
\end{lstlisting}

Yaf采用延迟实例化视图引擎的策略, 所以只有在使用前调用此方法, 视图引擎才会被实例化。

在初始化视图引擎时可以传入视图模板的目录，以及可选参数。




\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initViewParameters(Yaf_Dispatcher $dispatcher) {
        $dispatcher->initView(APPLICATION_PATH . "/views/")->assign("webroot", WEBROOT);
    }
}
\end{lstlisting}









如果需要自定义视图引擎, 那么需要在调用Yaf\_Dispatcher::setView自定义视图引擎之后, 才可以调用此方法, 否则将得不到正确的视图引擎, 因为默认的此方法会实例化一个Yaf\_View\_Simple视图引擎


\subsection{Yaf\_Dispatcher::registerPlugin()}

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::registerPlugin ( Yaf_Plugin_Abstract $plugin )
\end{lstlisting}

注册一个插件，其中\$plugin是一个Yaf\_Plugin\_Abstract派生类的实例。




\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
   public function _initPlugin(Yaf_Dispatcher $dispatcher) {
        /**
         * Yaf assumes plugin scripts under [application.directory] .  "/plugins" 
         * for this case, it will be:
         * [application.directory] . "/plugins/" . "User" . [application.ext]
         */ 
        $user=new UserPlugin();
        $dispatcher->registerPlugin($user);
   }
}
\end{lstlisting}

Yaf假设插件脚本位于plugins目录下。

\begin{example}
Yaf\_Dispatcher::registerPlugin示例
\begin{lstlisting}[language=PHP]
<?php
/**
 * 所有在Bootstrap类中, 以_init开头的方法, 都会被Yaf调用,
 * 这些方法, 都接受一个参数:Yaf_Dispatcher $dispatcher
 * 调用的次序, 和申明的次序相同
 */
class Bootstrap extends Yaf_Bootstrap_Abstract{
    /**
     * 注册一个插件
     * 插件的目录是在application_directory/plugins
     */
    public function _initPlugin(Yaf_Dispatcher $dispatcher) {
        $user = new UserPlugin();
        $dispatcher->registerPlugin($user);
    }
}


/**
 * 插件类定义
 * UserPlugin.php
 */
class UserPlugin extends Yaf_Plugin_Abstract {

    public function routerStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin routerStartup called <br/>\n";
    }

    public function routerShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin routerShutdown called <br/>\n";
    }

    public function dispatchLoopStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin DispatchLoopStartup called <br/>\n";
    }

    public function preDispatch(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin PreDispatch called <br/>\n";
    }

    public function postDispatch(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin postDispatch called <br/>\n";
    }

    public function dispatchLoopShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        echo "Plugin DispatchLoopShutdown called <br/>\n";
    }
}
\end{lstlisting}
\end{example}










\subsection{Yaf\_Dispatcher::returnResponse()}

是否返回（Response对象）响应。

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::returnResponse ( bool $flag )
\end{lstlisting}

如果启用, 则Response对象在分发完成以后不会自动输出给请求端, 而是交给开发者自己控制输出。

\begin{lstlisting}[language=PHP]
<?php
$application = new Yaf_Application("config.ini");

/* 关闭自动响应, 交给rd自己输出*/
$response = $application->getDispatcher()->returnResponse(TRUE)->getApplication()->run();

/** 输出响应*/
$response->response();
\end{lstlisting}

\subsection{Yaf\_Dispatcher::setDefaultAction()}

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::setDefaultAction ( string $action )
\end{lstlisting}

设置路由的默认动作（传入指定的Action名字），如果在路由结果中不包含动作信息，则会使用此默认动作作为路由动作结果。


\$action是默认动作名，需要全部小写。

\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract{

    public function _initDefaultName(Yaf_Dispatcher $dispatcher) {
        /**
         * 这个只是举例, 本身Yaf默认的就是"Index"
         */
        $dispatcher->setDefaultController("Index")->setDefaultAction("index");
    }
}
\end{lstlisting}

\subsection{Yaf\_Dispatcher::setDefaultController()}

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::setDefaultController ( string $controller )
\end{lstlisting}

设置路由的默认控制器（传入指定的控制器名字），如果在路由结果中不包含控制器信息，则会使用此默认控制器作为路由控制器结果。

\$controller是默认控制器名，需要首字母大写。

\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract{

    public function _initDefaultName(Yaf_Dispatcher $dispatcher) {
        /**
         * 这个只是示例, 本身Yaf默认的就是"Index"
         */
        $dispatcher->setDefaultModule("Index")->setDefaultController("Index")->setDefaultAction("index");
    }
}
\end{lstlisting}

\subsection{Yaf\_Dispatcher::setDefaultModule()}

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::setDefaultModule ( string $module )
\end{lstlisting}

设置路由的默认模块（传入指定的模块名字），如果在路由结果中不包含模块信息，则会使用此默认模块作为路由模块结果。

\$module是默认模块名，需要首字母大写。

\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initDefaultName(Yaf_Dispatcher $dispatcher) {
         $dispatcher->setDefaultModule('Index')->setDefaultController('Index')->setDefaultAction('index');
    }
}
\end{lstlisting}

\subsection{Yaf\_Dispatcher::setErrorHandler(\$callback,\$error\_type)}

设置错误处理函数。


例如，如果application.dispatcher.throwException关闭，那么Yaf会在出错的时候触发错误，这个时候如果设置了错误处理函数，则会把控制权交给错误处理函数处理，这样当错误发生的时候，这个错误处理函数将被调用。

\begin{compactitem}
\item \$callback：错误处理的回调函数
\item \$error\_type：要捕获的错误类型
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$dispatcher->setErrorHandler(array(get_class($this),'error_handler'));
\end{lstlisting}

其中，错误处理函数函数需要至少接受两个参数：错误代码(\$error\_code)和错误信息(\$error\_message)，可选的还可以接受三个参数——错误文件(\$err\_file)，错误行(\$err\_line)和错误上下文(\$errcontext)


\begin{lstlisting}[language=PHP]
<?php
/**
 * 一般可放在Bootstrap中定义错误处理函数
 */
function myErrorHandler($errno, $errstr, $errfile, $errline) {
    switch ($errno) {
        case YAF_ERR_NOTFOUND_CONTROLLER:
        case YAF_ERR_NOTFOUND_MODULE:
        case YAF_ERR_NOTFOUND_ACTION:
            header("Not Found");
            break;
        default:
            echo "Unknown error type: [$errno] $errstr<br />\n";
            break;
    }
    return true;
}
Yaf_Dispatcher::getInstance()->setErrorHandler("myErrorHandler");
\end{lstlisting}



\subsection{Yaf\_Dispatcher::setRequest()}

设置请求

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::setRequest ( Yaf_Request_Abstract $request )
\end{lstlisting}


\subsection{Yaf\_Dispatcher::setView()}

设置视图引擎（默认传入Yaf\_View\_Interface的实例）

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::setView ( Yaf_View_Interface $view )
\end{lstlisting}

Yaf提供了一个试图引擎——Yaf\_View\_Simple，如果需要使用自定义的视图引擎代替 Yaf\_View\_Simple ， 这个函数可以解决这个问题。


\begin{example}
使用Smarty代替默认的视图引擎
\begin{lstlisting}[language=PHP]
<?php
require "/path/to/smarty/Smarty.class.php";

class Smarty_Adapter implements Yaf_View_Interface
{
    /**
     * Smarty object
     * @var Smarty
     */
    public $_smarty;
 
    /**
     * Constructor
     *
     * @param string $tmplPath
     * @param array $extraParams
     * @return void
     */
    public function __construct($tmplPath = null, $extraParams = array()) {
        $this->_smarty = new Smarty;
 
        if (null !== $tmplPath) {
            $this->setScriptPath($tmplPath);
        }
 
        foreach ($extraParams as $key => $value) {
            $this->_smarty->$key = $value;
        }
    }
 
    /**
     * Set the path to the templates
     *
     * @param string $path The directory to set as the path.
     * @return void
     */
    public function setScriptPath($path)
    {
        if (is_readable($path)) {
            $this->_smarty->template_dir = $path;
            return;
        }
 
        throw new Exception('Invalid path provided');
    }
 
    /**
     * Assign a variable to the template
     *
     * @param string $key The variable name.
     * @param mixed $val The variable value.
     * @return void
     */
    public function __set($key, $val)
    {
        $this->_smarty->assign($key, $val);
    }
 
    /**
     * Allows testing with empty() and isset() to work
     *
     * @param string $key
     * @return boolean
     */
    public function __isset($key)
    {
        return (null !== $this->_smarty->get_template_vars($key));
    }
 
    /**
     * Allows unset() on object properties to work
     *
     * @param string $key
     * @return void
     */
    public function __unset($key)
    {
        $this->_smarty->clear_assign($key);
    }
 
    /**
     * Assign variables to the template
     *
     * Allows setting a specific key to the specified value, OR passing
     * an array of key => value pairs to set en masse.
     *
     * @see __set()
     * @param string|array $spec The assignment strategy to use (key or
     * array of key => value pairs)
     * @param mixed $value (Optional) If assigning a named variable,
     * use this as the value.
     * @return void
     */
    public function assign($spec, $value = null) {
        if (is_array($spec)) {
            $this->_smarty->assign($spec);
            return;
        }
 
        $this->_smarty->assign($spec, $value);
    }
 
    /**
     * Clear all assigned variables
     *
     * Clears all variables assigned to Yaf_View either via
     * {@link assign()} or property overloading
     * ({@link __get()}/{@link __set()}).
     *
     * @return void
     */
    public function clearVars() {
        $this->_smarty->clear_all_assign();
    }
 
    /**
     * Processes a template and returns the output.
     *
     * @param string $name The template to process.
     * @return string The output.
     */
    public function render($name, $value = NULL) {
        return $this->_smarty->fetch($name);
    }

    public function display($name, $value = NULL) {
        echo $this->_smarty->fetch($name);
    }
}
\end{lstlisting}
\end{example}

\begin{example}
使用Yaf\_Dispatcher::setView()设置视图渲染引擎
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    /**
     * there are some config for smarty in the config:
     *
     * smarty.left_delimiter   = "{{"
     * smarty.right_delimiter  = "}}"
     * smarty.template_dir     = APPLICATION_PATH "/views/scripts/"
     * smarty.compile_dir      = APPLICATION_PATH "/views/templates_c/"
     * smarty.cache_dir        = APPLICATION_PATH "/views/templates_d/"
     *
     */
    public function _initConfig() {
        $config = Yaf_Applicatin::app()->getConfig();
        Yaf_Registry::set('config',$config);
    }
    
    public function _initLocalName() {
        /** we put class Smarty_Adapter under the local library directory */
        Yaf\_Loader::getInstance()->registerLocalNamespace('Smarty');
    }
    
    public function _initSmarty(Yaf_Dispatcher $dispatcher) {
        $smarty = new Smarty_Adapter(null,Yaf_Registry::get('config')->get('smarty');
        $dispatcher->setView($smarty);
         /* now the Smarty view engine become the default view engine of Yaf */
    }
}
\end{lstlisting}
\end{example}

\subsection{Yaf\_Dispatcher::\_\_sleep()}

Yaf\_Dispatcher 不能被序列化

\begin{lstlisting}[language=PHP]
private void Yaf_Dispatcher::__sleep ( void )
\end{lstlisting}

\subsection{Yaf\_Dispatcher::throwException()}

开启/关闭异常抛出（如果关闭则触发错误），默认是开启状态。

\begin{lstlisting}[language=PHP]
public Yaf_Dispatcher Yaf_Dispatcher::throwException ([ bool $flag ] )
\end{lstlisting}

Yaf\_Dispatcher可以设置当意外的错误发生时是否开启/关闭异常抛出，其中：

\begin{compactitem}
\item 当开启的时候，Yaf将会抛出异常而不是触发可捕捉的错误。
\item 当关闭的时候，Yaf将会在出错时采用触发错误的方式。
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$app = new Yaf_Application("conf.ini");
/**
 * 关闭抛出异常
 */
Yaf_Dispatcher::getInstance()->throwException(FALSE);
\end{lstlisting}

另外，也可以使用 application.dispatcher.throwException来达到相同的目的。

\begin{example}
Yaf\_Dispatcher开启异常捕获的示例
\begin{lstlisting}[language=PHP]
<?php
$config = array(
    'application' => array(
        'directory' => dirname(__FILE__),
    ),
);
$app = new Yaf_Application($config);

$app->getDispatcher()->throwException(true);

try {
    $app->run();
} catch (Yaf_Exception $e) {
    var_dump($e->getMessage());
}
// 以上例程的输出类似于：
// string(59) "Could not find controller script /tmp/controllers/Index.php"
\end{lstlisting}
\end{example}


\begin{example}
Yaf\_Dispatcher关闭异常捕获的示例
\begin{lstlisting}[language=PHP]
<?php
$config = array(
    'application' => array(
        'directory' => dirname(__FILE__),
    ),
);
$app = new Yaf_Application($config);

$app->getDispatcher()->throwException(false);

$app->run();
?>
// 以上例程的输出类似于：
// PHP Catchable fatal error:  Yaf_Application::run(): 
// Could not find controller script /tmp/controllers/Index.php in /tmp/1.php on line 12
\end{lstlisting}
\end{example}


\subsection{Yaf\_Dispatcher::\_\_wakeup()}

Yaf\_Dispatcher 不能被反序列化

\begin{lstlisting}[language=PHP]
private void Yaf_Dispatcher::__wakeup ( void )
\end{lstlisting}


\subsection{Yaf\_Dispatcher::setAppDirectory()}

\begin{lstlisting}[language=PHP]
boolean Yaf_Dispatcher::setAppDirectory(string $directory);
\end{lstlisting}

（已废弃）改变APPLICATION\_PATH（绝对路径），这样就可以从新的APPLICATION\_PATH下加载控制器/视图，但是不会改变自动加载的路径。


\begin{lstlisting}[language=PHP]
<?php
$config = array(
    "ap" => array(
        "directory" => "/usr/local/www/ap",
    ),
);
$app = new Yaf_Application($config);
$app->getDispatcher()->setAppDirectory("/usr/local/new/application")->getApplication()->run();
\end{lstlisting}


\subsection{Yaf\_Dispatcher::setRequest()}

\begin{lstlisting}[language=PHP]
public boolean Yaf_Dispatcher::setRequest( Yaf_Request_Abstract  $request );
\end{lstlisting}

（已废弃）设置请求对象



\begin{lstlisting}[language=PHP]
<?php
$request = new Yaf_Request_Simple("Index", "Index", "index");
Yaf_Dispatcher::getInstance()->setRequest($request);
\end{lstlisting}













\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}





\chapter{Yaf\_Config\_Abstract}


Yaf\_Config\_Abstract被设计在应用程序中简化访问和使用配置数据。它为在应用程序代码中访问这样的配置数据提 供了一个基于用户接口的嵌入式对象属性。配置数据可能来自于各种支持等级结构数据存储的媒体。

Yaf\_Config\_Abstract实现了Countable, ArrayAccess 和 Iterator 接口，这样就可以基于Yaf\_Config\_Abstract对象来使用count()函数和PHP语句（例如foreach），也可以通过数组方式访问Yaf\_Config\_Abstract的元素。


\begin{compactitem}
\item Yaf\_Config\_Ini为存储在INI文件的配置数据提供了适配器。

\item Yaf\_Config\_Simple为存储在PHP的数组中的配置数据提供了适配器。

\end{compactitem}

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Config\_Abstract。



\section{Synopsis}


\begin{lstlisting}[language=PHP]
abstract Yaf_Config_Abstract {
  /* 属性 */
  protected $_config ;
  protected $_readonly ;
  /* 方法 */
  abstract public mixed get ( string $name , mixed $value )
  abstract public bool readonly ( void )
  abstract public Yaf_Config_Abstract set ( void )
  abstract public array toArray ( void )
}
\end{lstlisting}















\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\section{Property}


\subsection{\$\_config}

配置实际的保存容器


\subsection{\$\_readonly}

表示配置是否容许修改，其中对于Yaf\_Config\_Ini来说永远都是TRUE。

\section{Method}


\subsection{Yaf\_Config\_Abstract::get()}


Yaf\_Config\_Abstract实现了\_\_get方法, 所以获取配置将会变得很容易。







\begin{lstlisting}[language=PHP]
abstract public mixed Yaf_Config_Abstract::get ( string $name , mixed $value )
\end{lstlisting}


\begin{example}
获取配置的示例
\begin{lstlisting}[language=PHP]
$config = new Yaf_Config_Ini('/path/to/config.ini', 'staging');
echo $config->database->get("params")->host;   // 输出 "dev.example.com"
echo $config->get("database")->params->dbname; // 输出 "dbname"
\end{lstlisting}
\end{example}

\subsection{Yaf\_Config\_Abstract::readonly()}


寻找只读配置





\begin{lstlisting}[language=PHP]
bstract public bool Yaf_Config_Abstract::readonly ( void )
\end{lstlisting}

\subsection{Yaf\_Config\_Abstract::set()}

setter


\begin{lstlisting}[language=PHP]
abstract public Yaf_Config_Abstract Yaf_Config_Abstract::set ( void )
\end{lstlisting}

\subsection{Yaf\_Config\_Abstract::toArray()}

转换为数组

\begin{lstlisting}[language=PHP]
abstract public array Yaf_Config_Abstract::toArray ( void )
\end{lstlisting}



\chapter{Yaf\_Config\_Ini}



Yaf\_Config\_Ini允许开发者通过嵌套的对象属性语法在应用程序中用熟悉的INI格式存储和读取配置数据。 



\begin{lstlisting}[language=bash]
[base]
database.master.host = localhost
[production : base]
;Yaf的配置
application.directory    = /usr/local/www/production
;应用的配置
webhost                  = www.example.com
database.adapter         = pdo_mysql
database.params.host     = db.example.com
database.params.username = dbuser
database.params.password = secret
database.params.dbname   = dbname
; 开发站点配置数据从生产站点配置数据集成并如果需要可以重写
[dev : production]
application.directory    = /usr/dev/htdocs
database.params.host     = dev.example.com
database.params.username = devuser
database.params.password = devsecret
\end{lstlisting}

这里，dev节可以得到production节的所有配置，并间接获得base节的配置，并且覆盖application.directory的配置为\texttt{"/usr/dev/htdocs"}。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Config\_Ini。

当使用INI文件作为Yaf\_Application的配置的时候, 可以打开yaf.cache\_config来提升性能。




INI格式在提供拥有配置数据键的等级结构和配置数据节之间的继承能力方面具有专长。

配置数据等级结构通过用点或者句号(.)分离键值。 一个节可以扩展或者通过在节的名称之后带一个冒号(:)和被继承的配置数据的节的名称来从另一个节继承。

parse\_ini\_file()函数和 php.ini 文件没有关系，该文件在运行脚本时就已经处理过了，parse\_ini\_file()函数可以用来读取你自己的应用程序的配置文件。

如果 ini 文件中的值包含任何非字母数字的字符，需要将其括在双引号中（\texttt{"}）。

注意，有些保留字不能作为 ini 文件中的键名，包括null，yes，no，true 和 false，其中：

\begin{compactitem}
\item 值为 null，no 和 false 等效于\texttt{""}
\item 值为 yes 和 true 等效于\texttt{"1"}
\end{compactitem}

字符 \texttt{\{\}|\&\~{}![()"} 也不能用在键名的任何地方，而且这些字符在选项值中有着特殊的意义。

具体来说，Yaf\_Config\_Ini利用PHP的函数parse\_ini\_file()来解析配置文件，Yaf\_Config\_Ini的值可能传递给parse\_ini\_file()函数的值可能包括``TRUE", ``FALSE",``yes", ``no"和``NULL"等。


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Config_Ini extends Yaf_Config_Abstract implements Iterator , Traversable , ArrayAccess , Countable {
  /* 属性 */
  /* 方法 */
  public __construct ( string $config_file [, string $section ] )
  public void count ( void )
  public void current ( void )
  public void __get ([ string $name ] )
  public void __isset ( string $name )
  public void key ( void )
  public void next ( void )
  public void offsetExists ( string $name )
  public void offsetGet ( string $name )
  public void offsetSet ( string $name , string $value )
  public void offsetUnset ( string $name )
  public void readonly ( void )
  public void rewind ( void )
  public void __set ( string $name , mixed $value )
  public void toArray ( void )
  public void valid ( void )
  /* 继承的方法 */
  abstract public mixed Yaf_Config_Abstract::get ( string $name , mixed $value )
  abstract public bool Yaf_Config_Abstract::readonly ( void )
  abstract public Yaf_Config_Abstract Yaf_Config_Abstract::set ( void )
  abstract public array Yaf_Config_Abstract::toArray ( void )
}
\end{lstlisting}


以下示例配置数据都包含在/path/to/config.ini中：

\begin{lstlisting}[language=bash]
; Production site configuration data
[production]
webhost                  = www.example.com
database.adapter         = pdo_mysql
database.params.host     = db.example.com
database.params.username = dbuser
database.params.password = secret
database.params.dbname   = dbname
 
; Staging site configuration data inherits from production and
; overrides values as necessary
[staging : production]
database.params.host     = dev.example.com
database.params.username = devuser
database.params.password = devsecret
\end{lstlisting}



\begin{example}
使用Yaf\_Config\_Ini从INI配置文件中获取配置信息
\begin{lstlisting}[language=PHP]
<?php
$config = new Yaf_Config_Ini('/path/to/config.ini','staging');
var_dump($config->database->params->host); 
var_dump($config->database->params->dbname);
var_dump($config->get("database.params.username"));
// 以上例程的输出类似于：
// string(15) "dev.example.com"
// string(6) "dbname"
// string(7) "devuser
\end{lstlisting}
\end{example}

这个例子说明了使用Yaf\_Config\_Ini从一个INI配置文件中获取配置数据的基本用法。 这个例子中既有生产环境的配置方法也有演示环境的配置方法。 因为演示环境的配置跟生产环境的非常类似，所以演示环境的配置继承了生产环境的配置。 

在复杂的情况下，决定是任意的，也可以写成相反的。在更复杂的情况下，生产环境继承自演示环境不是不可能的。


\section{Property}

\subsection{\$\_config}



\subsection{\$\_readonly}


\section{Method}


\subsection{Yaf\_Config\_Ini::\_\_construct()}


构造函数




\begin{lstlisting}[language=PHP]
public Yaf_Config_Ini::__construct ( string $config_file [, string $section ] )
\end{lstlisting}








\subsection{Yaf\_Config\_Ini::count()}

返回配置的节数量


\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::count ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Ini::current()}


返回当前节点

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::current ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::\_\_get()}


读取节点配置

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::__get ([ string $name ] )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Ini::\_\_isset()}

检查节点是否存在

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::__isset ( string $name )
\end{lstlisting}


\subsection{Yaf\_Config\_Ini::key()}

返回当前元素的键


\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::key ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Ini::next()}

向前移动到下一个元素

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::next ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::offsetExists()}

检查一个偏移位置是否存在

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::offsetExists ( string $name )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::offsetGet()}

获取一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::offsetGet ( string $name )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Ini::offsetSet()}

设置一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::offsetSet ( string $name , string $value )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Ini::offsetUnset()}

复位一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::offsetUnset ( string $name )
\end{lstlisting}


\subsection{Yaf\_Config\_Ini::readonly()}

检查配置是否只读

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::readonly ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::rewind()}

检查当前位置是否有效

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::rewind ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::\_\_set()}

设置节点配置

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::__set ( string $name , mixed $value )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::toArray()}

转换为数组的格式

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::toArray ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Ini::valid()}

检查迭代器是否有效

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Ini::valid ( void )
\end{lstlisting}


\chapter{Yaf\_Config\_Simple}

Yaf\_Config\_Simple为存储在数组中的配置数据提供了适配器。

如果打开yaf.use\_namespace，可以使用Yaf\textbackslash Config\_Simple。



\section{Synopsis}


Yaf\_Config\_Simple 是 Yaf\_Config\_ini 的简洁版本，只允许传入数组进行初始化，并提供了设置readonly的参数。

\begin{lstlisting}[language=PHP]
Yaf_Config_Simple extends Yaf_Config_Abstract implements Iterator , Traversable , ArrayAccess , Countable {
  /* 属性 */
  protected $_readonly ;
  /* 方法 */
  public __construct ( string $config_file [, string $section ] )
  public void count ( void )
  public void current ( void )
  public void __get ([ string $name ] )
  public void __isset ( string $name )
  public void key ( void )
  public void next ( void )
  public void offsetExists ( string $name )
  public void offsetGet ( string $name )
  public void offsetSet ( string $name , string $value )
  public void offsetUnset ( string $name )
  public void readonly ( void )
  public void rewind ( void )
  public void __set ( string $name , string $value )
  public void toArray ( void )
  public void valid ( void )
  /* 继承的方法 */
  abstract public mixed Yaf_Config_Abstract::get ( string $name , mixed $value )
  abstract public bool Yaf_Config_Abstract::readonly ( void )
  abstract public Yaf_Config_Abstract Yaf_Config_Abstract::set ( void )
  abstract public array Yaf_Config_Abstract::toArray ( void )
}
\end{lstlisting}


\section{Property}

\subsection{\$\_config}



\subsection{\$\_readonly}


\section{Method}


\subsection{Yaf\_Config\_Simple::\_\_construct()}


构造函数




\begin{lstlisting}[language=PHP]
public Yaf_Config_Simple::__construct ( string $config_file [, string $section ] )
\end{lstlisting}








\subsection{Yaf\_Config\_Simple::count()}

返回配置的节数量


\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::count ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Simple::current()}


返回当前节点

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::current ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::\_\_get()}


读取节点配置

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::__get ([ string $name ] )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Simple::\_\_isset()}

检查节点是否存在

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::__isset ( string $name )
\end{lstlisting}


\subsection{Yaf\_Config\_Simple::key()}

返回当前元素的键


\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::key ( void )
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Simple::next()}

向前移动到下一个元素

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::next ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::offsetExists()}

检查一个偏移位置是否存在

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::offsetExists ( string $name )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::offsetGet()}

获取一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::offsetGet ( string $name )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Simple::offsetSet()}

设置一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::offsetSet ( string $name , string $value )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{Yaf\_Config\_Simple::offsetUnset()}

复位一个偏移位置的值

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::offsetUnset ( string $name )
\end{lstlisting}


\subsection{Yaf\_Config\_Simple::readonly()}

检查配置是否只读

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::readonly ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::rewind()}

检查当前位置是否有效

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::rewind ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::\_\_set()}

设置节点配置

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::__set ( string $name , string $value )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::toArray()}

转换为数组的格式

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::toArray ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{Yaf\_Config\_Simple::valid()}

检查迭代器是否有效

\begin{lstlisting}[language=PHP]
public void Yaf_Config_Simple::valid ( void )
\end{lstlisting}




\chapter{Yaf\_Controller\_Abstract}


Yaf\_Controller\_Abstract是Yaf的MVC体系的核心部分，每个用户自定义controller都应当继承Yaf\_Controller\_Abstract。


在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Controller\_Abstract。

Yaf\_Controller\_Abstract体系具有可扩展性, 可以通过继承已有的类, 来实现这个抽象类, 从而添加自己的应用逻辑。

在用户自己定义的controller中无法调用\_\_construct方法，Yaf\_Controller\_Abstract 提供了一个魔术方法Yaf\_Controller\_Abstract::init()，这样当controller被实例化的时候，init()将被调用。

对于Controller来说, 真正的执行体是在Controller中定义的一个一个的Action（动作）, 当然这些动作也可以定义在Controller外部。

Action可能需要参数。例如，当一个请求来到的时候，在路由中如果请求的参数有相同名称的变量（例如Yaf\_Request\_Abstract::getParam()）， Yaf将把参数传递给action方法（Yaf\_Action\_Abstract::execute()）。


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function indexAction($name, $value) {
    }
}
\end{lstlisting}



在使用默认路由的情况下, 对于请求\url{http://domain.com/index/index/name/a/value/2}就会在Request对象中生成两个参数name和value。

注意，这里的动作indexAction的参数与此同名，因此在indexAction中, 可以有如下两种方式来获取这俩个参数：

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function indexAction($name, $value) {
        //直接获取参数;
        echo $name, $value; //a2
        //通过Request对象获取
        echo $this->getRequest()->getParam("name"); //a
    }
}
\end{lstlisting}

需要注意的是, 这些参数是来自用户请求URL, 所以使用前一定要做安全化过滤。






另外, 为了防止PHP抛出参数缺失的警告, 应该尽量定义有默认值的参数。


\section{Synopsis}



\begin{lstlisting}[language=PHP]
abstract Yaf_Controller_Abstract {
   /* 属性 */
   public $actions ;
   protected $_module ;
   protected $_name ;
   protected $_request ;
   protected $_response ;
   protected $_invoke_args ;
   protected $_view ;
   /* 方法 */
   final private void __clone ( void )
   final private __construct ( void )
   protected bool display ( string $tpl [, array $parameters ] )
   public void forward ( string $module [, string $controller [, string $action [, array $paramters ]]] )
   public void getInvokeArg ( string $name )
   public void getInvokeArgs ( void )
   public string getModuleName ( void )
   public Yaf_Request_Abstract getRequest ( void )
   public Yaf_Response_Abstract getResponse ( void )
   public Yaf_View_Interface getView ( void )
   public void getViewpath ( void )
   public void init ( void )
   public void initView ([ array $options ] )
   public void redirect ( string $url )
   protected string render ( string $tpl [, array $parameters ] )
   public void setViewpath ( string $view_directory )
}
\end{lstlisting}

\section{Property}


\subsection{\$actions}


有些时候为了拆分比较大的Controller，使得代码更加清晰和易于管理。

Yaf支持将具体的动作分开定义，每个动作都需要实现 Yaf\_Action\_Abstract 就可以通过定义Yaf\_Controller\_Abstract::\$actions来指明那些动作对应于具体的那些分离的类。




开发者可以通过使用\$actions和 Yaf\_Action\_Abstract 在一个单独的PHP脚本中定义action函数。



\begin{example}
在独立的脚本中定义action
\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    protected $actions = array(
         /** now dummyAction is defined in a separate file */
         "dummy"=>"actions/Dummy_action.php",
    );
    
    /**/
    public function indexAction($name,$id){
         assert($name == $this->getRequest()->getParam("name"));
         assert($id == $this->_request->getParam("id"));
    }
}
\end{lstlisting}
\end{example}


当路由到动作Index的时候, 就会加载\texttt{APPLICATION\_PATH . "/actions/Index.php"}，并且在这个脚本文件中寻找DummyAction(可通过yaf.name\_suffix和yaf.name\_separator来改变具体命名形式)，继而调用这个类的execute方法。

\begin{example}
Dummy\_action.php
\begin{lstlisting}[language=PHP]
<?php
class DummyAction extends Yaf_Action_Abstract {
    /* a action class shall define this method  as the entry point */
    public function excute() {
    
    }
}
\end{lstlisting}
\end{example}

注意，在yaf.st\_compatible打开的情况下，会产生额外的查找逻辑。


\subsection{\$\_module}

模块名

\subsection{\$\_name}



\subsection{\$\_request}

当前的请求实例，属性的值由Yaf\_Dispatcher保证，一般通过Yaf\_Controller\_Abstract::getRequest来获取此属性。


\subsection{\$\_response}

当前的响应实例，属性的值由Yaf\_Dispatcher保证，一般通过Yaf\_Controller\_Abstract::getResponse来获取此属性。


\subsection{\$\_invoke\_args}



\subsection{\$\_view}

视图引擎，Yaf采用延时实例化视图引擎来提高性能，所以这个属性直到显式的调用了Yaf\_Controller\_Abstract::getView或者Yaf\_Controller\_Abstract::initView以后才可用。




\section{Method}


\subsection{Yaf\_Controller\_Abstract::\_\_clone()}


Yaf\_Controller\_Abstract 不能被克隆


\begin{lstlisting}[language=PHP]
final private void Yaf_Controller_Abstract::__clone ( void )
\end{lstlisting}


\subsection{Yaf\_Controller\_Abstract::\_\_construct()}

Yaf\_Controller\_Abstract 构造函数


\begin{lstlisting}[language=PHP]
final private Yaf_Controller_Abstract::__construct ( void )
\end{lstlisting}


\subsection{Yaf\_Controller\_Abstract::display()}

Yaf\_Controller\_Abstract::display()是Yaf\_View\_Interface::display()的包装。

\begin{lstlisting}[language=PHP]
protected bool Yaf_Controller_Abstract::display ( string $tpl [, array $parameters ] )
\end{lstlisting}

渲染视图模板，并且直接输出渲染页面的结果。


\begin{compactitem}
\item \$tpl - 要渲染的动作名
\item \$parameters - 要传递给视图引擎的渲染参数, 也可以使用Yaf\_View\_Interface::assign来替代。
\end{compactitem}






\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        /* 首先关闭自动渲染 */
        Yaf_Dispatcher::getInstance()->disableView();
    }

    public function indexAction() {
        $this->initView();
        /* 自己输出响应 */
        $this->display("test.phtml", array("name" => "value"));
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::forward()}

\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::forward ( string $module [, string $controller [, string $action [, array $paramters ]]] )
\end{lstlisting}

转发请求（将当前请求转给另外一个动作处理，在转发失败时返回FALSE）

默认情况下，Yaf\_Controller\_Abstract::forward()仅仅只是登记下要forward的目的地Action，并不会立即跳转目的Action执行，而是会等到当前的Action执行完成以后，在下一轮的DispatchLoop中才会交给目的Action。

如果希望立即跳转到目的Action，那么需要使用return结束当前的执行流程并立刻跳转。


\begin{compactitem}
\item module

要跳转的目的Action的Module, 如果是NULL, 则默认（或当前）Module会被采用.

\item controller

要跳转的目的Action的Controller, 如果是NULL, 则默认（或当前）Controller会被采用.

\item action

要跳转的目的Action（注意要全部小写）。

\item paramters

跳转参数（一个关联数组）, 可以在目的Action中通过Yaf\_Request\_Abstrace::getParam()来获取.

\end{compactitem}


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf\_Controller\_Abstract {
    public function indexAction() {
        $logined = $_SESSION['login'];
        if(!$login) {
            $this->forward('login', array('from'=>'Index'));
            return false;
        }
        // other process
    }
    
    public function loginAction() {
        echo 'login, redirected from',$this->_request->getParam('from'), ' action';
    }
}
// 以上例程的输出类似于：
// login, redirected from Index action
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::getInvokeArg()}


\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::getInvokeArg ( string $name )
\end{lstlisting}




\subsection{Yaf\_Controller\_Abstract::getInvokeArgs()}


\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::getInvokeArgs ( void )
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::getModuleName()}

\begin{lstlisting}[language=PHP]
public string Yaf_Controller_Abstract::getModuleName ( void )
\end{lstlisting}


获取当前控制器所属的模块名，成功返回模块名，失败返回NULL。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        echo $this->getModuleName();
    }
}
\end{lstlisting}




\subsection{Yaf\_Controller\_Abstract::getRequest()}


\begin{lstlisting}[language=PHP]
public Yaf_Request_Abstract Yaf_Controller_Abstract::getRequest ( void )
\end{lstlisting}

获取当前的请求实例。


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $request = $this->getRequest();
    }
}
\end{lstlisting}



\subsection{Yaf\_Controller\_Abstract::getResponse()}


\begin{lstlisting}[language=PHP]
public Yaf_Response_Abstract Yaf_Controller_Abstract::getResponse ( void )
\end{lstlisting}

获取当前的响应实例

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $response = $this->getResponse();
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::getView()}

\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::getViewpath ( void )
\end{lstlisting}

获取当前的视图引擎

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $view = $this->getView();
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::getViewPath()}

\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::getViewpath ( void )
\end{lstlisting}

获取当前的视图模板目录的路径

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        echo $this->getViewPath();
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::init()}

控制器初始化


\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::init ( void )
\end{lstlisting}


Yaf\_Controller\_Abstract::\_\_construct() 是final类型，所以用户不能重载它，不过Yaf允许用户定义 Yaf\_Controller\_Abstract::init()，该函数会在控制器对象实例化之后被调用。





\subsection{Yaf\_Controller\_Abstract::initView()}


\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::initView ([ array $options ] )
\end{lstlisting}


初始化视图引擎，而且Yaf采用了延迟实例化视图引擎的策略，所以只有在使用前调用此方法，视图引擎才会被实例化

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $view = $this->initView();
        /* 此后就可以直接通过获取Yaf_Controller_Abstract::$_view
         * 来访问当前视图引擎 
         */
        $this->_view->assign("webroot", "http://domain.com/");
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::redirect()}

\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::redirect ( string $url )
\end{lstlisting}



重定向请求到新的路径。

\begin{compactenum}
\item \$url - 重定向请求到的新的路径
\end{compactenum}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        if($user_not_login)
              $this->redirect("/login/");
              return false;
    }
}
\end{lstlisting}

\subsection{Yaf\_Controller\_Abstract::render()}

Yaf\_Controller\_Abstract::render()方法是对Yaf\_View\_Interface::render()的包装。

\begin{lstlisting}[language=PHP]
protected string Yaf_Controller_Abstract::render ( string $tpl [, array $parameters ] )
\end{lstlisting}

渲染视图模板并得到渲染页面的结果。


\begin{compactitem}
\item \$tpl - 要渲染的动作名
\item \$parameters - 要传递给视图引擎的渲染参数, 也可以使用Yaf\_View\_Interface::assign来替代。
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        /* 首先关闭自动渲染 */
        Yaf_Dispatcher::getInstance()->disableView();
    }

    public function indexAction() {
        $this->initView();
        /* 自己输出响应 */
        echo $this->render("test.phtml");
    }
}
\end{lstlisting}


\subsection{Yaf\_Controller\_Abstract::setViewpath()}


\begin{lstlisting}[language=PHP]
public void Yaf_Controller_Abstract::setViewpath ( string $view_directory )
\end{lstlisting}

修改视图模板路径（绝对路径），Yaf\_Controller\_Abstract::render就会在整个目录下寻找模板文件。



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $this->setViewPath("/usr/local/www/tpl/");
    }
}
\end{lstlisting}



\chapter{Yaf\_Action\_Abstract}


在Yaf中一个action可以采用单独定义Yaf\_Action\_Abstract来实现，也就是说一个action方法也可以是一个Yaf\_Action\_Abstract的派生类。

默认情况下，Yaf\_Action\_Abstract是MVC中C的动作, 一般而言动作都是定义在Yaf\_Controller\_Abstract的派生类中的, 但是有的时候, 为了使得代码清晰, 分离一些大的控制器, 则可以采用单独定义Yaf\_Action\_Abstract来实现。

Yaf\_Action\_Abstract体系具有可扩展性, 可以通过继承已有的类, 来实现这个抽象类, 从而添加应用自己的应用逻辑。






Yaf需要一个可以被它所调用的入口点，而且Yaf需要另一个类似\_\_invoke()的魔术方法来完成这样的任务，所以在用户自己的action类里面必须要实现抽象方法 Yaf\_Action\_Abstract::execute()。

如果打开了yaf.use\_namespace，也可以使用Yaf\textbackslash Action\_Abstract。

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Action_Abstract extends Yaf_Controller_Abstract {
    /* 属性 */
    protected $_controller ;
    /* 方法 */
    abstract publicmixed execute ([ mixed $arg [, mixed $... ]] )
    publicYaf_Controller_Abstract getController ( void )
    /* 继承的方法 */
    final private void Yaf_Controller_Abstract::__clone ( void )
    final private Yaf_Controller_Abstract::__construct ( void )
    protected bool Yaf_Controller_Abstract::display ( string $tpl [, array $parameters ] )
    public void Yaf_Controller_Abstract::forward ( string $module [, string $controller [, string $action [, array $paramters ]]] )
    public void Yaf_Controller_Abstract::getInvokeArg ( string $name )
    public void Yaf_Controller_Abstract::getInvokeArgs ( void )
    public string Yaf_Controller_Abstract::getModuleName ( void )
    public Yaf_Request_Abstract Yaf_Controller_Abstract::getRequest ( void )
    public Yaf_Response_Abstract Yaf_Controller_Abstract::getResponse ( void )
    public Yaf_View_Interface Yaf_Controller_Abstract::getView ( void )
    public void Yaf_Controller_Abstract::getViewpath ( void )
    public void Yaf_Controller_Abstract::init ( void )
    public void Yaf_Controller_Abstract::initView ([ array $options ] )
    public void Yaf_Controller_Abstract::redirect ( string $url )
    protected string Yaf_Controller_Abstract::render ( string $tpl [, array $parameters ] )
    public void Yaf_Controller_Abstract::setViewpath ( string $view_directory )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_module}


\subsection{\$\_name}


\subsection{\$\_request}


\subsection{\$\_response}


\subsection{\$\_invoke\_args}


\subsection{\$\_view}



\subsection{\$\_controller}


\section{Mothod}


\subsection{Yaf\_Action\_Abstract::execute()}


执行action







\begin{lstlisting}[language=PHP]
abstract public mixed Yaf_Action_Abstract::execute ([ mixed $arg [, mixed $... ]] )
\end{lstlisting}

Yaf\_Action\_Abstract::execute() 可能会有参数，而且由于从请求返回的值可能是不安全的，因此在使用之前需要对它们重新过滤。



\begin{lstlisting}[language=PHP]
<?php
class ProductController extends Yaf_Controller_Abstract {
    protected $actions = array(
        'index'=>'actions/Index.php',
    );
}
\end{lstlisting}



\begin{lstlisting}[language=PHP]
<?php
class ListAction extends Yaf_Action_Abstract {
    public function execute($name,$id){
        assert($name == $this->getRequest()->getParam('name'));
        assert($id == $this->getRequest()->getParam('id'));
    }
}
// 以上例程的输出类似于：
/**
 * Now assuming we are using the Yaf_Route_Static route 
 * for request: http://yourdomain/product/list/name/yaf/id/22
 * will result:
 */
// bool(true)
// bool(true)
\end{lstlisting}




\subsection{Yaf\_Action\_Abstract::getController()}

获取控制器实例



\begin{lstlisting}[language=PHP]
public Yaf_Controller_Abstract Yaf_Action_Abstract::getController ( void )
\end{lstlisting}





\chapter{Yaf\_View\_Interface}

Yaf给用户提供一个了一个可扩展的、可自定的视图引擎接口，其中定义了Yaf中使用的视图引擎需要实现的方法和功能。


用户可以使用自己的视图引擎来代替Yaf内置的Yaf\_View\_Simple。

在打开yaf.use\_namespace的情况下，也可以使用Yaf\textbackslash View\_Interface。

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_View_Interface {
    /* 方法 */
    abstract public bool assign ( string $name [, string $value ] )
    abstract public bool display ( string $tpl [, array $tpl_vars ] )
    abstract public void getScriptPath ( void )
    abstract public string render ( string $tpl [, array $tpl_vars ] )
    abstract public void setScriptPath ( string $template_dir )
}
\end{lstlisting}

\section{Yaf\_View\_Interface::assign()}

为视图引擎分配一个模板变量

\begin{lstlisting}[language=PHP]
abstract public bool Yaf_View_Interface::assign ( string $name [, string $value ] )
\end{lstlisting}

在视图模板中可以直接通过\$\{\$name\}获取模板变量值

\begin{lstlisting}[language=PHP]

\end{lstlisting}

\section{Yaf\_View\_Interface::display()}

渲染一个视图模板, 并直接输出给请求端


\begin{lstlisting}[language=PHP]
abstract public bool Yaf_View_Interface::display ( string $tpl [, array $tpl_vars ] )
\end{lstlisting}





\section{Yaf\_View\_Interface::getScriptPath()}

获取脚本路径

\begin{lstlisting}[language=PHP]
abstract public void Yaf_View_Interface::getScriptPath ( void )
\end{lstlisting}

\section{Yaf\_View\_Interface::render()}

渲染一个视图模板并得到结果（可以写入缓存等进行保存）

\begin{lstlisting}[language=PHP]
abstract public string Yaf_View_Interface::render ( string $tpl [, array $tpl_vars ] )
\end{lstlisting}


\section{Yaf\_View\_Interface::getScriptPath()}

设置模板的基目录，通常通过Yaf\_Dispatcher调用。



\begin{lstlisting}[language=PHP]
abstract public void Yaf_View_Interface::setScriptPath ( string $template_dir )
\end{lstlisting}


\$template\_dir是模板目录的绝对路径，默认的Yaf\_Dispatcher会设置此目录为\texttt{application.directory . "/views"}

\chapter{Yaf\_View\_Simple}



Yaf提供了高性能的视图引擎——也就是Yaf内建的一个模板引擎Yaf\_View\_Simple。

Yaf\_View\_Simple是一个支持PHP脚本的简单而快速的模板引擎，开发者通过Yaf\_View\_Interface::assign()传递的模板变量，可以在视图模板中直接通过变量名使用。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash View\_Simple。


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_View_Simple implements Yaf_View_Interface {
    /* 属性 */
    protected $_tpl_vars ;
    protected $_tpl_dir ;
    /* 方法 */
    public bool assign ( string $name [, mixed $value ] )
    public bool assignRef ( string $name , mixed &$value )
    public bool clear ([ string $name ] )
    final public __construct ( string $tempalte_dir [, array $options ] )
    public bool display ( string $tpl [, array $tpl_vars ] )
    public string eval ( string $tpl_content [, array $tpl_vars ] )
    public void __get ([ string $name ] )
    public string getScriptPath ( void )
    public void __isset ( string $name )
    public string render ( string $tpl [, array $tpl_vars ] )
    public void __set ( string $name , mixed $value )
    public bool setScriptPath ( string $template_dir )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_tpl\_vars}


所有通过Yaf\_View\_Simple::assign分配的变量都保存在此属性中。


\subsection{\$\_tpl\_dir}

当前视图引擎的模板文件基目录。


\section{Method}


\subsection{Yaf\_View\_Simple::assign()}

为视图引擎分配一个模板变量，在视图模板中可以直接通过\texttt{\$\{\$name\}}获取模板变量值。

\begin{lstlisting}[language=PHP]
public bool Yaf_View_Simple::assign ( string $name [, mixed $value ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - 字符串或数组，如果为字符串则\$value不能为空。

如果为数组则\$value须为空, 此参数为变量名和值的关联数组。

\item \$value - 分配的模板变量值
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function indexAction() {
        $this->getView()->assign('foo','bar');
        $this->_view->assign(array('key'=>'value','name'=>'value'));
    }
}
\end{lstlisting}

如果\$name不是合法的PHP变量名（比如整数或者是包含``|"的字符串），那么在视图模板文件中, 将不能直接通过\texttt{\$\{\$name\}}来访问这个变量。

当然，Yaf还是允许开发者可以在视图模板文件中通过\texttt{\$this->\_tpl\_vars[\$name]}来访问这个变量。


\begin{lstlisting}[language=HTML]
<html>
   <head>
       <title><?php echo $foo; ?></title>
   </head>
   <body>
   <?php
      foreach($this->_tpl_vars as $name=>$value) {
          echo $name; 
          // echo $this->_tpl_vars['name'];
      }
   ?>
   </body>
</html>
\end{lstlisting}

\begin{example}
Yaf\_View\_Simple::assign()示例
\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $params = array(
            'name' => 'value',
        );
        $this->getView()->assign($params)->assign("foo", "bar");
    }
}
\end{lstlisting}
\end{example}

\subsection{Yaf\_View\_Simple::assignRef()}

传递一个引用变量给模板引擎。

\begin{lstlisting}[language=PHP]
public bool Yaf_View_Simple::assignRef ( string $name , mixed &$value )
\end{lstlisting}

不同于Yaf\_View\_Simple::assign()，assignRef()方法传递一个引用变量给模板引擎


\begin{compactitem}
\item \$name - 一个字符串的名字，被用来传递值给模板。
\item \$value
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
   public function indexAction(){
       $value = 'bar';
       $this->getView()->assign('foo',$value);
       
       $dummy = $this->getView()->render('index/index.phtml';
       echo $value;
       
       // prevent the auto-render
       Yaf_Dispatcher::getInstance()->autoRender(FALSE);
   }
}
\end{lstlisting}



\begin{lstlisting}[language=HTML]
<html>
    <head>
        <title><?php echo $foo; $foo='changed'; ?></title>
    </head>
    <body>
    </body>
</html>
// 以上例程的输出类似于：
/* access the index controller will result: */
// changed
\end{lstlisting}




\subsection{Yaf\_View\_Simple::clear()}

清除指定的变量

\begin{lstlisting}[language=PHP]
public bool Yaf_View_Simple::clear ([ string $name ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - 分派的变量名。如果为空，将会清除所有的变量
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
   public function indexAction(){
       $this->getView()->clear('foo')->clear('bar'); // clear "foo" and "bar"
       $this->_view->clear(); // clear all assigned variables
   }
}
\end{lstlisting}


\subsection{Yaf\_View\_Simple::\_\_construct()}


\begin{lstlisting}[language=PHP]
final public Yaf_View_Simple::__construct ( string $tempalte_dir [, array $options ] )
\end{lstlisting}


\begin{compactitem}
\item \$template\_dir - 模板的基本路径，默认为\texttt{APPLICATOIN . "/views"}
\item \$options
\end{compactitem}


\begin{lstlisting}[language=PHP]
<?php
define('TEMPLATE_DIRECTORY',APPLICATION_PATH.'/views');
$view = new Yaf_View_Simple(TEMPLATE_DIRECTORY,array(
     'short_tag'=>false, // doesn't allow use short tag in template
));
\end{lstlisting}



\subsection{Yaf\_View\_Simple::display()}


渲染一个视图模板, 并直接输出给请求端

\begin{lstlisting}[language=PHP]
public bool Yaf_View_Simple::display ( string $tpl [, array $tpl_vars ] )
\end{lstlisting}

\begin{compactitem}
\item \$tpl - 视图模板文件（绝对路径），一般由Yaf\_Controller\_Abstract提供
\item \$tpl\_vars - 关联数组（模板变量）
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        $this->getView()->display($this->_script_path . "/test.phtml");
    }
}
\end{lstlisting}

\subsection{Yaf\_View\_Simple::eval()}

渲染模板

\begin{lstlisting}[language=PHP]
public string Yaf_View_Simple::eval ( string $tpl_content [, array $tpl_vars ] )
\end{lstlisting}

渲染一个字符串模板，然后返回结果。

\begin{compactitem}
\item \$tpl\_content - string template
\item \$tpl\_vars
\end{compactitem}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{Yaf\_View\_Simple::\_\_get()}

获取视图引擎的一个模板变量值（参数可以为空）

\begin{lstlisting}[language=PHP]
public void Yaf_View_Simple::__get ([ string $name ] )
\end{lstlisting}


\begin{compactitem}
\item \$name - 分配的模板变量名

如果为空，所有传递的变量都会被返回

\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function init() {
        $this->initView();
    }
    public funciton indexAction() {
        //通过__get直接获取变量值
        echo $this->_view->name;
    }
}
\end{lstlisting}


\subsection{Yaf\_View\_Simple::get()}

获取视图引擎的一个模板变量值

\begin{lstlisting}[language=PHP]
public mixed Yaf_View_Simple::get( string  $name );
\end{lstlisting}

\begin{compactitem}
\item \$name - 模板变量名
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function init() {
        $this->initView();
    }
    public funciton indexAction() {
        echo $this->_view->get("name");
    }
}
\end{lstlisting}



\subsection{Yaf\_View\_Simple::getScriptPath()}

\begin{lstlisting}[language=PHP]
public string Yaf_View_Simple::getScriptPath ( void )
\end{lstlisting}

获取当前的模板目录

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        echo  $this->getView()->getScriptPath();
    }
}
\end{lstlisting}







\subsection{Yaf\_View\_Simple::\_\_isset()}

检测模板变量是否存在。

\begin{lstlisting}[language=PHP]
public void Yaf_View_Simple::__isset ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}

\subsection{Yaf\_View\_Simple::render()}

渲染一个视图模板并得到结果。

\begin{lstlisting}[language=PHP]
public string Yaf_View_Simple::render ( string $tpl [, array $tpl_vars ] )
\end{lstlisting}

\begin{compactitem}
\item \$tpl - 视图模板文件（绝对路径），一般由Yaf\_Controller\_Abstract提供
\item \$tpl\_vars - 关联数组（模板变量）
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        echo $this->getView()->render($this->_script_path . "/test.phtml");
    }
}
\end{lstlisting}

\subsection{Yaf\_View\_Simple::\_\_set()}

\begin{lstlisting}[language=PHP]
public void Yaf_View_Simple::__set ( string $name , mixed $value )
\end{lstlisting}

为视图引擎分配一个模板变量，在视图模板中可以直接通过\texttt{\$\{\$name\}}获取模板变量值。

\begin{compactitem}
\item \$name - 字符串或者关联数组, 如果为字符串则\$value不能为空, 此字符串代表要分配的变量名。

如果为数组，则\$value须为空，此参数为变量名和值的关联数组。

\item \$value - 分配的模板变量值
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $this->getView()->name = "value";
    }
}
\end{lstlisting}




这是一个更简单并且用来替代 Yaf\_View\_Simple::assign() 的方法

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public function indexAction() {
        $this->getView()->foo = 'bar'; // same as assign("foo", "bar");
    }
}
\end{lstlisting}

\subsection{Yaf\_View\_Simple::setScriptPath()}

设置模板的目录，默认的Yaf\_Dispatcher会设置此目录为\texttt{APPLICATION\_PATH . "/views"}。

\begin{lstlisting}[language=PHP]
public bool Yaf_View_Simple::setScriptPath ( string $template_dir )
\end{lstlisting}


\begin{compactitem}
\item \$template\_dir - 视图模板的基目录（局对路径）
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        $this->getView()->setScriptPath("/tmp/views/");
    }
}
\end{lstlisting}

\chapter{Yaf\_Loader}

Yaf\_Loader 类为Yaf提供了自动加载(autoload)功能的全面解决方案，这样Yaf就可以根据类名中包含的路径信息实现类的定位和自动加载。

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Loader {
    /* 属性 */
    protected $_local_ns ;
    protected $_library ;
    protected $_global_library ;
    protected static $_instance ;
    /* 方法 */
    public void autoload ( $class_name )
    public void clearLocalNamespace ( void )
    private void __clone ( void )
    private __construct ( void )
    public static void getInstance ( [$local_library_path [,$global_library_path]] )
    public Yaf_Loader getLibraryPath ([ bool $is_global = false ] )
    public void getLocalNamespace ( void )
    public static void import (string $file)
    public void isLocalName ($class_name)
    public void registerLocalNamespace (mixed $name_prefix)
    public Yaf_Loader setLibraryPath ( string $library_path [, bool $is_global = false ] )
    private void __sleep ( void )
    private void __wakeup ( void )
}
\end{lstlisting}


Yaf\_Loader也提供了对传统的require\_once的替代方案，开发者可以通过舍弃传统的require\_once获得一些性能上的优势。

在第一次使用的时候，Yaf\_Loader将检索 Yaf\_Application 的实例， 而且Yaf\_Loader 实现了单例模式，并使用spl\_autoload注册它自己，通过 Yaf\_Loader::getInstance() 返回它的实例。

Yaf\_Loader 加载一个类时仅仅尝试一次，如果失败了， 后面的操作将取决于yaf.use\_spl\_auload的配置值。

\begin{compactitem}
\item 如果这个配置项为On，Yaf\_Loader::autoload() 将会返回FALSE， 从而把机会让给其他的自动加载功能。
\item 如果这个配置项为Off（默认）， Yaf\_Loader::autoload() 将会返回TRUE， 最重要的是将会抛出一个非常有用的警告（对于找出一个类加载失败非常有用）。
\end{compactitem}

默认情况下，Yaf\_Loader 收集所有library(类定义的脚本)并储存进在 php.ini(yaf.library)定义的global library directory之中，因此务必保持yaf.use\_spl\_autoload为关闭，除非有一些library有自己的autoload机制，并且是无法改写的。

如果需要使用 Yaf\_Loader 搜索本地类（库）（定义在application.ini， 默认情况下，它是 \texttt{application.directory . "/libraray"}）， 需要使用 Yaf\_Loader::registerLocalNameSpace() 注册本地类前缀。

在下面的示例中假设 APPLICATION\_PATH 是 application.directory，并使用Yaf\_Loader来加载类。


\begin{lstlisting}[language=PHP]
// Assuming the following configure in php.ini:
yaf.libraray = "/global_dir"

//Assuming the following configure in application.ini
application.libraray = APPLICATION_PATH "/library"
\end{lstlisting}

假设以下本地名称空间已被注册，接着使用Yaf\_Loader注册本地命名空间。

\begin{example}
注册本地命名空间
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initLoader($dispatcher) {
        Yaf_Loader::getInstance()->registerLocalNamespace(array('Foo','Bar'));
    }
}
\end{lstlisting}
\end{example}


下面是自动加载类的示例：

\begin{example}
自动加载类
\begin{lstlisting}[language=PHP]
class Foo_Bar_Test =>
  // APPLICATION_PATH/library/Foo/Bar/Test.php
  
class GLO_Name  =>
  // /global_dir/Glo/Name.php
 
class BarNon_Test
  // /global_dir/Barnon/Test.php
\end{lstlisting}
\end{example}

Yaf\_Loader支持加载命名空间类，例如：

\begin{example}
加载命名空间类
\begin{lstlisting}[language=PHP]
class \Foo\Bar\Dummy =>
   // APPLICATION_PATH/library/Foo/Bar/Dummy.php

class \FooBar\Bar\Dummy =>
   // /global_dir/FooBar/Bar/Dummy.php
\end{lstlisting}
\end{example}

上述所有的目录名字的首字母是大写的，可以通过在php.ini中设置 yaf.lowcase\_path = On 来将它们小写。

Yaf\_Loader 也是设计来加载MVC类，对应的规则如下：

\begin{example}
使用Yaf\_Loader加载MVC类
\begin{lstlisting}[language=PHP]
Controller Classes =>
// APPLICATION_PATH/controllers/

Model Classes =>
// APPLICATION_PATH/models/

Plugin Classes =>
// APPLICATION_PATH/plugins/
\end{lstlisting}
\end{example}

通常情况下，Yaf 通过识别一个类的后缀（这个是默认的，也可以通过改变配置项 yaf.name\_suffix 来将它改为通过前缀识别）来决定它是否是一个MVC类，例如：

\begin{lstlisting}[language=PHP]
Controller Classes =>
    // ***Controller

Model Classes =>
    // ***Model

Plugin Classes =>
    // ***Plugin
\end{lstlisting}


Yaf\_Loader加载的MVC类的目录将受 yaf.lowcase\_path 的影响。

\begin{example}
加载MVC类的示例
\begin{lstlisting}[language=PHP]
class IndexController
    // APPLICATION_PATH/controllers/Index.php

class DataModel =>
   // APPLICATION_PATH/models/Data.php

class DummyPlugin =>
  // APPLICATION_PATH/plugins/Dummy.php

class A_B_TestModel =>
  // APPLICATION_PATH/models/A/B/Test.php
\end{lstlisting}
\end{example}



\section{Property}


\subsection{\$\_local\_ns}

\$\_local\_ns指示了本地类的类名前缀，可以通过Yaf\_Loader::registerLocalNamespace来添加新的值。

\subsection{\$\_library}

\$\_library是本地（自身）类加载路径，其值通常来自配置文件中的application.library。

默认情况下，它的值是 \texttt{application.directory . "/library"}， 可以通过修改\texttt{application.ini}中的\texttt{application.library}或者调用 Yaf\_Loader::setLibraryPath() 改变它。

\subsection{\$\_global\_library}

\$\_global\_library是全局类加载路径，其值通常来自php.ini中的application.library。


\subsection{\$\_instance}

Yaf\_Loader实现了单例模式，一般由Yaf\_Application负责初始化Yaf\_Loader，并使用\$\_instance属性保存当前Yaf\_Loader实例。

\section{Method}


\subsection{Yaf\_Loader::autoload(\$class\_name)}

载入一个类, 这个方法被Yaf用作自动加载类的方法, 当然也可以手动调用来实现自动加载。




\begin{lstlisting}[language=PHP]
public void Yaf_Loader::autoload ($class_name)
\end{lstlisting}

\$class\_name是要载入的类名，类名必须包含路径信息，也就是下划线分隔的路径信息和类名。

在载入的过程中, 首先会判断这个类名是否是本地类, 如果是本地类, 则使用本地类类库目录, 否则使用全局类目录. 然后判断yaf.lowcase\_path是否开启, 如果开启, 则会把类名中的路径部分全部小写. 然后加载并执行。

\begin{lstlisting}[language=bash]
/** yaf.lowcase_path=0 */
Foo_Bar_Dummy表示这个类存在于类库目录下的Foo/Bar/Dummy.php

/** yaf.lowcase_path=1 */
Foo_Bar_Dummy表示这个类存在于类库目录下的foo/bar/Dummy.php
\end{lstlisting}


注意，在php.ini中的yaf.lowcase\_path开启的情况下, 路径信息中的目录部分都会被转换成小写。

在php.ini中的yaf.use\_spl\_autoload关闭的情况下, 即使类没有找到, Yaf\_Loader::autoload也会返回TRUE, 剥夺其后面的自动加载函数的执行权利。

\begin{lstlisting}[language=PHP]
<?php
Yaf_Loader::autoload("Baidu_ST_Dummy_Bar");
\end{lstlisting}

\subsection{Yaf\_Loader::clearLocalNamespace()}



\begin{lstlisting}[language=PHP]
public void Yaf_Loader::clearLocalNamespace ( void )
\end{lstlisting}


清除本地命名空间（或清除已注册的本地类前缀）

\begin{lstlisting}[language=PHP]
<?php
Yaf_Loader::getInstance()->clearLocalNamespace();
\end{lstlisting}

\subsection{Yaf\_Loader::\_\_clone()}



\begin{lstlisting}[language=PHP]
private void Yaf_Loader::__clone ( void )
\end{lstlisting}

\subsection{Yaf\_Loader::\_\_construct()}

\begin{lstlisting}[language=PHP]
private Yaf_Loader::__construct ( void )
\end{lstlisting}

\subsection{Yaf\_Loader::getInstance([\$local\_library\_path [,\$global\_library\_path]])}

获取当前的Yaf\_Loader实例

\begin{lstlisting}[language=PHP]
public static Yaf_Loader Yaf_Loader::getInstance ( $local_library_path,$global_library_path)
\end{lstlisting}


\begin{compactitem}
\item \$local\_library\_path - 本地(自身)类库目录, 如果留空, 则返回已经实例化过的Yaf\_Loader实例，
\item \$global\_library\_path - 全局类库目录, 如果留空则会认为和\$local\_library\_directory相同。
\end{compactitem}

Yaf\_Loader是单例模式，所以即使第二次以不同的参数实例化一个Yaf\_Loader，得到的仍然是已经实例化的第一个实例。

\begin{lstlisting}[language=PHP]
<?php
$loader = Yaf_Loader::getInstance();
\end{lstlisting}


\subsection{Yaf\_Loader::getLibraryPath()}

\begin{lstlisting}[language=PHP]
public Yaf_Loader Yaf_Loader::getLibraryPath ([ bool $is_global = false ] )
\end{lstlisting}


\subsection{Yaf\_Loader::getLocalNamespace()}

\begin{lstlisting}[language=PHP]
public void Yaf_Loader::getLocalNamespace ( void )
\end{lstlisting}

获取当前已经注册的本地类前缀

\begin{lstlisting}[language=PHP]
<?php
Yaf_Loader::getInstance()->registerLocalNamespace(array("Foo", "Bar"));
print(Yaf_Loader::getInstance()->getLocalNamespace());
//输出:
// :Foo:Bar:
\end{lstlisting}


\subsection{Yaf\_Loader::import(string \$file)}


\begin{lstlisting}[language=PHP]
public static void Yaf_Loader::import (\$file)
\end{lstlisting}

导入一个PHP文件, 因为Yaf\_Loader::import只是专注于一次包含, 所以要比传统的require\_once性能好一些。

要载入的文件路径\$file可以为绝对路径和相对路径，如果为相对路径则会以应用的本地类目录(application.library)为基目录。


\begin{lstlisting}[language=PHP]
<?php
//绝对路径
Yaf_Loader::import("/usr/local/foo.php);

//相对路径, 会在APPLICATION_PATH."/library"下加载
Yaf_loader::import("plugins/User.php");
\end{lstlisting}

\subsection{Yaf\_Loader::isLocalName(\$class\_name)}


判断一个类是否是本地类

\begin{lstlisting}[language=PHP]
public void Yaf_Loader::isLocalName ($class_name)
\end{lstlisting}

\$class\_name是字符串表示类名, 本方法会根据下划线分隔截取出类名的第一部分, 然后在Yaf\_Loader的\_local\_ns中判断是否存在, 从而确定结果。

\begin{lstlisting}[language=PHP]
<?php
Yaf_Loader::getInstance()->registrLocalNamespace("Foo");

Yaf_Loader::getInstance()->isLocalName("Foo_Bar");//TRUE
Yaf_Loader::getInstance()->isLocalName("FooBar");//FALSE
\end{lstlisting}

\subsection{Yaf\_Loader::registerLocalNamespace(mixed \$name\_prefix)}

注册本地类前缀并返回结果。

\begin{lstlisting}[language=PHP]
public void Yaf_Loader::registerLocalNamespace ([ mixed $prefix ] )
\end{lstlisting}

对于以这些前缀开头的本地类，都从本地类库路径中加载。

\begin{compactitem}
\item \$prefix - 字符串或者是数组格式的类名前缀，不包含前缀后面的下划线

所有拥有和这些前缀相同前缀的类将被加载到本地library路径。
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
Yaf_Loader::getInstance()->registerLocalNamespace("Foo");
Yaf_Loader::getInstance()->registerLocalNamespace(array("Foo", "Bar"));
\end{lstlisting}


\subsection{Yaf\_Loader::setLibararyPath()}

改变library路径

\begin{lstlisting}[language=PHP]
public Yaf_Loader Yaf_Loader::setLibraryPath ( string $directory [, bool $is_global = false ] )
\end{lstlisting}

\subsection{Yaf\_Loader::\_\_sleep()}

\begin{lstlisting}[language=PHP]
private void Yaf_Loader::__sleep ( void )
\end{lstlisting}

\subsection{Yaf\_Loader::\_\_wakeup()}


\begin{lstlisting}[language=PHP]
private void Yaf_Loader::__wakeup ( void )
\end{lstlisting}





\chapter{Yaf\_Plugin\_Abstract}

Yaf提供了插件机制来定制和扩展框架，插件本身是一个类，基于组件定义的类会有所变化——开发者可能需要去实现这些接口，不过插件(Plugin)实际上本身仍然是一个类。

一个插件(plugin)会被Yaf\_Dispatcher::registerPlugin()加载到Yaf框架中， 在框架注册(registerd)后，插件(plugin)类中定义方法将会在恰当的时间被该接口执行。



\begin{lstlisting}[language=PHP]
<?php
/* bootstrap class should be defined under ./application/Bootstrap.php */
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initPlugin(Yaf_Dispatcher $dispatcher) {
        /* register a plugin */
        $dispatcher->registerPlugin(new TestPlugin());
    }
}

/* plugin class should be placed under ./application/plugins/ */
class TestPlugin extends Yaf_Plugin_Abstract {
    public function routerStartup(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response) {
        /* 在路由之前执行，这个钩子中可以执行URL重写等操作 */
        var_dump('routerStartup');
    }
    
    public function routerShutdown(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response) {
       /* 在路由完成后执行，这个钩子中可以执行登录检测等操作 */
       var_dump('routerShutdown');
    }
    
    public function dispatchLoopStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
       var_dump('dispatchLoopStartup');
    }
    
    public function preDispatch(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response) {
        var_dump('preDispatch');
    }
    
    public function postDispatch(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response){
        var_dump('postDispatch');
    }
    
    public function dispatchLoopShutdown(Yaf_Request_Abstract $request,Yaf_Response_Abstract $response){
        /* final hook */
        /* in the this hook user can do loging or implement layout */
        var_dump('dispatchLoopShutdown');
    }
}

class IndexController extends Yaf_Controller_Abstract {
    public function indexAction(){
         return false; // prevent rendering
    }
}

$config = array(
    'application'=>array(
         'directory'=>dirname(__FILE__).'/application/',
    ),
);
$app=new Yaf_Application($config);
$app->bootstrap()->run();

// 以上例程的输出类似于：
// string(13) "routerStartup"
// string(14) "routerShutdown"
// string(19) "dispatchLoopStartup"
// string(11) "preDispatch"
// string(12) "postDispatch"
// string(20) "dispatchLoopShutdown"
\end{lstlisting}

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Plugin_Abstract {
    /* 方法 */
    public void dispatchLoopShutdown ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void dispatchLoopStartup ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void postDispatch ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void preDispatch ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void preResponse ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void routerShutdown ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
    public void routerStartup ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
}
\end{lstlisting}




\section{Method}

\subsection{Yaf\_Plugin\_Abstract::dispatchLoopShutdown()}


路由调度循环结束之后的操作



\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::dispatchLoopShutdown ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

这个方式是Yaf插件钩子系统中最后的一个钩子，如果一个用户插件实现了这个方法，它将在分发循环结束之后触发。

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}



\subsection{Yaf\_Plugin\_Abstract::dispatchLoopStartup()}

路由调度循环开始之前的操作


\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::dispatchLoopStartup ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

这个钩子将在分发循环开始之前触发。

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}



\subsection{Yaf\_Plugin\_Abstract::postDispatch()}

路由调度之后的操作


\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::postDispatch ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}

\subsection{Yaf\_Plugin\_Abstract::preDispatch()}

路由调度之前的操作


\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::preDispatch ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}


\subsection{Yaf\_Plugin\_Abstract::preResponse()}

这个钩子在响应(Yaf\_Response)前被触发



\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::preResponse ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}

\subsection{Yaf\_Plugin\_Abstract::routerShutdown()}

路由结束时的操作






\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::routerShutdown ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

这个钩子在路由结束之后触发，通常被用于登陆检查。

\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}


\subsection{Yaf\_Plugin\_Abstract::routerStartup()}

路由开始时的操作


\begin{lstlisting}[language=PHP]
public void Yaf_Plugin_Abstract::routerStartup ( Yaf_Request_Abstract $request , Yaf_Response_Abstract $response )
\end{lstlisting}

这个是Yaf插件的勾子系统最早被触发的的一个方法，如果一个用户插件实现了这个方法，它将在路由之前触发。


\begin{compactitem}
\item \$request
\item \$response
\end{compactitem}

\chapter{Yaf\_Registry}

Yaf\_Registry（对象注册表(或称对象仓库)）是一个用于在整个应用空间(application space)内存储对象和值的容器。

通过把对象存储在Yaf\_Registry容器中，开发者可以在整个项目的任何地方使用同一个对象。

Registry机制相当于一种全局存储，开发者可以通过Yaf\_Registry类的静态方法来使用对象注册表。

另外，Yaf\_Registry类本身是一个数组对象，可以使用数组形式来访问其中的类方法。


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Registry {
    /* 属性 */
    static $_instance ;
    protected $_entries ;
    /* 方法 */
    private void __clone ( void )
    __construct ( void )
    public static void del ( string $name )
    public static mixed get ( string $name )
    public static bool has ( string $name )
    public static bool set ( string $name , string $value )
}
\end{lstlisting}

在打开yaf.use\_namespace的情况下，也可以使用Yaf\textbackslash Registry。

\section{Property}

\subsection{\$\_instance}


\subsection{\$\_entries}


\section{Method}


\subsection{Yaf\_Registry::\_\_clone()}




\begin{lstlisting}[language=PHP]
private void Yaf_Registry::__clone ( void )
\end{lstlisting}


\subsection{Yaf\_Registry::\_\_construct()}


\begin{lstlisting}[language=PHP]
Yaf_Registry::__construct ( void )
\end{lstlisting}

\subsection{Yaf\_Registry::del()}


删除存在于注册表中的一个项目


\begin{lstlisting}[language=PHP]
public static void Yaf_Registry::del ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
/** 存入 */
Yaf_Registry::set('config', Yaf_Application::app()->delConfig());

Yaf_Registry::del("config");
\end{lstlisting}

\subsection{Yaf\_Registry::get()}


\begin{lstlisting}[language=PHP]
public static mixed Yaf_Registry::get ( string $name )
\end{lstlisting}

获取注册表中寄存的项

\begin{compactitem}
\item \$name
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
/** 存入 */
Yaf_Registry::set('config', Yaf_Application::app()->getConfig());

/* 之后可以在任何地方获取到 */
$config->Yaf_Registry::get("config");
\end{lstlisting}

\subsection{Yaf\_Registry::has()}



\begin{lstlisting}[language=PHP]
public static bool Yaf_Registry::has ( string $name )
\end{lstlisting}

查询某一项目是否存在于注册表中

\begin{compactitem}
\item \$name
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
/** 存入 */
Yaf_Registry::set('config', Yaf_Application::app()->hasConfig());

assert(Yaf_Registry::has("config"));
\end{lstlisting}

\subsection{Yaf\_Registry::set()}


\begin{lstlisting}[language=PHP]
public static bool Yaf_Registry::set ( string $name , string $value )
\end{lstlisting}

往全局注册表添加一个新的项

\begin{compactitem}
\item \$name
\item \$value
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
/** 存入 */
Yaf_Registry::set('config', Yaf_Application::app()->getConfig());

/* 之后可以在任何地方获取到 */
$config->Yaf_Registry::get("config");
\end{lstlisting}

\chapter{Yaf\_Request\_Abstract}

Yaf\_Request\_Abstract代表了一个实际请求，一般不需要自己实例化它，Yaf\_Application在run以后会自动根据当前请求实例它。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Request\_Abstract。



\section{Synopsis}



\begin{lstlisting}[language=PHP]
Yaf_Request_Abstract {
    /* Constants */
    const string SCHEME_HTTP = http ;
    const string SCHEME_HTTPS = https ;
    /* 属性 */
    public $module ;
    public $controller ;
    public $action ;
    public $method ;
    protected $params ;
    protected $language ;
    protected $_exception ;
    protected $_base_uri ;
    protected $uri ;
    protected $dispatched ;
    protected $routed ;
    /* 方法 */
    public void getActionName ( void )
    public void getBaseUri ( void )
    public void getControllerName ( void )
    public void getEnv ( string $name [, string $default ] )
    public void getException ( void )
    public void getLanguage ( void )
    public void getMethod ( void )
    public void getModuleName ( void )
    public void getParam ( string $name [, string $default ] )
    public void getParams ( void )
    public void getRequestUri ( void )
    public void getServer ( string $name [, string $default ] )
    public void isCli ( void )
    public void isDispatched ( void )
    public void isGet ( void )
    public void isHead ( void )
    public void isOptions ( void )
    public void isPost ( void )
    public void isPut ( void )
    public void isRouted ( void )
    public void isXmlHttpRequest ( void )
    public void setActionName ( string $action )
    public void setBaseUri ( string $uir )
    public void setControllerName ( string $controller )
    public void setDispatched ( void )
    public void setModuleName ( string $module )
    public void setParam ( string $name [, string $value ] )
    public void setRequestUri ( string $uir )
    public void setRouted ([ string $flag ] )
}
\end{lstlisting}



Yaf\_Request\_Abstract的getPost()和getQuery()等方法并没有对应的setter方法，而且这些方法是直接从PHP内部的\$\_POST和\$\_GET等全局变量的原生变量只读的查询值，所以这里就产生了一个问题—通过在PHP脚本中对这些变量的修改，并不能反映到getPost()/getQuery()等方法。

\begin{example}
POST变量只读
\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public functin indexAction() {
        $_POST['name'] = 'new_name';
        // 此时对POST的修改, 并不能反映到getPost上
        echo $this->getRequest()->getPost('name'); // old name
    }
}
\end{lstlisting}
\end{example}

针对getPost()和getQuery()的设计是经过深思熟虑的, 也可以不依赖PHP的variable\_orders的配置，但是带来一个问题就是QA和Rd无法通过修改这些变量来做测试数据。

为了解决上述问题，Yaf提供了一个debug模式，在这个模式下的getPost()/getQuery()/getServer()/getCookie()将从符号表中的对应变量查询值，从而可以让我们直接对PHP的超级变量做的修改能反映到对应的Yaf\_Request\_Abstract的方法上。

\begin{lstlisting}[language=bash]
$ PHP_BIN/phpize
$ ./configure --enable-ap-debug --with-php-config=$PHP_BIN/php-config
$ make
$ make install  
\end{lstlisting}


在正式的生产环境中禁止以Debug模式编译Yaf，除了性能损耗之外就是Yaf的Debug模式有悖于\$\_POST等全局变量的只读特性。

为了提醒在生产环境中开启Debug模式的问题，Yaf的Debug模式在Yaf\_Application的构造函数中会触发一个E\_STRICT错误提示：

\begin{lstlisting}[language=bash]
Strict Standards: you are running ap in debug mode
\end{lstlisting}




\section{Property}


\subsection{\$module}

在路由完成后, 请求被分配到的模块名

\subsection{\$controller}

在路由完成后, 请求被分配到的控制器名

\subsection{\$action}

在路由完成后, 请求被分配到的动作名

\subsection{\$method}

当前请求的Method, 对于命令行来说, Method为\texttt{"CLI"}

\subsection{\$params}

当前请求的附加参数

\subsection{\$language}

当前请求的希望接受的语言, 对于Http请求来说, 这个值来自分析请求头Accept-Language. 对于不能鉴别的情况, 这个值为NULL.

\subsection{\$\_exception}
\subsection{\$\_base\_uri}

当前请求Request URI要忽略的前缀, 一般不需要手工设置, Yaf会自己分析。

只有当Yaf分析出错的时候, 可以通过application.baseUri来手工设置.

\subsection{\$uri}

当前请求的Request URI

\subsection{\$dispatched}

表示当前请求是否已经完成分发

\subsection{\$routed}

表示当前请求是否已经完成路由

\section{Constant}


\subsection{Yaf\_Request\_Abstract::SCHEME\_HTTP}

\subsection{Yaf\_Request\_Abstract::SCHEME\_HTTPS}

\section{Method}


\subsection{Yaf\_Request\_Abstract::getActionName()}



获取当前请求被路由到的动作(Action)名.




\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getActionName ( void )
\end{lstlisting}

路由成功以后, 返回当前被分发处理此次请求的动作名. 路由之前, 返回NULL


\begin{lstlisting}[language=PHP]
<?php
class ErrorController extends Yaf_Controller_Abstract {
    public funciton errorAction() {
        echo "current Action:" . $this->getRequest()->getActionName();
    }
}
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::getBaseUri()}




\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getBaseUri ( void )
\end{lstlisting}




\subsection{Yaf\_Request\_Abstract::getControllerName()}

获取当前请求被路由到的控制器名.

\begin{lstlisting}[language=PHP]
public string Yaf_Request_Abstract::getControllerName ( void )
\end{lstlisting}

路由成功以后, 返回当前被分发处理此次请求的控制器名. 路由之前, 返回NULL


\begin{lstlisting}[language=PHP]
<?php
class ErrorController extends Yaf_Controller_Abstract {
    public funciton errorAction() {
        echo "current Controller:" . $this->getRequest()->getControllerName();
    }
}
\end{lstlisting}

\subsection{Yaf\_Request\_Abstract::getEnv()}


取得ENV变量的值

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getEnv ( string $name [, string $default ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_ENV变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Abstract::getException()}


Yaf\_Request\_Abstract::getException()方法主要用于在异常捕获模式下, 在异常发生的情况时流程进入Error控制器的error动作时, 获取当前发生的异常对象。

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getException ( void )
\end{lstlisting}

在有异常的情况下, 返回当前异常对象. 没有异常的情况下, 返回NULL

\begin{lstlisting}[language=PHP]
<?php
class ErrorController extends Yaf_Controller_Abstract {
    public funciton errorAction() {
        $exception = $this->getRequest()->getException();
    }
}
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::getLanguage()}




\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getLanguage ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::getMethod()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getMethod ( void )
\end{lstlisting}

获取当前请求的类型, 可能的返回值为GET,POST,HEAD,PUT,CLI等.


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        if ($this->getRequest()->getMethod() == "CLI") {
            echo "running in cli mode";
        }
    }
}
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::getModuleName()}


获取当前请求被路由到的模块名

\begin{lstlisting}[language=PHP]
public string Yaf_Request_Abstract::getModuleName ( void )
\end{lstlisting}


路由成功以后, 返回当前被分发处理此次请求的模块名. 路由之前, 返回NULL

\begin{lstlisting}[language=PHP]
<?php
class ErrorController extends Yaf_Controller_Abstract {
    public funciton errorAction() {
        echo "current Module:" . $this->getRequest()->getModuleName();
    }
}
\end{lstlisting}



\subsection{Yaf\_Request\_Abstract::getParam()}

获取当前请求中的路由参数, 路由参数不是指\$\_GET或者\$\_POST, 而是在路由过程中, 路由协议根据Request Uri分析出的请求参数。

例如，对于默认的路由协议Yaf\_Route\_Static, 路由如下请求URL:\url{http://www.domain.com/module/controller/action/name1/value1/name2/value2/}路由结束后将会得到俩个路由参数, name1和name2, 值分别是value1, value2。

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getParam ( string $name [, string $default ] )
\end{lstlisting}

路由参数和\$\_GET,\$\_POST一样, 是来自用户的输入, 不是可信的. 使用前需要做安全过滤.


\begin{compactitem}
\item \$name - 要获取的路由参数名
\item \$default - 如果设定此参数, 如果没有找到\$name路由参数, 则返回此参数值.
\end{compactitem}

如果getParam()方法找到对应的值就返回对应的路由参数值, 如果没有找到, 而又设置了\$default\_value, 则返回default\_value, 否则返回NULL。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        echo "user id:" . $this->getRequest()->getParam("userid", 0);
    }
}
\end{lstlisting}



和getParam()不同，getParams()返回当前所有的路由参数。




\subsection{Yaf\_Request\_Abstract::getParams()}

获取当前请求中的所有路由参数。

需要注意的是，路由参数不是指\$\_GET或者\$\_POST, 而是在路由过程中, 路由协议根据Request Uri分析出的请求参数。

例如，对于默认的路由协议Yaf\_Route\_Static, 路由如下请求URL\url{http://www.domain.com/module/controller/action/name1/value1/name2/value2/}路由结束后将会得到俩个路由参数, name1和name2, 值分别是value1, value2.


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getParams ( void )
\end{lstlisting}

路由参数和\$\_GET,\$\_POST一样, 是来自用户的输入, 不是可信的. 使用前需要做安全过滤。



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        $this->getRequest()->getParams();
    }
}
\end{lstlisting}




\subsection{Yaf\_Request\_Abstract::getRequestUri()}




\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getRequestUri ( void )
\end{lstlisting}



\subsection{Yaf\_Request\_Abstract::getServer()}

返回SERVER全局变量的值

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::getServer ( string $name [, string $default ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_SERVER变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Abstract::isCli()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isCli ( void )
\end{lstlisting}

获取当前请求是否为CLI请求，如果是CLI请求返回TRUE, 不是返回FALSE。


\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        if ($this->getRequest()->isCli()) {
            echo "running in Cli mode";
        }
    }
}
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::isDispatched()}




\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isDispatched ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::isGet()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isGet ( void )
\end{lstlisting}

获取当前请求是否为GET请求，如果是GET请求返回TRUE, 不是返回FALSE。



\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        if ($this->getRequest()->isGet()) {
            echo "running in Get mode";
        }
    }
}
\end{lstlisting}



\subsection{Yaf\_Request\_Abstract::isHead()}



\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isHead ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::isOptions()}





\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isOptions ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::isPost()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isPost ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Abstract::isPut()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isPut ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::isRouted()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isRouted ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Abstract::isXmlHttpRequest()}

检测请求是否是AJAX请求。

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::isXmlHttpRequest ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::setActionName()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setActionName ( string $action )
\end{lstlisting}

\begin{compactitem}
\item \$action
\end{compactitem}



\subsection{Yaf\_Request\_Abstract::setBaseUri()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setBaseUri ( string $uri )
\end{lstlisting}

\begin{compactitem}
\item \$uri
\end{compactitem}

\subsection{Yaf\_Request\_Abstract::setControllerName()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setControllerName ( string $controller )
\end{lstlisting}

\begin{compactitem}
\item \$controller
\end{compactitem}

\subsection{Yaf\_Request\_Abstract::setDispatched()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setDispatched ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Abstract::setModuleName()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setModuleName ( string $module )
\end{lstlisting}

\begin{compactitem}
\item \$module
\end{compactitem}



\subsection{Yaf\_Request\_Abstract::setParam()}

为当前的请求设置路由参数。

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setParam ( string $name [, string $value ] )
\end{lstlisting}


\begin{compactitem}
\item \$name - 路由参数名
\item \$value - 路由参数值
\end{compactitem}

成功返回Yaf\_Request\_Abstract实例自身, 失败返回FALSE。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton indexAction() {
        $this->getRequest()->setParam("userid", 0);
    }
}
\end{lstlisting}

\subsection{Yaf\_Request\_Abstract::setRequestUri()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setRequestUri ( string $uri )
\end{lstlisting}

\begin{compactitem}
\item \$uri
\end{compactitem}



\subsection{Yaf\_Request\_Abstract::setRouted()}

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Abstract::setRouted ([ string $flag ] )
\end{lstlisting}

\begin{compactitem}
\item \$flag
\end{compactitem}

\chapter{Yaf\_Request\_Http}

Yaf\_Request\_Http代表了一个实际的HTTP请求，一般不需要自己实例化它，Yaf\_Application在run()以后会自动根据当前请求来实例化它。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Request\_Http。

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Request_Http extends Yaf_Request_Abstract {
    /* 属性 */
    /* 方法 */
    private void __clone ( void )
    __construct ( void )
    public mixed get ( string $name [, string $default ] )
    public mixed getCookie ( string $name [, string $default ] )
    public void getFiles ( void )
    public mixed getPost ( string $name [, string $default ] )
    public mixed getQuery ( string $name [, string $default ] )
    public void getRequest ( void )
    public bool isXmlHttpRequest ( void )
    /* 继承的方法 */
    public void Yaf_Request_Abstract::getActionName ( void )
    public void Yaf_Request_Abstract::getBaseUri ( void )
    public void Yaf_Request_Abstract::getControllerName ( void )
    public void Yaf_Request_Abstract::getEnv ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::getException ( void )
    public void Yaf_Request_Abstract::getLanguage ( void )
    public void Yaf_Request_Abstract::getMethod ( void )
    public void Yaf_Request_Abstract::getModuleName ( void )
    public void Yaf_Request_Abstract::getParam ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::getParams ( void )
    public void Yaf_Request_Abstract::getRequestUri ( void )
    public void Yaf_Request_Abstract::getServer ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::isCli ( void )
    public void Yaf_Request_Abstract::isDispatched ( void )
    public void Yaf_Request_Abstract::isGet ( void )
    public void Yaf_Request_Abstract::isHead ( void )
    public void Yaf_Request_Abstract::isOptions ( void )
    public void Yaf_Request_Abstract::isPost ( void )
    public void Yaf_Request_Abstract::isPut ( void )
    public void Yaf_Request_Abstract::isRouted ( void )
    public void Yaf_Request_Abstract::isXmlHttpRequest ( void )
    public void Yaf_Request_Abstract::setActionName ( string $action )
    public void Yaf_Request_Abstract::setBaseUri ( string $uir )
    public void Yaf_Request_Abstract::setControllerName ( string $controller )
    public void Yaf_Request_Abstract::setDispatched ( void )
    public void Yaf_Request_Abstract::setModuleName ( string $module )
    public void Yaf_Request_Abstract::setParam ( string $name [, string $value ] )
    public void Yaf_Request_Abstract::setRequestUri ( string $uir )
    public void Yaf_Request_Abstract::setRouted ([ string $flag ] )
}
\end{lstlisting}

\section{Property}

\subsection{\$module}
\subsection{\$controller}
\subsection{\$action}
\subsection{\$method}
\subsection{\$params}
\subsection{\$language}
\subsection{\$\_exception}
\subsection{\$\_base\_uri}
\subsection{\$uri}
\subsection{\$dispatched}
\subsection{\$routed}

\section{Method}


\subsection{Yaf\_Request\_Http::\_\_clone()}



\begin{lstlisting}[language=PHP]
private void Yaf_Request_Http::__clone ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Http::\_\_construct()}


\begin{lstlisting}[language=PHP]
Yaf_Request_Http::__construct ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Http::get()}

获取\$\_GET全局变量

\begin{lstlisting}[language=PHP]
public mixed Yaf_Request_Http::get ( string $name [, string $default ] )
\end{lstlisting}


从客户端返回变量，这个方法将从请求参数中寻找参数name，如果没有找到的话，将从POST, GET, Cookie, Server中寻找。

\begin{compactitem}
\item \$name - \$\_GET变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Http::getCookie()}

获取\$\_COOKIE全局变量

\begin{lstlisting}[language=PHP]
public mixed Yaf_Request_Http::getCookie ( string $name [, string $default ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_COOKIE变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Http::getFiles()}

获取\$\_FILES全局变量

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Http::getFiles ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Http::getPost()}

获取\$\_POST全局变量
\begin{lstlisting}[language=PHP]
public mixed Yaf_Request_Http::getPost ( string $name [, string $default ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_POST变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Http::getQuery()}

获取查询字符串（或\$\_GET）变量

\begin{lstlisting}[language=PHP]
public mixed Yaf_Request_Http::getQuery ( string $name [, string $default ] )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_GET变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}


\subsection{Yaf\_Request\_Http::getRequest()}

获取\$\_REQUEST全局变量

\begin{lstlisting}[language=PHP]
public void Yaf_Request_Http::getRequest ( void )
\end{lstlisting}

\begin{compactitem}
\item \$name - \$\_REQUEST变量的名字
\item \$default - 如果这个参数被提供了，当参数找不到的时候它将被返回
\end{compactitem}

\subsection{Yaf\_Request\_Http::isXmlHttpRequest()}

是否为Ajax请求


\begin{lstlisting}[language=PHP]
public bool Yaf_Request_Http::isXmlHttpRequest ( void )
\end{lstlisting}

这个方法取决于请求报头—HTTP\_X\_REQUESTED\_WITH，但是一些Javascript库在做Ajax请求时候不设置这个报文头。


\chapter{Yaf\_Request\_Simple}


Yaf\_Request\_Simple代表了一个实际的HTTP请求，一般不需要自己实例化它，Yaf\_Application在run()以后会自动根据当前请求来实例化它。

特别地，Yaf\_Request\_Simple可以被用于测试环境，例如CLI模式下模拟一些特殊的要求。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Request\_Simple。

\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Request_Simple extends Yaf_Request_Abstract {
    /* Constants */
    const string SCHEME_HTTP = http ;
    const string SCHEME_HTTPS = https ;
    /* 属性 */
    /* 方法 */
    private void __clone ( void )
    __construct ( void )
    public void get ( void )
    public void getCookie ( void )
    public void getFiles ( void )
    public void getPost ( void )
    public void getQuery ( void )
    public void getRequest ( void )
    public void isXmlHttpRequest ( void )
    /* 继承的方法 */
    public void Yaf_Request_Abstract::getActionName ( void )
    public void Yaf_Request_Abstract::getBaseUri ( void )
    public void Yaf_Request_Abstract::getControllerName ( void )
    public void Yaf_Request_Abstract::getEnv ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::getException ( void )
    public void Yaf_Request_Abstract::getLanguage ( void )
    public void Yaf_Request_Abstract::getMethod ( void )
    public void Yaf_Request_Abstract::getModuleName ( void )
    public void Yaf_Request_Abstract::getParam ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::getParams ( void )
    public void Yaf_Request_Abstract::getRequestUri ( void )
    public void Yaf_Request_Abstract::getServer ( string $name [, string $default ] )
    public void Yaf_Request_Abstract::isCli ( void )
    public void Yaf_Request_Abstract::isDispatched ( void )
    public void Yaf_Request_Abstract::isGet ( void )
    public void Yaf_Request_Abstract::isHead ( void )
    public void Yaf_Request_Abstract::isOptions ( void )
    public void Yaf_Request_Abstract::isPost ( void )
    public void Yaf_Request_Abstract::isPut ( void )
    public void Yaf_Request_Abstract::isRouted ( void )
    public void Yaf_Request_Abstract::isXmlHttpRequest ( void )
    public void Yaf_Request_Abstract::setActionName ( string $action )
    public void Yaf_Request_Abstract::setBaseUri ( string $uir )
    public void Yaf_Request_Abstract::setControllerName ( string $controller )
    public void Yaf_Request_Abstract::setDispatched ( void )
    public void Yaf_Request_Abstract::setModuleName ( string $module )
    public void Yaf_Request_Abstract::setParam ( string $name [, string $value ] )
    public void Yaf_Request_Abstract::setRequestUri ( string $uir )
    public void Yaf_Request_Abstract::setRouted ([ string $flag ] )
}
\end{lstlisting}

\section{Property}


\subsection{\$module}
\subsection{\$controller}
\subsection{\$action}
\subsection{\$method}
\subsection{\$params}
\subsection{\$language}
\subsection{\$\_exception}
\subsection{\$\_base\_uri}
\subsection{\$uri}
\subsection{\$dispatched}
\subsection{\$routed}

\section{Constant}


\subsection{Yaf\_Request\_Simple::SCHEME\_HTTP}


\subsection{Yaf\_Request\_Simple::SCHEME\_HTTPS}


\section{Method}


\subsection{Yaf\_Request\_Simple::\_\_clone()}





\begin{lstlisting}[language=PHP]
private void Yaf_Request_Simple::__clone ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::\_\_clone()}


\begin{lstlisting}[language=PHP]
Yaf_Request_Simple::__construct ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Simple::get()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::get ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::getCookie()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::getCookie ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::getFiles()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::getFiles ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::getPost()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::getPost ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::getQuery()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::getQuery ( void )
\end{lstlisting}


\subsection{Yaf\_Request\_Simple::getRequest()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::getRequest ( void )
\end{lstlisting}

\subsection{Yaf\_Request\_Simple::isXmlHttpRequest()}


\begin{lstlisting}[language=PHP]
public void Yaf_Request_Simple::isXmlHttpRequest ( void )
\end{lstlisting}

\chapter{Yaf\_Response\_Abstract}

响应对象和请求对象相对应, Yaf\_Response\_Abstract是发送给请求端的响应的载体。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Response\_Abstract。

\section{Synopsis}



\begin{lstlisting}[language=PHP]
Yaf_Response_Abstract {
    /* Constants */
    const string DEFAULT_BODY = "content" ;
    /* 属性 */
    protected $_header ;
    protected $_body ;
    protected $_sendheader ;
    /* 方法 */
    public bool appendBody ( string $content [, string $key ] )
    public bool clearBody ([ string $key ] )
    public void clearHeaders ( void )
    private void __clone ( void )
    public __construct ( void )
    public void __destruct ( void )
    public mixed getBody ([ string $key ] )
    public void getHeader ( void )
    public bool prependBody ( string $content [, string $key ] )
    public void response ( void )
    protected void setAllHeaders ( void )
    public bool setBody ( string $content [, string $key ] )
    public void setHeader ( void )
    public void setRedirect ( void )
    private void __toString ( void )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_header}

响应给请求的Header, 目前是保留属性

\subsection{\$\_body}

响应给请求的Body内容
\subsection{\$\_sendheader}

\section{Method}


\subsection{Yaf\_Response\_Abstract::appendBody()}




往已有的响应body后附加新的内容(并返回布尔值)



\begin{lstlisting}[language=PHP]
public bool Yaf_Response_Abstract::appendBody ( string $content [, string $key ] )
\end{lstlisting}

\begin{compactitem}
\item \$content - content string
\item \$key - 响应内容的key，可以设置一个键值对，如果没有具体的设置的话，系统默认使用Yaf\_Response\_Abstract::DEFAULT\_BODY
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$response = new Yaf_Response_Http();
$response->setBody('Hello')->prependBody(' World');
echo $response;
// 以上例程的输出类似于：
// Hello World
\end{lstlisting}



\subsection{Yaf\_Response\_Abstract::clearBody()}

清除已经设置的响应body

\begin{lstlisting}[language=PHP]
public bool Yaf_Response_Abstract::clearBody ([ string $key ] )
\end{lstlisting}

\begin{compactitem}
\item \$key 如果没有具体清除哪个key所对应的内容，那么所有内容将被清除
\end{compactitem}



\subsection{Yaf\_Response\_Abstract::clearHeaders()}



\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::clearHeaders ( void )
\end{lstlisting}



\subsection{Yaf\_Response\_Abstract::\_\_clone()}


\begin{lstlisting}[language=PHP]
private void Yaf_Response_Abstract::__clone ( void )
\end{lstlisting}


\subsection{Yaf\_Response\_Abstract::\_\_construct()}


\begin{lstlisting}[language=PHP]
public Yaf_Response_Abstract::__construct ( void )
\end{lstlisting}

\subsection{Yaf\_Response\_Abstract::\_\_destruct()}


\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::__destruct ( void )
\end{lstlisting}

\subsection{Yaf\_Response\_Abstract::getBody()}

获取已经设置的响应body


\begin{lstlisting}[language=PHP]
public mixed Yaf_Response_Abstract::getBody ([ string $key ] )
\end{lstlisting}

\begin{compactitem}
\item\$key - body所对应的key。

如果没有指定key，系统默认使用Yaf\_Response\_Abstract::DEFAULT\_BODY。如果传入一个NULL，所有的内容将会以数组形式被返回。
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$response = new Yaf_Response_Http();
$response->setBody('Hello')->setBody(' World','footer');
var_dump($response->getBody()); // default
var_dump($response->getBody(Yaf_Response_Abstract::DEFAULT_BODY)); // same as above
var_dump($response->getBody('footer'));
var_dump($response->getBody(NULL));// get all
// 以上例程的输出类似于：
// string(5) "Hello"
// string(5) "Hello"
// string(6) " World"
// array(2) {
//   ["content"]=>
//   string(5) "Hello"
//   ["footer"]=>
//   string(6) " World"
// }
\end{lstlisting}


\subsection{Yaf\_Response\_Abstract::getHeader()}

\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::getHeader ( void )
\end{lstlisting}



\subsection{Yaf\_Response\_Abstruct::prependBody()}

往已有的响应body前插入新的内容并返回bool值。

\begin{lstlisting}[language=PHP]
public bool Yaf_Response_Abstract::prependBody ( string $content [, string $key ] )
\end{lstlisting}

\begin{compactitem}
\item \$body - content string
\item \$key - body所对应的key。

可以设置一个body的键值对，如果没有指定key，系统默认使用Yaf\_Response\_Abstract::DEFAULT\_BODY
\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$response = new Yaf_Response_Http();
$response->setBody('World')->prependBody('Hello');

echo $response;
// 以上例程的输出类似于：
// Hello World
\end{lstlisting}

\subsection{Yaf\_Response\_Abstract::response()}

发送响应


\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::response ( void )
\end{lstlisting}

\begin{lstlisting}[language=PHP]
<?php
$response = new Yaf_Response_Http();
$response->setBody('Hello')->setBody(' World','footer');
$response->response();
// 以上例程的输出类似于：
// Hello World
\end{lstlisting}



\subsection{Yaf\_Response\_Abstract::setAllHeaders()}





\begin{lstlisting}[language=PHP]
protected void Yaf_Response_Abstract::setAllHeaders ( void )
\end{lstlisting}


\subsection{Yaf\_Response\_Abstract::setBody()}

设置响应的Body，\$name参数是保留参数（如果没有特殊效果, 留空即可）



\begin{lstlisting}[language=PHP]
public bool Yaf_Response_Abstract::setBody ( string $content [, string $key ] )
\end{lstlisting}

成功返回Yaf\_Response\_Abstract, 失败返回FALSE。

\begin{lstlisting}[language=PHP]
<?php
class IndexController extends Yaf_Controller_Abstract {
    public funciton init() {
        $this->getResponse()->setBody("Hello World");
    }
}
\end{lstlisting}

\begin{compactitem}
\item \$body - 要响应的字符串, 一般是一段HTML, 或者是一段JSON(返回给Ajax请求)
\item \$key - body所对应的key，可以设置一个body的键值对，如果没有指定key，系统默认使用Yaf\_Response\_Abstract::DEFAULT\_BODY
\end{compactitem}

或者，也可以通过指定不同的key, 给一个response对象设置很多响应字符串, 可以在所有的请求结束后做layout, 如果不做特殊处理就转交给Yaf去发送响应的话, 所有设置的响应字符串, 按照被设置的先后顺序被输出给客户端。


\begin{lstlisting}[language=PHP]
<?php
$response = new Yaf_Response_Http();
$response->setBody('Hello')->setBody(' World','footer');
print_r($response);
echo $response;
// 以上例程的输出类似于：
// Yaf_Response_Http Object
// (
//     [_header:protected] => Array
//         (
//         )

//     [_body:protected] => Array
//         (
//             [content] => Hello
//             [footer] =>  World
//         )

//     [_sendheader:protected] => 1
//     [_response_code:protected] => 200
// )
// Hello World
\end{lstlisting}

\subsection{Yaf\_Response\_Abstract::setHeader()}


\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::setHeader ( void )
\end{lstlisting}

\begin{example}
从Controller发送HTTP头
\begin{lstlisting}[language=PHP]
<?php
/* Set Content-Type */
$response = $this->getResponse();
$response->setHeader('Content-Type','text/html; charset=utf-8');

$response->response();

/* Set HTTP Status */
$response = $this->getResponse();
$response->setHeader($this->getRequest()->getServer('SERVER_PROTOCOL'),'404 NOT FOUND');

$response->response();
\end{lstlisting}
\end{example}

除了使用getServer()来获取\$\_SERVER全局变量之外，还可以直接使用\$\_SERVER。


\subsection{Yaf\_Response\_Abstract::setRedirect()}


\begin{lstlisting}[language=PHP]
public void Yaf_Response_Abstract::setRedirect ( void )
\end{lstlisting}

\subsection{Yaf\_Response\_Abstract::\_\_toString()}


\begin{lstlisting}[language=PHP]
private void Yaf_Response_Abstract::__toString ( void )
\end{lstlisting}


\chapter{Yaf\_Response\_Http}

Yaf\_Response\_Http是在Yaf作为Web应用的时候默认响应载体

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Response_Http extends Yaf_Response_Abstract {
    /* Constants */
    const string DEFAULT_BODY = "content" ;
    /* 属性 */
    protected $_header ;
    protected $_body ;
    protected $_sendheader ;
    protected $_response_code;
    /* 方法 */
    public void setHeader ( $name,$value,[$rep[,$response_code]] )
    public void setAllHeaders ( $headers )
    public void getHeader ( [$name] )
    public void clearHeaders ( void )
    public void setRedirect ( $url )
    /* 继承的方法 */
    public void Yaf_Response_Abstract response ( void )
    public Yaf_Response_Abstract __construct ( void )
    public void Yaf_Response_Abstract __destruct ( void )
    public void Yaf_Response_Abstract __toString ( void )
    public bool Yaf_Response_Abstract setBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract appendBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract prependBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract clearBody ([ string $name ] )
    public mixed Yaf_Response_Abstract getBody ([ string $name ] )
}
\end{lstlisting}

\section{Property}

\subsection{\$\_header}


\subsection{\$\_body}


\subsection{\$\_sendheader}


\subsection{\$\_response\_code}

响应给请求端的HTTP状态码


\section{Method}


\subsection{Yaf\_Response\_Http::setHeader(\$name,\$value,[\$rep[,\$response\_code]])}
\subsection{Yaf\_Response\_Http::setAllHeaders(\$headers )}
\subsection{Yaf\_Response\_Http::getHeader([\$name])}
\subsection{Yaf\_Response\_Http::clearHeaders(void)}
\subsection{Yaf\_Response\_Http::setRedirect(\$url)}

\subsection{Yaf\_Response\_Http::response(void)}
\subsection{Yaf\_Response\_Http::\_\_construct(void)}
\subsection{Yaf\_Response\_Http::\_\_destruct(void)}
\subsection{Yaf\_Response\_Http::\_\_toString(void)}
\subsection{Yaf\_Response\_Http::setBody(string \$body[,string \$name])}
\subsection{Yaf\_Response\_Http::appendBody(string \$body[,string \$name])}
\subsection{Yaf\_Response\_Http::prependBody(string \$body[,string \$name])}
\subsection{Yaf\_Response\_Http::clearBody([string \$name])}
\subsection{Yaf\_Response\_Http::getBody([string \$name])}

\chapter{Yaf\_Response\_Cli}

Yaf\_Response\_Cli是在Yaf作为命令行应用的时候默认响应载体。

\section{Synopsis}



\begin{lstlisting}[language=PHP]
Yaf_Response_Cli extends Yaf_Response_Abstract {
    /* Constants */
    const string DEFAULT_BODY = "content" ;
    /* 属性 */
    protected $_header ;
    protected $_body ;
    protected $_sendheader ;
    /* 继承的方法 */
    public Yaf_Response_Abstract __construct ( void )
    public void Yaf_Response_Abstract __destruct ( void )
    public void Yaf_Response_Abstract __toString ( void )
    public bool Yaf_Response_Abstract setBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract appendBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract prependBody ( string $body [, string $name ] )
    public bool Yaf_Response_Abstract clearBody ([ string $name ] )
    public mixed Yaf_Response_Abstract getBody ([ string $name ] )
    public void Yaf_Response_Abstract response ( void )
}
\end{lstlisting}


\section{Property}

\subsection{\$\_header}


\subsection{\$\_body}


\subsection{\$\_sendheader}


\section{Method}

\subsection{Yaf\_Response\_Cli::\_\_construct(void)}
\subsection{Yaf\_Response\_Cli::\_\_destruct(void)}
\subsection{Yaf\_Response\_Cli::\_\_toString(void)}
\subsection{Yaf\_Response\_Cli::setBody(string \$body[,string \$name])}
\subsection{Yaf\_Response\_Cli::appendBody(string \$body[, string \$name])}
\subsection{Yaf\_Response\_Cli::prependBody(string \$body[, string \$name])}
\subsection{Yaf\_Response\_Cli::clearBody([string \$name])}
\subsection{Yaf\_Response\_Cli::getBody([string \$name])}
\subsection{Yaf\_Response\_Cli::response(void)}




\chapter{Yaf\_Route\_Interface}

Yaf\_Route\_Interface是Yaf路由协议的标准接口, 它的存在使得用户可以自定义路由协议。

\section{Synopsis}



\begin{lstlisting}[language=PHP]
Yaf_Route_Interface {
    /* 方法 */
    abstract public string assemble ( array $info [, array $query ] )
    abstract public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}

\section{Method}

\subsection{Yaf\_Route\_Interface::assemble()}

将指定路由规则组合成一个url



\begin{lstlisting}[language=PHP]
abstract public string Yaf_Route_Interface::assemble ( array $info [, array $query ] )
\end{lstlisting}

这个方法会将指定的参数加上自定义的参数组合成一个url，所有route必须结合其路由规则来实现这个方法。

\begin{compactitem}
\item \$info
\item \$query
\end{compactitem}




\subsection{Yaf\_Route\_Interface::route()}

路由一个请求


\begin{lstlisting}[language=PHP]
abstract public bool Yaf_Route_Interface::route ( Yaf_Request_Abstract $request )
\end{lstlisting}


Yaf\_Route\_Interface::route() 是用户自定义路由唯一需要实现的方法。

\begin{compactitem}
\item 如果这个方法返回TRUE，那么路由进程将会中止。
\item 如果这个方法返回FLASE，那么Yaf\_Router 将会调用路由堆栈中的下一个路由来路由请求。
\end{compactitem}

这个方法会设置路由的结果给参数请求，通过调用Yaf\_Request\_Abstract::setControllerName()，Yaf\_Request\_Abstract::setActionName() 和 Yaf\_Request\_Abstract::setModuleName()。

这个方法也需要调用Yaf\_Request\_Abstract::setRouted()做最后的请求路由。

\begin{compactitem}
\item \$request - Yaf\_Request\_Abstract实例
\end{compactitem}


\chapter{Yaf\_Route\_Map}

\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Route_Map implements Yaf_Route_Interface {
    /* 属性 */
    protected $_ctl_router ;
    protected $_delimeter ;
    /* 方法 */
    public string assemble ( array $info [, array $query ] )
    public __construct ([ string $controller_prefer = false [, string $delimiter = '' ]] )
    public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_ctl\_router}



\subsection{\$\_delimeter}


\section{Method}


\subsection{Yaf\_Route\_Map::assemble()}

组合url

\begin{lstlisting}[language=PHP]
public string Yaf_Route_Map::assemble ( array $info [, array $query ] )
\end{lstlisting}


根据指定参数和自定义参数将map这个route组合成一个url

\begin{compactitem}
\item \$info

需要传入一个数组，数组的key可以为:a或者:c，其中:a表示action，:c表示controller。


当map route初始化时，controller\_prefer为false时，这个参数需要传入:c。当controller\_prefer 为true时，这个参数需要传入:a。

\item \$query

用户自定义的query string，将根据此路由规则拼接在url中

\end{compactitem}

\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route = new Yaf_Route_Map();

$router->addRoute('map',$route);
var_dump($router->getRoute('map')->assemble(
   array(':c'=>'foo_bar'),
   array('tkey1'=>'tval1','tkey2'=>'tval2')
));

$route = new Yaf_Route_Map(true,'_');
$router->addRoute('map',$route);
var_dump($router->getRoute('map')->assemble(
   array(':a'=>'foo_bar'),
   array('tkey1'=>'tval1','tkey2'=>'tval2')
));

// 以上例程的输出类似于：
// string(%d) "/foo/bar?tkey1=tval1&tkey2=tval2"
// string(%d) "/foo/bar/_/tkey1/tval1/tkey2/tval2"
\end{lstlisting}



\subsection{Yaf\_Route\_Map::\_\_construct()}


\begin{lstlisting}[language=PHP]
public Yaf_Route_Map::__construct ([ string $controller_prefer = false [, string $delimiter = '' ]] )
\end{lstlisting}

\begin{compactitem}
\item \$controller\_prefer - 结果是否应该考虑作为controller或action
\item \$delimeter
\end{compactitem}







\begin{example}
添加路由映射示例
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a map route to Yaf_Router route stack
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",new Yaf_Route_Map());
\end{lstlisting}
\end{example}

以上示例的输出类似于：



\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/product/foo/bar
 * route will result in following values:
 */
array(
  "controller" => "product_foo_bar",
)
\end{lstlisting}


\begin{example}
通过调用addRoute()添加路由映射
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a map route to Yaf_Router route stack
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",new Yaf_Route_Map(true, "_"));
\end{lstlisting}
\end{example}

以上例程的输出类似于：

\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/user/list/_/foo/22
 * route will result in following values:
 */
array(
    "action" => "user_list",
)

/**
 * and request parameters:
 */
array(
  "foo"   => 22,
)
\end{lstlisting}

\begin{example}
通过调用addConfig()来添加路由映射
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a map route to Yaf_Router route stack by calling addconfig
 */
$config = array(
    "name" => array(
        "type"  => "map",         //Yaf_Route_Map route
        "controllerPrefer" => FALSE,
        "delimiter"        => "#!",
    ),
);
Yaf_Dispatcher::getInstance()->getRouter()->addConfig(new Yaf_Config_Simple($config));
\end{lstlisting}
\end{example}

\subsection{Yaf\_Route\_Map::route()}

执行路由

\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Map::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}

\chapter{Yaf\_Route\_Regex}

Yaf\_Route\_Regex是Yaf内置的路由中最灵活的。


\begin{lstlisting}[language=PHP]
class Yaf_Route_Regex extends Yaf_Route_Interface implements Yaf_Route_Interface {
    /* 属性 */
    protected $_route;
    protected $_default;
    protected $_maps;
    protected $_verify;
    /* 方法 */
    public string assemble(array $info [, array $query]);
    public __construct(string $match, array $route [, array $map [, array $verify]]);
    public bool route(Yaf_Request_Abstract $request);
    /* 继承的方法 */
    abstract public string Yaf_Route_Interface::assemble(array $info [, array $query]);
    abstract public bool Yaf_Route_Interface::route(Yaf_Request_Abstract $request);
}
\end{lstlisting}

\section{Property}


\subsection{\$\_route}


\subsection{\$\_default}


\subsection{\$\_maps}


\subsection{\$\_verify}



\section{Method}


\subsection{Yaf\_Route\_Regex::assemble()}

组合url


\begin{lstlisting}[language=PHP]
public string Yaf_Route_Regex::assemble ( array $info [, array $query ] )
\end{lstlisting}

根据指定参数和自定义参数将regex这个route组合成一个url。

在regex route使用assemble需要在初始化时指定reverse参数，否则将不能正常工作。

\begin{compactitem}
\item \$info - 需要传入一个数组，数组的key可以为:a、:c、:m，:a表示action，:c表示controller，:m表示module。


\item \$query - 用户自定义的query string，将根据此路由规则拼接在url中
\end{compactitem}


\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route = new Yaf_Route_Regex(
    "#^/product/([^/]+)/([^/])+#",
    array(
        'controller' => "product",  //route to product controller,
    ),
    array(),
    array(),
    '/:m/:c/:a'
);
$router->addRoute("regex", $route);
var_dump($router->getRoute('regex')->assemble(
    array(
        ':m' => 'module',
        ':c' => 'controller',
        ':a' => 'action'
    ),
    array(
        'tkey1' => 'tval1',
        'tkey2' =>
            'tval2'
    )
));
\end{lstlisting}

以上例程的输出类似于：

\begin{lstlisting}[language=PHP]
string(49) "/module/controller/action?tkey1=tval1&tkey2=tval2"
\end{lstlisting}


\subsection{Yaf\_Route\_Regex::\_\_construct()}


\begin{lstlisting}[language=PHP]
publicYaf_Route_Regex::__construct ( string $match , array $route [, array $map [, array $verify ]] )
\end{lstlisting}

\begin{compactitem}
\item \$match - 一个完整的正则表达式，用来匹配一个请求的uri，如果不能匹配，Yaf\_Route\_Regex 将返回FALSE。

\item \$route - 当路由正则匹配成功请求uri时，Yaf\_Route\_Regex将会用它来决定哪一个m/c/a被路由。

在这个数组中无论是m/c/a都是最优的，如果没有提供一个明确的值，它将会以默认方式被路由。 另外也可以使用map的结果作为m/c/a的结果.

\item \$map - 将匹配到的结果捕捉放到一个已经命名好的数组中。

\item \$verify

\end{compactitem}

\begin{example}
添加正则路由
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a regex route to Yaf_Router route stack
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",
    new Yaf_Route_Regex(
        "#^/product/([^/]+)/([^/])+#", //match request uri leading "/product"
        array(
            'controller' => "product",  //route to product controller,
        ),
        array(
            1 => "name",   // now you can call $request->getParam("name")
            2 => "id",     // to get the first captrue in the match pattern.
        )
    )
);
\end{lstlisting}
\end{example}


\begin{example}
使用动态的controller
\begin{lstlisting}[language=PHP]
<?php
/**
 *  使用动态的controller
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",
    new Yaf_Route_Regex(
        "#^/product/([^/]+)/([^/])+#", //match request uri leading "/product"
        array(
            'controller' => ":name",  //使用上面匹配的:name, 也就是$1作为controller
        ),
        array(
            1 => "name",   // now you can call $request->getParam("name")
            2 => "id",     // to get the first captrue in the match pattern.
        )
    )
);
\end{lstlisting}
\end{example}



\begin{example}
使用addConfig()添加正则路由
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a regex route to Yaf_Router route stack by calling addconfig
 */
$config = array(
    "name" => array(
        "type"  => "regex",          //Yaf_Route_Regex route
        "match" => "#(.*)#",         //match arbitrary request uri
        "route" => array(
            'controller' => "product",  //route to product controller,
            'action'     => "dummy",    //route to dummy action
        ),
        "map" => array(
            1 => "uri",   // now you can call $request->getParam("uri")
        ),
    ),
);
Yaf_Dispatcher::getInstance()->getRouter()->addConfig(
    new Yaf_Config_Simple($config));
\end{lstlisting}
\end{example}

\subsection{Yaf\_Route\_Regex::route()}

路由一个传进来的请求。


\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Regex::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}

如果正则表达式是Yaf\_Route\_Regex::\_\_construct()的第一个参数，并且匹配了请求uri，返回TRUE，否则返回FALSE。


\chapter{Yaf\_Route\_Rewrite}

\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Route_Rewrite extends Yaf_Route_Interface implements Yaf_Route_Interface {
    /* 属性 */
    protected $_route ;
    protected $_default ;
    protected $_verify ;
    /* 方法 */
    public string assemble ( array $info [, array $query ] )
    public __construct ( string $match , array $route [, array $verify ] )
    public bool route ( Yaf_Request_Abstract $request )
    /* 继承的方法 */
    abstract public string Yaf_Route_Interface::assemble ( array $info [, array $query ] )
    abstract public bool Yaf_Route_Interface::route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}


\section{Property}


\subsection{\$\_route}


\subsection{\$\_default}


\subsection{\$\_verify}



\section{Method}


\subsection{Yaf\_Route\_Rewrite::assemble()}

组合url



\begin{lstlisting}[language=PHP]
public string Yaf_Route_Rewrite::assemble ( array $info [, array $query ] )
\end{lstlisting}

根据指定参数和自定义参数将rewrite这个route组合成一个url

\begin{compactitem}
\item \$info - 需要传入一个数组，数组中每个key必须和初始化rewrite route时\$match参数中的带冒号的参数名一致


\item \$query - 用户自定义的query string，将根据此路由规则拼接在url中

\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route = new Yaf_Route_Rewrite(
    "/product/:name/:id/*",
    array(
        'controller' => "product",
    ),
    array()
);
$router->addRoute("rewrite", $route);

var_dump($router->getRoute('rewrite')->assemble(
    array(
        ':name' => 'foo',
        ':id' => 'bar',
        ':tmpkey1' => 'tmpval1'
    ),
    array(
        'tkey1' => 'tval1',
        'tkey2' => 'tval2'
    )
));
\end{lstlisting}

以上例程的输出类似于：

\begin{lstlisting}[language=PHP]
string(57) "/product/foo/bar/tmpkey1/tmpval1/?tkey1=tval1&tkey2=tval2"
\end{lstlisting}


\subsection{Yaf\_Route\_Rewrite::\_\_construct()}




\begin{lstlisting}[language=PHP]
public Yaf_Route_Rewrite::__construct ( string $match , array $route [, array $verify ] )
\end{lstlisting}

\begin{compactitem}
\item \$match - 一个类似正则表达式，会被用来匹配一个请求的uri，如果匹配失败，Yaf\_Route\_Rewrite 会返回FALSE。

\item \$route - 当路由正则匹配成功请求uri时，Yaf\_Route\_Rewrite 将会用它来决定哪一个m/c/a被路由。

在这个数组中无论是m/c/a都是最优的，如果你没有提供一个明确的值，它将会以默认方式被路由。

\item \$verify
\end{compactitem}


\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a rewrite route to Yaf_Router route stack
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",
    new Yaf_Route_rewrite(
        "/product/:name/:id/*", //match request uri leading "/product"
        array(
            'controller' => "product",  //route to product controller,
        )
    )
);
\end{lstlisting}

以上例程的输出类似于：



\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/product/foo/22/foo/bar
 * route will result in following values:
 */
array(
  "controller" => "product",
  "module"     => "index", //(default)
  "action"     => "index", //(default)
)

/**
 * and request parameters:
 */
array(
  "name" => "foo",
  "id"   => 22,
  "foo"  => bar
)
\end{lstlisting}


\begin{example}
通过addConfig()添加Rewrite路由
\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a rewrite route to Yaf_Router route stack by calling addconfig
 */
$config = array(
    "name" => array(
        "type" => "rewrite",        //Yaf_Route_Rewrite route
        "match" => "/user-list/:id", //match only /user/list/?/
        "route" => array(
            'controller' => "user",  //route to user controller,
            'action' => "list",  //route to list action
        ),
    ),
);
Yaf_Dispatcher::getInstance()->getRouter()->addConfig(
    new Yaf_Config_Simple($config));
\end{lstlisting}
\end{example}

以上例程的输出类似于：



\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/user-list/22
 * route will result in following values:
 */
array(
  "controller" => "user",
  "action"     => "list",
  "module"     => "index", //(default)
)

/**
 * and request parameters:
 */
array(
  "id"   => 22,
)
\end{lstlisting}


\begin{example}
使用动态结果作为action名
\begin{lstlisting}[language=PHP]
<?php
/**
 * 使用动态结果作为action名
 */
$config = array(
    "name" => array(
        "type" => "rewrite",        //Yaf_Route_Rewrite route
        "match" => "/user-list/:a/:id", //match only /user-list/开头的
        "route" => array(
            'controller' => "user",  //route to user controller,
            'action' => ":a",  //使用动态的action
        ),
    ),
);
Yaf_Dispatcher::getInstance()->getRouter()->addConfig(
    new Yaf_Config_Simple($config));
\end{lstlisting}
\end{example}

以上例程的输出类似于：



\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/user-list/list/22
 * route will result in following values:
 */
array(
  "controller" => "user",
  "action"     => "list",
  "module"     => "index", //(default)
)

/**
 * and request parameters:
 */
array(
  "id"   => 22,
)
\end{lstlisting}




\subsection{Yaf\_Route\_Rewrite::route()}







\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Rewrite::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}

\chapter{Yaf\_Router}

Yaf\_Router是标准的框架路由。


\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Router {
   /* 属性 */
   protected $_routes ;
   protected $_current ;
   /* 方法 */
   public void addConfig ( Yaf_Config_Abstract $config )
   public Yaf_Router addRoute ( string $name , Yaf_Route_Abstract $route )
   public __construct ( void )
   public string getCurrentRoute ( void )
   public void getRoute ( string $name )
   public void getRoutes ( void )
   public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}

路由是一个拿到URI端点（URL中的URI的一部分）然后分解参数得到哪一个module, controller, 和action需要接受请求。

module, controller, 和action，还有一些其他的参数是打包在一个Yaf\_Request\_Abstract的对象中，然后通过Yaf\_Dispatcher来处理的。

路由只发生一次——最初接到请求并且在第一个controller分发之前。

Yaf\_Router被设计来允许使用纯PHP结构的类似功能模块的跳转，其本身非常松散的基于Ruby on Rails的路由，并且不需要开发者了解Web服务器处理URL跳转的相关知识。

Yaf\_Router可以处理一个Apache 跳转（mod\_rewrite）模块的规则。


\begin{example}
Apache的跳转规则
\begin{lstlisting}[language=PHP]
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css|html)$ index.php
\end{lstlisting}
\end{example}



\begin{example}
预定义的Apache的跳转规则
\begin{lstlisting}[language=PHP]
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} -s [OR]
RewriteCond %{REQUEST_FILENAME} -l [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^.*$ - [NC,L]
RewriteRule ^.*$ index.php [NC,L]
\end{lstlisting}
\end{example}

\begin{example}
Lighttpd的跳转规则
\begin{lstlisting}[language=PHP]
url.rewrite-once = (
  ".*\?(.*)$" => "/index.php?$1",
  ".*\.(js|ico|gif|jpg|png|css|html)$" => "$0",
  "" => "/index.php"
)
\end{lstlisting}
\end{example}


\begin{example}
Nginx的跳转规则
\begin{lstlisting}[language=PHP]
server {
  listen ****;
  server_name  yourdomain.com;
  root   document_root;
  index  index.php index.html;

  if (!-e $request_filename) {
    rewrite ^/(.*)  /index.php/$1 last;
  }
}
\end{lstlisting}
\end{example}


Yaf\_Router预设了一个默认路由，它将以controller/action的形式匹配URIs。

此外，一个module的名字可以被指定为第一路径元素，允许URIs设置为module/controller/action的形式。

最后，Yaf\_Router也会匹配一些URI中额外附加的参数，默认形式是controller/action/var1/value1/var2/value2。

\begin{example}
Yaf\_Route\_Static
\begin{lstlisting}[language=PHP]
// Assuming the following configure:
$conf = array(
   "application" => array(
      "modules" => "Index,Blog",
   ),
);

Controller only:
http://example/news
    controller == news
Action only(when defined yaf.action_prefer=1 in php.ini)
    action  == news
 
Invalid module maps to controller name:
http://example/foo
    controller == foo
 
Module + controller:
http://example/blog/archive
    module     == blog
    controller == archive
 
Module + controller + action:
http://example/blog/archive/list
    module     == blog
    controller == archive
    action     == list
 
Module + controller + action + params:
http://example/blog/archive/list/sort/alpha/date/desc
    module     == blog
    controller == archive
    action     == list
    sort       == alpha
    date       == desc
\end{lstlisting}
\end{example}


\section{Property}


\subsection{\$\_route}


\subsection{\$\_current}


\section{Method}


\subsection{Yaf\_Router::addConfig()}


向Router中添加配置文件中定义的路由







\begin{lstlisting}[language=PHP]
public void Yaf_Router::addConfig ( Yaf_Config_Abstract $config )
\end{lstlisting}

将application.ini中定义的路由规则添加到Yaf\_Router的路由栈中

下面是一个在application.ini中定义的路由规则示例：


\begin{lstlisting}[language=PHP]
;the order is very important, the prior one will be called first

;a rewrite route match request /product/*/*
routes.route_name.type="rewrite"
routes.route_name.match="/product/:name/:value"
routes.route_name.route.controller=product
routes.route_name.route.action=info

;a regex route match request /list/*/*
routes.route_name1.type="regex"
routes.route_name1.match="#^list/([^/]*)/([^/]*)#"
routes.route_name1.route.controller=Index
routes.route_name1.route.action=action
routes.route_name1.map.1=name
routes.route_name1.map.2=value

;a simple route match /**?c=controller&a=action&m=module
routes.route_name2.type="simple"
routes.route_name2.controller=c
routes.route_name2.module=m
routes.route_name2.action=a

;a simple router match /**?r=PATH_INFO
routes.route_name3.type="supervar"
routes.route_name3.varname=r

;a map route match any request to controller
routes.route_name4.type="map"
routes.route_name4.controllerPrefer=TRUE
routes.route_namer.delimiter="#!"
\end{lstlisting}

\begin{example}
使用Yaf\_Dispatcher::autoConfig()加载路由规则
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initConfig() {
        $config = Yaf_Application::app()->getConfig();
        Yaf_Registry::set("config", $config);
    }

    public function _initRoute(Yaf_Dispatcher $dispatcher) {
        $router = $dispatcher->getRouter();
        /**
         * we can add some pre-defined routes in application.ini
         */
        $router->addConfig(Yaf_Registry::get("config")->routes);
    }
}
\end{lstlisting}
\end{example}




\subsection{Yaf\_Router::addRoute()}

往Router中添加新的路由


\begin{lstlisting}[language=PHP]
public Yaf_Router Yaf_Router::addRoute ( string $name , Yaf_Route_Abstract $route )
\end{lstlisting}


默认地，Yaf\_Router使用Yaf\_Route\_Static作为它的默认的路由，可以通过调用这个方法往Router的堆栈中添加一个新的路由。

在路由栈中，新的路由规则会比老的规则先调用，如果新路由规则返回TRUE，那么路由进程将会结束。否则，老的规则将会被调用。

\begin{example}
Yaf\_Dispatcher::autoRender()示例
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initConfig() {
        $config = Yaf_Application::app()->getConfig();
        Yaf_Registry::set("config", $config);
    }

    public function _initRoute(Yaf_Dispatcher $dispatcher) {
        $router = $dispatcher->getRouter();
        /**
         * we can add some pre-defined routes in application.ini
         */
        $router->addConfig(Yaf_Registry::get("config")->routes);
        /**
         * add a Rewrite route, then for a request uri:
         * http://domain/product/list/22/foo
         * will be matched by this route, and result:
         *
         *  [module] =>
         *  [controller] => product
         *  [action] => info
         *  [method] => GET
         *  [params:protected] => Array
         *      (
         *          [id] => 22
         *          [name] => foo
         *      )
         */
        $route = new Yaf_Route_Rewrite(
            "/product/list/:id/:name",
            array(
                "controller" => "product",
                "action" => "info",
            )
        );

        $router->addRoute('dummy', $route);
    }
}
\end{lstlisting}
\end{example}







\subsection{Yaf\_Router::\_\_construct()}



\begin{lstlisting}[language=PHP]
public Yaf_Router::__construct ( void )
\end{lstlisting}


\subsection{Yaf\_Router::getCurrentRoute()}

取得当前有效的路由的名字


\begin{lstlisting}[language=PHP]
public string Yaf_Router::getCurrentRoute ( void )
\end{lstlisting}

获取当前路由进程中正在起作用的路由名，开发者需要在路由进程结束之后调用此方法，在这之前，这个方法会一直返回NULL。

\begin{example}
注册路由到Bootstrap
\begin{lstlisting}[language=PHP]
<?php
class Bootstrap extends Yaf_Bootstrap_Abstract {
    public function _initConfig() {
        $config = Yaf_Application::app()->getConfig();
        Yaf_Registry::set("config", $config);
    }

    public function _initRoute(Yaf_Dispatcher $dispatcher) {
        $router = $dispatcher->getRouter();
        $rewrite_route = new Yaf_Route_Rewrite(
            "/product/list/:page",
            array(
                "controller" => "product",
                "action" => "list",
            )
        );

        $regex_route = new Yaf_Route_Rewrite(
            "#^/product/info/(\d+)",
            array(
                "controller" => "product",
                "action" => "info",
            )
        );
        $router->addRoute('rewrite', $rewrite_route)->addRoute('regex', $regex_route);
    }

    /**
     * register plugin
     */
    public function __initPlugins(Yaf_Dispatcher $dispatcher) {
        $dispatcher->registerPlugin(new DummyPlugin());
    }
}
\end{lstlisting}
\end{example}


\begin{example}
application.directory/plugins/Dummy.php
\begin{lstlisting}[language=PHP]
<?php
class DummyPlugin extends Yaf_Plugin_Abstract {

    public function routerShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) {
        var_dump(Yaf_Dispatcher::getInstance()->getRouter()->getCurrentRoute());
    }
}
\end{lstlisting}
\end{example}


以上例程的输出类似于：

\begin{lstlisting}[language=PHP]
/* for http://yourdomain.com/product/list/1
 * DummyPlugin will output:
 */
string(7) "rewrite"

/* for http://yourdomain.com/product/info/34
 * DummyPlugin will output:
 */
string(5) "regex"

/* for other request URI
 * DummyPlugin will output:
 */
string(8) "_default"
\end{lstlisting}

\subsection{Yaf\_Router::getRoute()}


\begin{lstlisting}[language=PHP]
public void Yaf_Router::getRoute ( string $name )
\end{lstlisting}


\subsection{Yaf\_Router::getRoutes()}



\begin{lstlisting}[language=PHP]
public void Yaf_Router::getRoutes ( void )
\end{lstlisting}

\subsection{Yaf\_Router::route()}


\begin{lstlisting}[language=PHP]
public bool Yaf_Router::route ( Yaf_Request_Abstract $request )
\end{lstlisting}


\chapter{Yaf\_Route\_Simple}


Yaf\_Route\_Simple 会匹配请求中的query string，然后找到路由信息。

开发者需要做的只是告诉 Yaf\_Route\_Simple，在\$\_GET中哪个是Module，哪个是Controller，哪个是Action。


\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Route_Simple implements Yaf_Route_Interface {
    /* 属性 */
    protected $controller ;
    protected $module ;
    protected $action ;
    /* 方法 */
    public string assemble ( array $info [, array $query ] )
    public__construct ( string $module_name , string $controller_name , string $action_name )
    public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}


另外，Yaf\_Route\_Simple::route() 总是会返回TRUE，所以把Yaf\_Route\_Simple放在路由堆栈前面是很重要的，否则其他所有的路由都可能不会被调用到。


\section{Property}

\subsection{\$controller}


\subsection{\$module}


\subsection{\$action}


\section{Method}


\subsection{Yaf\_Route\_Simple::assemble()}

组合url





\begin{lstlisting}[language=PHP]
public string Yaf_Route_Simple::assemble ( array $info [, array $query ] )
\end{lstlisting}

根据指定参数和自定义参数将simple这个route组合成一个url

\begin{compactitem}
\item \$info - 需要传入一个数组，数组中每个key可为:m、:c、:a，:m代表module，:c代表controller, :a代表action

\item \$query - 用户自定义的query string，将根据此路由规则拼接在url中

\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route  = new Yaf_Route_Simple('m', 'c', 'a');
$router->addRoute("simple", $route);
var_dump($router->getRoute('simple')->assemble(
    array(
        ':a' => 'yafaction',
        'tkey' => 'tval',
        ':c' => 'yafcontroller',
        ':m' => 'yafmodule'
    ),
    array(
        'tkey1' => 'tval1',
        'tkey2' => 'tval2'
    )
));
// 以上例程的输出类似于：
string(64) "?m=yafmodule&c=yafcontroller&a=yafaction&tkey1=tval1&tkey2=tval2"
\end{lstlisting}

\subsection{Yaf\_Route\_Simple::\_\_construct()}




\begin{lstlisting}[language=PHP]
public Yaf_Route_Simple::__construct ( string $module_name , string $controller_name , string $action_name )
\end{lstlisting}

Yaf\_Route\_Simple将从query string中获得路由信息。这个构造函数的参数会被作为键到\$\_GET中去寻找路由信息。

\begin{compactitem}
\item \$module\_name - module信息的键名
\item \$controller\_name - controller信息的键名
\item \$action\_name - action信息的键名
\end{compactitem}




\begin{lstlisting}[language=PHP]
<?php
$route = new Yaf_Route_Simple("m", "controller", "act");
Yaf_Router::getInstance()->addRoute("simple", $route);
\end{lstlisting}

上述示例的输出可能如下：

\begin{lstlisting}[language=PHP]
Request: http://yourdomain.com/path/?controller=a&act=b
=> module = default(index), controller = a, action = b

Request: http://yourdomain.com/path
=> module = default(index), controller = default(index), action = default(index)
\end{lstlisting}

\subsection{Yaf\_Route\_Simple::route()}



\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Simple::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}

\chapter{Yaf\_Route\_Static}

默认的，Yaf\_Router 只有一个Yaf\_Route\_Static 作为它默认的路由。

Yaf\_Route\_Static 旨在处理80\%的要求，而且实例化 Yaf\_Route\_Static 是没有必要的，也没必要将它加入Yaf\_Router的路由堆栈。

在Yaf\_Router的路由堆栈中总是存在Yaf\_Route\_Static的一个实例，并且总是在最后被调用。

\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Route_Static implements Yaf_Router {
    /* 方法 */
    public string assemble ( array $info [, array $query ] )
    public void match ( string $uri )
    public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}

\section{Method}


\subsection{Yaf\_Route\_Static::assemble()}

组合url





\begin{lstlisting}[language=PHP]
public string Yaf_Route_Static::assemble ( array $info [, array $query ] )
\end{lstlisting}

根据指定参数和自定义参数将static这个route组合成一个url。

\begin{compactitem}
\item \$info - 需要传入一个数组，数组中每个key可为:m、:c、:a，:m代表module，:c代表controller, :a代表action

\item \$query - 用户自定义的query string，将根据此路由规则拼接在url中

\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route  = new Yaf_Route_Static();
$router->addRoute("static", $route);
var_dump($router->getRoute('static')->assemble(
    array(
        ':a' => 'yafaction',
        'tkey' => 'tval',
        ':c' => 'yafcontroller',
        ':m' => 'yafmodule'
    ))
);

var_dump($router->getRoute('static')->assemble(
    array(
        ':a' => 'yafaction',
        'tkey' => 'tval',
        ':c' => 'yafcontroller',
        ':m' => 'yafmodule'
    ),
    array(
        'tkey1' => 'tval1',
        'tkey2' => 'tval2'
    ))
);
// 以上例程的输出类似于：
// string(%d) "/yafmodule/yafcontroller/yafaction"
// string(%d) "/yafmodule/yafcontroller/yafaction?tkey1=tval1&tkey2=tval2"
\end{lstlisting}

\subsection{Yaf\_Route\_Static::match()}


\begin{lstlisting}[language=PHP]
public void Yaf_Route_Static::match ( string $uri )
\end{lstlisting}

\begin{compactitem}
\item \$uri
\end{compactitem}

\subsection{Yaf\_Route\_Static::route()}



\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Static::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}



\begin{lstlisting}[language=PHP]
// assuming there is only one module defined:Index
Request: http://yourdomain.com/a/b
=> module = index, controller=a, action=b

//assuming ap.action_prefer = On
Request: http://yourdomain.com/b
=> module = default(index), controller = default(index), action = b

//assuming ap.action_prefer = Off
Request: http://yourdomain.com/b
=> module = default(index), controller = b, action = default(index)


Request: http://yourdomain.com/a/b/foo/bar/test/a/id/4
=> module = default(index), controller = a, action = b, request parameters: foo = bar, test = a, id = 4
\end{lstlisting}

\chapter{Yaf\_Route\_Supervar}


\section{Synopsis}






\begin{lstlisting}[language=PHP]
Yaf_Route_Supervar implements Yaf_Route_Interface {
   /* 属性 */
   protected $_var_name ;
   /* 方法 */
   public string assemble ( array $info [, array $query ] )
   public __construct ( string $supervar_name )
   public bool route ( Yaf_Request_Abstract $request )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_var\_name}


\section{Method}


\subsection{Yaf\_Route\_Supervar::assemble()}


组合url


\begin{lstlisting}[language=PHP]
public string Yaf_Route_Supervar::assemble ( array $info [, array $query ] )
\end{lstlisting}

根据指定参数和自定义参数将supervar这个route组合成一个url

\begin{compactitem}
\item \$info - 需要传入一个数组，数组中每个key可为:m、:c、:a，:m代表module，:c代表controller, :a代表action

\item \$query - 用户自定义的query string，将根据此路由规则拼接在url中

\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
$router = new Yaf_Router();
$route  = new Yaf_Route_Supervar('r');
$router->addRoute("supervar", $route);
var_dump($router->getRoute('supervar')->assemble(
    array(
        ':a' => 'yafaction',
        'tkey' => 'tval',
        ':c' => 'yafcontroller',
        ':m' => 'yafmodule'
    ),
    array(
        'tkey1' => 'tval1',
        'tkey2' => 'tval2'
    )
));

try {
    var_dump($router->getRoute('supervar')->assemble(
        array(
            ':a' => 'yafaction',
            'tkey' => 'tval',
            ':m' => 'yafmodule'
        ),
        array(
            'tkey1' => 'tval1',
            'tkey2' => 'tval2',
            1 => array(),
        )
    ));
} catch (Exception $e) {
    var_dump($e->getMessage());
}
// 以上例程的输出类似于：
// string(%d) "?r=/yafmodule/yafcontroller/yafaction&tkey1=tval1&tkey2=tval2"
// string(%d) "You need to specify the controller by ':c'"
\end{lstlisting}

\subsection{Yaf\_Route\_Supervar::\_\_construct()}

\begin{lstlisting}[language=PHP]
public Yaf_Route_Supervar::__construct ( string $supervar_name )
\end{lstlisting}

Yaf\_Route\_Supervar 类似于 Yaf\_Route\_Static，不同的是Yaf\_Route\_Supervar 在query string 中寻找路径信息，参数 supervar\_name 是键名。

\begin{compactitem}
\item \$supervar\_name - 键名
\end{compactitem}



\begin{lstlisting}[language=PHP]
<?php
/**
 * Add a supervar route to Yaf_Router route stack
 */
Yaf_Dispatcher::getInstance()->getRouter()->addRoute("name",
    new Yaf_Route_Supervar("r"));
\end{lstlisting}

以上例程的输出类似于：

\begin{lstlisting}[language=PHP]
/** 
 *for request: http://yourdomain.com/xx/oo/?r=/ctr/act/var/value
 * will result in following:
 */
array (
    "module"   => index(default),
    "controller" => ctr,
    "action"     => act,
    "params"     => array(
    "var" => value,
  )
)
\end{lstlisting}


\subsection{Yaf\_Route\_Supervar::route()}




\begin{lstlisting}[language=PHP]
public bool Yaf_Route_Supervar::route ( Yaf_Request_Abstract $request )
\end{lstlisting}

\begin{compactitem}
\item \$request
\end{compactitem}

如果在\$\_GET中存在对应的键名（在Yaf\_Route\_Supervar::\_\_construct()中定义）就返回TRUE，否则返回FALSE。

\chapter{Yaf\_Session}

Yaf\_Session是Yaf对Session的包装，并实现了Iterator, ArrayAccess, Countable接口。

在打开yaf.use\_namespace的情况下，可以使用Yaf\textbackslash Session。


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Session implements Iterator , Traversable , ArrayAccess , Countable {
    /* 属性 */
    protected static $_instance ;
    protected $_session ;
    protected $_started ;
    /* 方法 */
    private void __clone ( void )
    private __construct ( void )
    public void count ( void )
    public void current ( void )
    public void del ( string $name )
    public void __get ( string $name )
    public static void getInstance ( void )
    public void has ( string $name )
    public void __isset ( string $name )
    public void key ( void )
    public void next ( void )
    public void offsetExists ( string $name )
    public void offsetGet ( string $name )
    public void offsetSet ( string $name , string $value )
    public void offsetUnset ( string $name )
    public void rewind ( void )
    public void __set ( string $name , string $value )
    private void __sleep ( void )
    public void start ( void )
    public void __unset ( string $name )
    public void valid ( void )
    private void __wakeup ( void )
}
\end{lstlisting}

\section{Property}


\subsection{\$\_instance}


\subsection{\$\_session}


\subsection{\$\_started}


\section{Method}


\subsection{Yaf\_Session::\_\_clone()}




\begin{lstlisting}[language=PHP]
private void Yaf_Session::__clone ( void )
\end{lstlisting}

\subsection{Yaf\_Session::\_\_construct()}



\begin{lstlisting}[language=PHP]
private Yaf_Session::__construct ( void )
\end{lstlisting}



\subsection{Yaf\_Session::count()}



\begin{lstlisting}[language=PHP]
public void Yaf_Session::count ( void )
\end{lstlisting}


\subsection{Yaf\_Session::current()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::current ( void )
\end{lstlisting}


\subsection{Yaf\_Session::del(string \$name)}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::del ( string $name )
\end{lstlisting}



\begin{compactitem}
\item \$name
\end{compactitem}


\subsection{Yaf\_Session::\_\_get()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::__get ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}

\subsection{Yaf\_Session::getInstance()}


\begin{lstlisting}[language=PHP]
public static void Yaf_Session::getInstance ( void )
\end{lstlisting}

\subsection{Yaf\_Session::has()}



\begin{lstlisting}[language=PHP]
public void Yaf_Session::has ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}



\subsection{Yaf\_Session::\_\_isset()}



\begin{lstlisting}[language=PHP]
public void Yaf_Session::__isset ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}

\subsection{Yaf\_Session::key()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::key ( void )
\end{lstlisting}


\subsection{Yaf\_Session::next()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::next ( void )
\end{lstlisting}



\subsection{Yaf\_Session::offsetExists()}




\begin{lstlisting}[language=PHP]
public void Yaf_Session::offsetExists ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}

\subsection{Yaf\_Session::offsetGet()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::offsetGet ( string $name )
\end{lstlisting}


\begin{compactitem}
\item \$name
\end{compactitem}

\subsection{Yaf\_Session::offsetSet()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::offsetSet ( string $name , string $value )
\end{lstlisting}

\begin{compactitem}
\item \$name
\item \$value
\end{compactitem}


\subsection{Yaf\_Session::offsetUnset()}





\begin{lstlisting}[language=PHP]
public void Yaf_Session::offsetUnset ( string $name )
\end{lstlisting}

\begin{compactitem}
\item \$name
\end{compactitem}


\subsection{Yaf\_Session::rewind()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::rewind ( void )
\end{lstlisting}

\subsection{Yaf\_Session::\_\_set()}

\begin{lstlisting}[language=PHP]
public void Yaf_Session::__set ( string $name , string $value )
\end{lstlisting}

\begin{compactitem}
\item \$name
\item \$value
\end{compactitem}


\subsection{Yaf\_Session::\_\_sleep()}



\begin{lstlisting}[language=PHP]
private void Yaf_Session::__sleep ( void )
\end{lstlisting}


\subsection{Yaf\_Session::start()}


\begin{lstlisting}[language=PHP]
public void Yaf_Session::start ( void )
\end{lstlisting}

\subsection{Yaf\_Session::\_\_unset()}

\begin{lstlisting}[language=PHP]
public void Yaf_Session::__unset ( string $name )
\end{lstlisting}


\subsection{Yaf\_Session::valid()}

\begin{lstlisting}[language=PHP]
public void Yaf_Session::valid ( void )
\end{lstlisting}

\subsection{Yaf\_Session::\_\_wakeup()}



\begin{lstlisting}[language=PHP]
private void Yaf_Session::__wakeup ( void )
\end{lstlisting}




\chapter{Yaf\_Exception}

Yaf实现了一套错误和异常捕获机制，主要是对常见的错误处理和异常捕获方法做了一个简单抽象，方便应用组织自己的错误统一处理逻辑。

Yaf自身出错时候，根据配置可以分别采用抛出异常或者触发错误的方式来通知错误。

在appliation.dispatcher.throwException(配置文件, 或者通过Yaf\_Dispatcher::throwException(true))打开的情况下，Yaf会抛异常，否则则会触发错误，那么对应的就有两套错误处理方式可供应用选用。

在application.dispatcher.catchException(配置文件, 或者可通过Yaf\_Dispatcher::catchException(true))开启的情况下，当Yaf遇到未捕获异常的时候，就会把运行权限交给当前模块的Error Controller的Error Action动作，而异常可以作为请求的一个参数传递给Error Action。

在Error Action中可以通过\texttt{\$request->getRequest()->getParam("exception")}获取当前发生的异常。

另外，也可以通过\texttt{\$request->getException()}来获取当前发生的异常，而且如果Error Action定义了一个名为\texttt{\$exception}的参数的话，也可以直接通过这个参数获取当前发生的异常。




\begin{lstlisting}[language=PHP]
<?php
/**
 * 当有未捕获的异常, 则控制流会跳转到这里
 */
class ErrorController extends Yaf_Controller_Abstract {
    /**
     * 也可通过$request->getException()获取到发生的异常
     */
    public function errorAction($exception) {
        assert($exception === $exception->getCode());
        $this->getView()->assign("code", $exception->getCode());
        $this->getView()->assign("message", $exception->getMessage());
    }
}
\end{lstlisting}

通过最终的异常处理逻辑，Yaf应用就可以在出错的时候直接抛出异常，这样就可以在统一的异常处理逻辑中，根据各种不同的异常逻辑来处理错误和记录日志等。

下面是一个常用的Error Action：


\begin{lstlisting}[language=PHP]
<?php
/**
 * 当有未捕获的异常, 则控制流会跳转到这里
 */
class ErrorController extends Yaf_Controller_Abstract {
    /**
     * 也可通过$request->getException()获取到发生的异常
     */
    public function errorAction($exception) {
        switch ($exception->getCode()) {
            case YAF_ERR_LOADFAILD:
            case YAF_ERR_LOADFAILD_MODULE:
            case YAF_ERR_LOADFAILD_CONTROLLER:
            case YAF_ERR_LOADFAILD_ACTION:
                //404
                header("Not Found");
                break;

            case CUSTOM_ERROR_CODE:
                //自定义的异常
                //...
                break;
        }
    }
}
\end{lstlisting}

下面是一个更为易读的方式：



\begin{lstlisting}[language=PHP]
<?php
/**
 * 当有未捕获的异常, 则控制流会流到这里
 */
class ErrorController extends Yaf_Controller_Abstract {
    /**
     * 此时可通过$request->getException()获取到发生的异常
     */
    public function errorAction() {
        $exception = $this->getRequest()->getException();
        try {
            throw $exception;
        } catch (Yaf_Exception_LoadFailed $e) {
            //加载失败
        } catch (Yaf_Exception $e) {
            //其他错误
        }
    }
}
\end{lstlisting}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception extends Exception {
    /* 属性 */
    protected $message ;
    protected $code ;
    protected $previous ;
    /* 方法 */
    public __construct ( void )
    public void getPrevious ( void )
    /* 继承的方法 */
    final public string Exception::getMessage ( void )
    final public Exception Exception::getPrevious ( void )
    final public int Exception::getCode ( void )
    final public string Exception::getFile ( void )
    final public int Exception::getLine ( void )
    final public array Exception::getTrace ( void )
    final public string Exception::getTraceAsString ( void )
    public string Exception::__toString ( void )
    final private void Exception::__clone ( void )
}
\end{lstlisting}

\section{Property}


\subsection{\$message}


\subsection{\$code}


\subsection{\$file}


\subsection{\$line}


\subsection{\$previous}



\section{Method}


\subsection{Yaf\_Exception::\_\_construct()}





\begin{lstlisting}[language=PHP]
public Yaf_Exception::__construct ( void )
\end{lstlisting}



\subsection{Yaf\_Exception::getPrevious()}


\begin{lstlisting}[language=PHP]
public void Yaf_Exception::getPrevious ( void )
\end{lstlisting}

\chapter{Yaf\_Exception\_TypeError}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_TypeError extends Yaf_Exception {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}


\chapter{Yaf\_Exception\_StartupError}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_StartupError extends Yaf_Exception {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}


\chapter{Yaf\_Exception\_DispatchFailed}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_DispatchFailed extends Yaf_Exception {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_RouterFailed}


\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Exception_RouterFailed extends Yaf_Exception {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_LoadFailed}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_LoadFailed extends Yaf_Exception {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_LoadFailed\_Module}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_LoadFailed_Module extends Yaf_Exception_LoadFailed {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_LoadFailed\_Controller}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_LoadFailed_Controller extends Yaf_Exception_LoadFailed {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_LoadFailed\_Action}

\section{Synopsis}

\begin{lstlisting}[language=PHP]
Yaf_Exception_LoadFailed_Action extends Yaf_Exception_LoadFailed {
     /* 属性 */
     /* 方法 */
     /* 继承的方法 */
     public Yaf_Exception::__construct ( void )
     public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\chapter{Yaf\_Exception\_LoadFailed\_View}


\section{Synopsis}


\begin{lstlisting}[language=PHP]
Yaf_Exception_LoadFailed_View extends Yaf_Exception_LoadFailed {
    /* 属性 */
    /* 方法 */
    /* 继承的方法 */
    public Yaf_Exception::__construct ( void )
    public void Yaf_Exception::getPrevious ( void )
}
\end{lstlisting}

\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

