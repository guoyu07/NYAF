\part{JSON}

\chapter{Overview}

\chapter{JSON}


PHP的json扩展实现了对JSON（JavaScript Object Notation）的数据转换，其中解码分析器基于 Douglas Crockford 的 JSON\_checker。

PHP实现了JSON的RFC 7159标准中指定的JSON规范的超集。


JSON扩展是PHP核心的一部分，而且该扩展没有在 php.ini 中定义配置指令，也没有定义自己的资源类型。

JSON扩展引入了如下的预定义常量，并且仅在此扩展编译入 PHP 或在运行时动态载入时可用。



\begin{longtable}{|m{130pt}|m{20pt}|m{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
常量名字&常量值&说明
\endhead
%endhead

%firsthead
\caption{json\_last\_error()返回的错误类型}\\
\hline
常量名字&常量值&说明
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
JSON\_ERROR\_NONE (integer)&0&没有错误发生。\\
\hline
JSON\_ERROR\_DEPTH (integer)&1&到达了最大堆栈深度。\\
\hline
JSON\_ERROR\_STATE\_MISMATCH (integer)&2&出现了下溢（underflow）或者模式不匹配。\\
\hline
JSON\_ERROR\_CTRL\_CHAR (integer)&3&控制字符错误，可能是编码不对。\\
\hline
JSON\_ERROR\_SYNTAX (integer)&4&语法错误。\\
\hline
JSON\_ERROR\_UTF8 (integer)&5&异常的 UTF-8 字符，也许是因为不正确的编码。\\
\hline
JSON\_ERROR\_RECURSION (integer)&6&The object or array passed to json\_encode() include recursive references and cannot be encoded. If the JSON\_PARTIAL\_OUTPUT\_ON\_ERROR option was given, NULL will be encoded in the place of the recursive reference.\\
\hline
JSON\_ERROR\_INF\_OR\_NAN (integer)&7&The value passed to json\_encode() includes either NAN or INF. If the JSON\_PARTIAL\_OUTPUT\_ON\_ERROR option was given, 0 will be encoded in the place of these special numbers.\\
\hline
JSON\_ERROR\_UNSUPPORTED\_TYPE (integer)&8&A value of an unsupported type was given to json\_encode(), such as a resource. If the JSON\_PARTIAL\_OUTPUT\_ON\_ERROR option was given, NULL will be encoded in the place of the unsupported value.\\
JSON\_ERROR\_INVALID\_PROPERTY\_NAME&9&\\
\hline
JSON\_ERROR\_UTF16&19&\\
\hline
\end{longtable}



\begin{longtable}{|m{130pt}|m{20pt}|m{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
常量名字&常量值&说明
\endhead
%endhead

%firsthead
\caption{ json\_encode() 的 form 选项常量}\\
\hline
常量名字&常量值&说明
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
JSON\_HEX\_TAG (integer)				&1	&所有的 < 和 > 转换成 \textbackslash u003C 和 \textbackslash u003E。\\
\hline
JSON\_HEX\_AMP (integer)				&2	所有的 \& 转换成 \textbackslash u0026。 \\
\hline
JSON\_HEX\_APOS (integer)				&4	&所有的\texttt{'}转换成 \textbackslash u0027。\\
\hline
JSON\_HEX\_QUOT (integer)			&8	&所有的\texttt{"}转换成 \textbackslash u0022。\\
\hline
JSON\_FORCE\_OBJECT (integer)		&16	&使一个非关联数组输出一个类（Object）而非数组。 在数组为空而接受者需要一个类（Object）的时候尤其有用。 \\
\hline
JSON\_NUMERIC\_CHECK (integer)		&32	&将所有数字字符串编码成数字（numbers）。\\
\hline
JSON\_UNESCAPED\_SLASHES (integer)	&64	&不要编码 /。\\
\hline
JSON\_PRETTY\_PRINT (integer)			&128&用空白字符格式化返回的数据。 \\
\hline
JSON\_UNESCAPED\_UNICODE (integer)	&256&以字面编码多字节 Unicode 字符（默认是编码成 \textbackslash uXXXX）。 \\
\hline
JSON\_PARTIAL\_OUTPUT\_ON\_ERROR (integer)	&512&\\
\hline
JSON\_PRESERVE\_ZERO\_FRACTION (integer)		&1024&\\
\hline
JSON\_BIGINT\_AS\_STRING (integer)		&2	&将大数字编码成原始字符原来的值。\\
\hline
\end{longtable}


\section{json\_decode()}

对 JSON 格式的字符串进行解码

\section{json\_encode()}

对变量进行 JSON 编码

\section{json\_last\_error\_msg()}

Returns the error string of the last json\_encode() or json\_decode() call

\section{json\_last\_error()}

返回最后发生的错误

\chapter{JSONP}

JSONP将JSON数据包装在一个回调函数中。

\begin{lstlisting}[language=PHP]
callback({/*.. JSON data .. */});
\end{lstlisting}

具体来说，JSONP（JSON with Padding）是JSON的一种“使用模式”，可以让网页从别的网域请求数据，另一个解决这个问题的新方法是跨来源资源共享。


由于浏览器的同源策略的限制，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而HTML的 <script>元素是一个例外。

利用 <script>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。

为了理解这种模式的原理，首先想象有一个回传JSON文件的URL，而JavaScript 程序可以用XMLHttpRequest向这个URL请求数据。假设我们的URL是\url{http://server2.example.com/RetrieveUser?UserId=xxx}，如果UserId 是1823，且当浏览器通过URL传输UserId，也就是抓取\url{http://server2.example.com/RetrieveUser?UserId=1823}，得到：

\begin{lstlisting}[language=PHP]
{"Name": "小明", "Id" : 1823, "Rank": 7}
\end{lstlisting}

上述这个JSON数据可能是依据传过去URL的查询参数动态产生的。

这个时候，把 <script>元素的src属性设成一个回传JSON的URL是可以想像的，这也代表从HTML页面通过script元素抓取 JSON是可能的。

然而，一份JSON文件并不是一个JavaScript程序。为了让浏览器可以在 <script>元素运行，从src里URL 回传的必须是可运行的JavaScript。在JSONP的使用模式里，该URL回传的是由函数调用包起来的动态生成JSON，这就是JSONP的“填充（padding）”或是“前辍（prefix）”的由来。

惯例上浏览器提供回调函数的名称当作送至服务器的请求中命名查询参数的一部分，例如：

\begin{lstlisting}[language=HTML]
<script type="text/javascript" src="http://server2.example.com/RetrieveUser?UserId=1823&jsonp=parseResponse">
</script>
\end{lstlisting}

服务器会在传给浏览器前将JSON数据填充到回调函数（parseResponse）中。浏览器得到的回应已不是单纯的数据叙述而是一个脚本。在本例中，浏览器得到的是：

\begin{lstlisting}[language=JavaScript]
parseResponse({"Name": "小明", "Id" : 1823, "Rank": 7})
\end{lstlisting}

虽然这个填充（前辍）“通常”是浏览器运行背景中定义的某个回调函数，它也可以是变量赋值、if叙述或者是其他JavaScript叙述。JSONP要求（也就是使用JSONP模式的请求）的回应不是JSON也不被当作JSON解析——回传内容可以是任意的表达式，甚至不需要有任何的JSON，不过惯例上填充部分还是会触发函数调用的一小段JavaScript片段，而这个函数调用是作用在JSON格式的数据上的。


另一种说法—典型的JSONP就是把既有的JSON API用函数调用包起来以达到跨域访问的解决方案。

为了要引导一个JSONP调用（或者说，使用这个模式），你需要一个script 元素。因此，浏览器必须为每一个JSONP要求加（或是重用）一个新的、有所需 src值的 <script>元素到HTML DOM里—或者说是“注入”这个元素。浏览器运行该元素，抓取src里的URL，并运行回传的 JavaScript。


上述的原理使得JSONP被称作是一种“让用户利用script元素注入的方式绕开同源策略”的方法。

使用远程网站的script标签会让远程网站得以注入任何的内容至网站里。如果远程的网站有JavaScript注入漏洞，原来的网站也会受到影响。


现在有一个正在进行项目在定义所谓的JSON-P严格安全子集，使浏览器可以对MIME类别是“application/json-p”请求做强制处理。如果回应不能被解析为严格的JSON-P，浏览器可以丢出一个错误或忽略整个回应。

粗糙的JSONP部署很容易受到跨站请求伪造（CSRF/XSRF）的攻击。因为HTML <script>标签在浏览器里不遵守同源策略，恶意网页可以要求并获取属于其他网站的JSON数据。当用户正登录那个其他网站时，上述状况使得该恶意网站得以在恶意网站的环境下操作该JSON数据，可能泄漏用户的密码或是其他敏感数据。

只有在该JSON数据含有不该泄漏给第三方的隐密数据，且服务器仅靠浏览器的同源策略阻挡不正常要求的时候这才会是问题。若服务器自己决定要求的专有性，并只在要求正常的情况下输出数据则没有问题。只靠Cookie并不足以决定要求是合法的，这很容易受到跨站请求伪造攻击。

乔治·詹姆提（George Jempty）在2005年夏天建议在JSON前面选择性的加上变量赋值，鲍勃·伊波利托（Bob Ippolito）于2005年12月提出了JSONP最原始的提案，其中填充部分已经是回调函数，现在已经有很多Web 2.0应用程序开始使用JSONP提案，例如Dojo Toolkit、Google Web Toolki与Web服务等。

\begin{lstlisting}[language=PHP]
<?php
header("content-type: text/javascript");

if(isset($_GET['name']) && isset($_GET['callback'])) {
    $obj->name = $_GET['name'];
    $obj->message = "Hello " . $obj->name;

    echo $_GET['callback']. '(' . json_encode($obj) . ');';
}
\end{lstlisting}

下面的示例说明如何使用jQuery来请求JSONP数据：


\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>JQuery JSONP</title>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js"></script>
    <script>
    $(document).ready(function(){
 
        $("#useJSONP").click(function(){
            $.ajax({
                url: 'http://domain.com/jsonp-demo.php',
                data: {name: 'Chad'},
                dataType: 'jsonp',
                jsonp: 'callback',
                jsonpCallback: 'jsonpCallback',
                success: function(){
                    alert("success");
                }
            });
        });
 
    });
     
    function jsonpCallback(data){
        $('#jsonpResult').text(data.message);
    }
    </script>
  </head> 
  
  <body>
    <input type="button" id="useJSONP" value="Use JSONP"></input><br /><br />
    <span id="jsonpResult"></span>
  </body>
</html>
\end{lstlisting}

为了使用jQuery发送JSONP数据，需要设置dataType为jsonp，并且为jsonp设置回调函数，因此请求JSONP数据的的URL类似于\url{http://domain.com/jsonp-demo.php?callback=jsonpCallback\&name=Chad}。

对应的对PHP的请求产生的结果如下：



\begin{lstlisting}[language=PHP]
jsonpCallback({"name":"Chad","message":"Hello Chad"});
\end{lstlisting}

为了严格防止跨站请求伪造攻击，需要在PHP返回的结果的返回头中设置：


\begin{lstlisting}[language=PHP]
header("content-type: Access-Control-Allow-Origin: *");
header("content-type: Access-Control-Allow-Methods: GET");
\end{lstlisting}

如果使用托管服务或不能完全控制服务器端逻辑，可能服务器主机会阻止JSONP请求，因此需要在Web服务器（例如Apache）进行如下配置 ：

\begin{lstlisting}[language=PHP]
Header set Access-Control-Allow-Origin "mydomain.com"
\end{lstlisting}

除了可以使用字符串函数移除JSON数据包头之外，也可以定义jsonp\_decode()和jsonp\_encode()来处理JSONP。

\section{jsonp\_decode()}

\begin{lstlisting}[language=PHP]
/**
 * Decodes a JSONP string and falls back to JSON decoding in case
 * the value passed is not JSONP.
 * 
 * Provides the same interface as the built-in json_decode function
 *
 * @param string $jsonp
 * @param bool $assoc
 *
 * @return mixed
 */
function jsonp_decode($jsonp, $assoc = false) { 
    // PHP 5.3 adds depth as third parameter to json_decode
    $jsonLiterals = array('true' => 1, 'false' => 1, 'null');
    if(preg_match('/^[^[{"\d]/', $jsonp) && !isset($jsonLiterals[$jsonp])) { // we have JSONP
       $jsonp = substr($jsonp, strpos($jsonp, '('));
    }
    return json_decode(trim($jsonp,'();'), $assoc);
}
\end{lstlisting}


\section{jsonp\_encode()}

\begin{lstlisting}[language=PHP]
/**
 * Encodes the value as JSONP with the given function name.
 *
 * @param mixed $value
 * @param string $function_name
 *
 * @return string
 */
function jsonp_encode($value, $function_name = 'cb') { 
    // 5.3 adds options as second parameter to json_encode
    return sprintf('%s(%s);', $function_name, json_encode($value));;
}
\end{lstlisting}


\chapter{JSONSerializable}


实现 JsonSerializable 的类可以 在 json\_encode() 时定制自己的 JSON 表示法。

\begin{lstlisting}[language=PHP]
JsonSerializable {
    /* 方法 */
    abstract public mixed jsonSerialize ( void )
}
\end{lstlisting}

\section{JSONSerializable::jsonSerialize()}

指定需要被序列化成 JSON 的数据


\begin{lstlisting}[language=PHP]
abstract public mixed JsonSerializable::jsonSerialize ( void )
\end{lstlisting}

把对象（Object）序列化成能被 json\_encode() 原生地序列化的值，因此返回值是能被 json\_encode() 序列化的数据， 这个值可以是除了 resource 外的任意类型。

\begin{example}
使用JSONSerializable::jsonSerialize()返回数组
\begin{lstlisting}[language=PHP]
<?php
class ArrayValue implements JsonSerializable {
    public function __construct(array $array) {
        $this->array = $array;
    }

    public function jsonSerialize() {
        return $this->array;
    }
}

$array = [1, 2, 3];
echo json_encode(new ArrayValue($array), JSON_PRETTY_PRINT);
// 以上例程会输出：
[
    1,
    2,
    3
]
\end{lstlisting}
\end{example}


\begin{example}
使用JSONSerializable::jsonSerialize()返回关联数组
\begin{lstlisting}[language=PHP]
<?php
class ArrayValue implements JsonSerializable {
    public function __construct(array $array) {
        $this->array = $array;
    }

    public function jsonSerialize() {
        return $this->array;
    }
}

$array = ['foo' => 'bar', 'quux' => 'baz'];
echo json_encode(new ArrayValue($array), JSON_PRETTY_PRINT);
// 以上例程会输出：
{
    "foo": "bar",
    "quux": "baz"
}
\end{lstlisting}
\end{example}


\begin{example}
使用JSONSerializable::jsonSerialize()返回整型值
\begin{lstlisting}[language=PHP]
<?php
class IntegerValue implements JsonSerializable {
    public function __construct($number) {
        $this->number = (integer) $number;
    }

    public function jsonSerialize() {
        return $this->number;
    }
}

echo json_encode(new IntegerValue(1), JSON_PRETTY_PRINT);
// 以上例程会输出：
1
\end{lstlisting}
\end{example}




\begin{example}
使用JSONSerializable::jsonSerialize()返回字符串值
\begin{lstlisting}[language=PHP]
<?php
class StringValue implements JsonSerializable {
    public function __construct($string) {
        $this->string = (string) $string;
    }

    public function jsonSerialize() {
        return $this->string;
    }
}

echo json_encode(new StringValue('Hello!'), JSON_PRETTY_PRINT);
// 以上例程会输出：
"Hello!"
\end{lstlisting}
\end{example}




\chapter{JSON API}

JSON API 来自 JSON 的数据传输，它被隐式地定义在 Ember 的 REST 风格数据适配器。

一般来说，Ember Data 被设计用来实现这样的目的：消除哪些为不同应用程序与服务器之间通信而写的特殊代码， 而是用 REST 风格数据适配器将它们转换成统一的方式。

一些服务器，比如 Firebase、Parse 和 CouchDB 已经定义了和客户端通信的精确的协议，以便适合 Ember 数据。 相比之下，用 Rails、Node.js、 Django 编写的服务器端程序，倾向于使用 REST 风格， 但对于客户端程序，却没有多少是使用 REST 风格的。

Ember Data 的 REST Adapter 隐式定义了一个协议， 服务器需要实现此协议，用来为客户端程序提供有所的资源。 ActiveModel::Serializers 是 Rails 的一个库，并实现了 Ember Data 所期望的序列化格式。

Ember Data 关于记录的创建、更新和删除， 已经成为 Rails、Django 和 Node.js 开发者广泛使用的约定。

媒体类型的目标是追求均衡:

\begin{compactitem}
\item 一个通用的媒体类型，可以在非常广泛的场景中使用，包括常用的关系类型
\item 对现有服务器端框架最佳实践类似（可读性与可调试性）
\item 易于在服务器端实现
\item 易于在客户端实现
\end{compactitem}

该类媒体仍然是一个进展中的工作，我们是非常开放的反馈和建议改进。 就是说，该规范的实现工作已经开始，我们的价值在于提供更好的雾件（vaporware）。



通过遵循共同的约定，可以提高开发效率，利用更普遍的工具，可以是你更加专注于开发重点：你的程序。

基于 JSON API 的客户端还能够充分利用缓存，以提升性能，有时甚至可以完全不需要网络请求。

下面是一个使用 JSON API 发送响应（response）的示例：


\begin{lstlisting}[language=bash]
{
  "links": {
    "posts.author": {
      "href": "http://example.com/people/{posts.author}",
      "type": "people"
    },
    "posts.comments": {
      "href": "http://example.com/comments/{posts.comments}",
      "type": "comments"
    }
  },
  "posts": [{
    "id": "1",
    "title": "Rails is Omakase",
    "links": {
      "author": "9",
      "comments": [ "5", "12", "17", "20" ]
    }
  }]
}
\end{lstlisting}


顶级的 "links" 部分是可选的。 除去 "links" 部分，此响应看起来非常接近使用已经存在的 API 构建的响应。

JSON API 不仅可以用来构建响应，还包括创建和更新资源。

如果你想扩展 JSON API，你应该遵循 RFC 6906 定义的 profile。meta 部分定义了 profile 的链接。

在 RFC 规范中，profile：

\begin{quote}
不改变资源表示的语义定义本身，但让客户了解更多的语义(约束、规范、扩展)相关联的资源表示形式， 还有这些定义的媒体类型和可能的其他机制。
\end{quote}


例如，假设你想让你的 API 支持不同的分页设计，如基于游标。 你会制作某种信息页面在你的网站上，如 http://api.example.com/profile， 然后会响应中包含 meta 键:

\begin{lstlisting}[language=JavaScript]
GET http://api.example.com/
\end{lstlisting}


\begin{lstlisting}[language=JavaScript]
{
  "meta": {
    "profile": "http://api.example.com/profile"
  },

  "posts": [{
    // 一份单独的文档
  }]
}
\end{lstlisting}

That document will de-reference to explain your link relations:


这份文档将解释链接之间的关系:


\begin{lstlisting}[language=JavaScript]
GET http://api.example.com/profile HTTP/1.1
\end{lstlisting}


\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: text/plain
\end{lstlisting}

Example.com API 使用基于游标的分页。 它是这样工作的: 在想要的 meta 部分，它将返回一个 cursors 的关系（relation）, 其中包括 after，before 和 limit，用来描述该游标。 您可以使用 href 给出的 URI 模板来生成分页的 URIs。

\begin{lstlisting}[language=JavaScript]
"meta": {
  "cursors": {
    "after": "abcd1234",
    "before": "wxyz0987",
    "limit": 25,
    "href": "https://api.example.com/whatever{?after,before,limit}"
  }
}
\end{lstlisting}

\section{HAL}

一旦 JSON API 发布稳定版，它将保持向后兼容，它将遵守永不删除，只是添加的开发策略。

\textbf{为什么不使用 HAL 规范？}

不使用HAL规范的原因如下：

\begin{compactitem}
\item HAL 递归嵌套子文档，而 JSON API 在顶层采用扁平化对象结构。意味着不同的对象引用相同的 “people”（例如，posts和comments的author）时，这种规范能够保证每个person document仅存在一个有效实例。

\item 相似的，JSON API使用IDs做链接，使从复合响应中缓存文档成为可能，仅当本地不存在对应文档，才会发出后续请求。如果幸运，甚至可以完全无需HTTP请求。

\item HAL是序列化格式，但完全未定义文档更新操作。JSON API则仔细考虑如何更新已存在文档（依赖PATCH和JSON PATCH），以及更新操作与GET请求返回复合文档交互方式。同时定义如何创建，删除文档，以及更新操作的200,204响应。
\end{compactitem}

简单来说，JSON API尝试格式化相似的，特殊的client-server通讯接口，使用JSON作为数据交换格式。专注于使用成熟的客户端来调用相关API，客户端能够缓存已经获取到的文档，避免再次请求已缓存信息。

JSON API从大量实际项目所使用的库中抽象而出。同时定义请求/响应（HAL未定义），以及对应数据交互格式。

\textbf{如何获取资源可能的行为？}

你应该使用OPTIONS HTTP方法来获取当前特定资源的行为。OPTIONS请求返回方法的语义遵循JSON API标准。

举例来说，如果"GET,POST"是URL OPTIONS请求的响应，那么就可以获取该资源信息，以及创建新资源。

如果你想知道特定资源属性作用，你不得不使用应用级别的描述来定义属性的含义与功能，并使用错误响应通知用户。这个特性依旧在讨论中，尚未加入最终标准。

\textbf{有没有JSON 规范来定义JSON API?}

当然，你可以在http://jsonapi.org/schema找到JSON规范定义。注意这个规范并不完美。 因为JSON文档可能会通过规范检查，但并不意味着是合适的JSON API文档。规范只是为了常规性排错检查。

可以在http://json-schema.org找到更多关于JSON 规范格式的信息。

\textbf{为什么资源集合作为数组返回，而不是ID索引集合？}

JSON数组是自然排序，而集合需要元数据进行成员排序。因此，默认情况下，数组能够实现更自然的排序或者特殊方式排序。

除此之外，JSON API 允许返回不包含IDs的只读资源，与IDs索引集合方式不兼容。

\textbf{为什么关联资源嵌套在复合文档的 linked 对象中？}

主要资源应该相互独立，因为他们的顺序和数量通常比较重要。通过多种方式，分离主要资源和关联资源是必要的，因为主要资源可能会有相同类型的关联资源（e.g. the "parents" of a "person")。关联资源嵌套在 linked 中能够防止可能的冲突。



\section{MIME}


JSON API 已经在 IANA 机构完成注册。 它的 MIME 类型是 application/vnd.api+json。


\section{Format}

JSON API 是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求。

JSON API设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性。

JSON API需要使用JSON API媒体类型(application/vnd.api+json) 进行数据交互。

JSON API服务器支持通过GET方法获取资源。而且必须独立实现HTTP POST, PUT和DELETE方法的请求响应，以支持资源的创建、更新和删除。

JSON API服务器也可以选择性支持HTTP PATCH方法 [RFC5789]和JSON Patch格式 [RFC6902]，进行资源修改。JSON Patch支持是可行的，因为理论上来说，JSON API通过单一JSON 文档，反映域下的所有资源，并将JSON文档作为资源操作介质。在文档顶层，依据资源类型分组。每个资源都通过文档下的唯一路径辨识。

\subsection{Rule}

文档中的关键字， "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" 依据RFC 2119 [RFC2119]规范解释。

\section{Client}

客户端必须在包含Content-Type: application/vnd.api+json头并且不包含媒体类型参数的请求文档中发送所有JSON API数据。

在Accept头中包含JSON API媒体类型并且不包含媒体类型参数的客户端必须在Accept头中指定媒体类型至少一次。

客户端必须忽略任何从响应文档的Content-Type头中获取的application/vnd.api+json媒体类型参数。

\section{Server}

服务器必须在包含Content-Type: application/vnd.api+json头并且不包含媒体类型参数的请求文档中发送所有JSON API数据。

如果接收到一个用任何媒体类型参数指定Content-Type: application/vnd.api+json头的请求，服务器必须返回一个415 Unsupported Media Type状态码响应。

如果接收到一个在Accept头中包含任何JSON API媒体类型并且所有实体都以媒体类型参数更改的请求，服务器必须返回一个406 Not Acceptable状态码响应。

\section{Docment}


JSON API文档结构，通过媒体类型application/vnd.api+json标示。JSON API文档使用javascript 对象（JSON）[RFC4627]定义。

尽管同种媒体类型用以请求和响应文档，但某些特性只适用于其中一种。差异在下面呈现。

除非另有说明，根据本规范定义的对象都不应该包含任何其他键。客户端和服务器实现必须忽略本规范未指定的键。

\subsection{Top Level}

JSON 对象必须位于每个JSON API文档的根级。这个对象定义文档的“top level”。

文档必须包含以下至少一种top-level键：


\begin{compactitem}
\item data: 文档的”primary data”.
\item errors: 错误对象列表.
\item meta: 包含非标准元信息的元对象.
\end{compactitem}

data键和errors键不能再一个文档中同时存在。

文档可能包含以下任何top-level键：

\begin{compactitem}
\item jsonapi: 描述服务器实现的对象.
\item links: 与primary data相关的链接对象.
\item include: 与primary data或其他资源相关的资源对象("included resources")列表.
\end{compactitem}

如果文档不包含top-level data键，included键也不应该出现。

文档的top-level 链接对象可能包含以下键：


\begin{compactitem}
\item self: 生成当前响应文档的链接.
\item related: 当primary data代表资源关系时，表示相关资源链接.
\item Primary data的分页链接.
\end{compactitem}

文档中的“primary data”代表一个请求所要求的资源或资源集合。

Primary data 必须是以下列举的一种：

\begin{compactitem}
\item 如果请求要求单一资源，应该是一个单一资源对象，或一个单一资源标识符，或null.
\item 如果请求要求资源集合，应该是一个资源对象列表，或一个空列表([]).
\end{compactitem}

例如，以下primary data表示一个单一资源对象：

\begin{lstlisting}[language=JavaScript]
{
  "data": {
    "type": "articles",
    "id": "1",
    "attributes": {
      // ... this article's attributes
    },
    "relationships": {
      // ... this article's relationships
    }
  }
}
\end{lstlisting}

以下primary data表示一个指向同样资源的单一资源标识符:

\begin{lstlisting}[language=JavaScript]
{
  "data": {
    "type": "articles",
    "id": "1"
  }
}
\end{lstlisting}


即使只包含一个元素或为空，资源的一个逻辑集合也必须表示为一个列表。


\subsection{Resource Object}

JSON API 文档中的"Resuorce objects"代表资源。

一个资源对象必须至少包含以下top-level键：

\begin{compactitem}
\item id
\item type
\end{compactitem}

例外：当资源对象来自客户端并且代表一个将要在服务器创建的新资源时，id键不是必须的。

此外，资源对象可能包含以下top-level键：

\begin{compactitem}
\item attribute: 属性对象代表资源的某些数据.
\item relationshiops: 关联对象描述该资源与其他JSON API资源之间的关系.
\item links: 链接资源包含与资源相关的链接.
\item meta: 元数据资源包含与资源对象相关的非标准元信息，这些信息不能被作为属性或关联对象表示.
\end{compactitem}

一篇文献(即一个"文献"类型的资源)在文档中这样表示:



\begin{lstlisting}[language=JavaScript]
// ...
{
  "type": "articles",
  "id": "1",
  "attributes": {
    "title": "Rails is Omakase"
  },
  "relationships": {
    "author": {
      "links": {
        "self": "/articles/1/relationships/author",
        "related": "/articles/1/author"
      },
      "data": { "type": "people", "id": "9" }
    }
  }
}
// ...
\end{lstlisting}


\subsection{Identifiers}

每个资源对象包含一个id键和一个type键。id键和type键的值必须是字符串类型。

对于每一个既定API，每个资源对象的type和id对必须定义一个单独且唯一的资源。(由一个或多个但行为表现为一个服务器的服务器控制的URI集合构成一个API。)

type键用于描述共享相同属性和关联的资源对象。

type键的值必须与遵循键名称相同的约束条件。

\subsection{Fields}


资源对象的属性和关联被统称为"fields"。

一个资源对象的所有字段必须与type和id在同一命名空间中。即一个资源不能拥有名字相同的属性与关联，也不能拥有被命名为type或id的属性和关联。


\subsection{Property}

attribute键的值必须是一个对象(一个"attributes object")。属性对象的键("attributes")代表与资源对象中定义的与其有关的信息。

属性可以包含任何合法JSON值。

JSON对象和列表涉及的复杂数据结构可以作为属性的值。但是一个组成或被包含于属性中的对象不能包含relationships或links键，因为这些键为此规范未来的用途所预留。

虽然一些has-one关系的外键(例如author_id)被在内部与其他将要在资源对象中表达的信息一起储存，但是这些键不能作为属性出现。

\subsection{Relationship}

relationships键的值必须是一个对象("relationships object")。

关联对象("relationships")的键表示在资源对象中定义的与其相关的其他资源对象。

关联可以是单对象关联或多对象关联。

一个"relationship object"必须包含以下至少一种键：

\begin{compactitem}
\item links: 一个链接对象至少包含以下一种键：

\begin{compactenum}
\item self: 指向关联本身的链接("relationship link")。此链接允许客户端直接修改关联。例如，通过一个articale的关联URL移除一个author将会解除一个人与article的关系而不需要删除这个people资源本身。获取成功后，这个链接将返回一个相关资源之间的连接，将其作为primary data。(见 获取关联).
\item related: 相关资源链接.
\end{compactenum}

\item data: 资源连接.
\item meta: 包含关于此关联的非标准元信息的元对象.
\end{compactitem}

一个代表多对象关联的关联对象可能在links键下也包含分页链接，如后文描述。

\subsection{Related Resource Link}

"related resource link"提供 关联中链接的资源对象的权限。当获取成功后，相关资源对象将作为响应的primary data返回。

例如，通过一个GET请求检索时，一篇article的comments关联可以指定一个返回评论集合资源对象的链接。

当一个相关资源链接出现时，它必须指向一个合法URL， 即使关联当前不予任何目标资源相关。此外，一个相关资源链接不能因为它的关联内容更改而更改。



\subsection{Resource Link}

复合文档中的资源连接允许客户端将所有包含的资源对象链接在一起，而不需要通过链接GET任何URL。

资源连接必须通过以下一种形式表述：

\begin{compactitem}
\item 空的单对象关联用null表示.
\item 空的多对象关联用一个空列表([])表示.
\item 非空单对象关联用一个资源标识符对象表示.
\item 非空多对象关联用一个资源标识符对象列表表示.
\end{compactitem}

例如，以下文献与author相关：

\begin{lstlisting}[language=JavaScript]
// ...
{
  "type": "articles",
  "id": "1",
  "attributes": {
    "title": "Rails is Omakase"
  },
  "relationships": {
    "author": {
      "links": {
        "self": "http://example.com/articles/1/relationships/author",
        "related": "http://example.com/articles/1/author"
      },
      "data": { "type": "people", "id": "9" }
    }
  },
  "links": {
    "self": "http://example.com/articles/1"
  }
}
// ...
\end{lstlisting}


author关联包含一个指向关联本身的链接(这允许客户端直接更改相关作者)、一个用于获取资源对象的相关资源链接和一个连接信息。

资源对象中的可选的links键包含与资源相关的链接。

当链接对象存在时，它可能包含指向定义了资源对象所表示的资源的self链接。


\begin{lstlisting}[language=JavaScript]
// ...
{
  "type": "articles",
  "id": "1",
  "attributes": {
    "title": "Rails is Omakase"
  },
  "links": {
    "self": "http://example.com/articles/1"
  }
}
// ...
\end{lstlisting}


服务器收到一个特定URL的GET请求后，必须回复将此资源作为promary data的响应。


\section{Resource Identifier Object}

“resource identifier object”是一个定义单独资源的对象。

“resource identifier object”必须包含type和id键。

“resource identifier object”也可能包含meta键，它的值是包含非标准元信息的meta对象。



\subsection{Compound Documents}

为了减少HTTP请求的数量，服务器可能允许包含相关资源与所请求的主要资源的响应。这种响应被称作"compound documents"。

在复合文档中，所有包含的资源必须以一个top-level中的included键中的资源对象列表表示。

复合文档要求 “full linkage”，这意味着所有包含其中的资源必须至少被一个在同一文档中的资源标识符对象定义。这些资源标识符对象可以是primary data或与主要或相关资源包含在一起的资源连接。

全连接要求唯一的例外是当包含连接数据的关联字段被通过稀疏字段集合排除时。

一个含有多个包含关联的复杂示例文档如下所示:



\begin{lstlisting}[language=JavaScript]
{
  "data": [{
    "type": "articles",
    "id": "1",
    "attributes": {
      "title": "JSON API paints my bikeshed!"
    },
    "links": {
      "self": "http://example.com/articles/1"
    },
    "relationships": {
      "author": {
        "links": {
          "self": "http://example.com/articles/1/relationships/author",
          "related": "http://example.com/articles/1/author"
        },
        "data": { "type": "people", "id": "9" }
      },
      "comments": {
        "links": {
          "self": "http://example.com/articles/1/relationships/comments",
          "related": "http://example.com/articles/1/comments"
        },
        "data": [
          { "type": "comments", "id": "5" },
          { "type": "comments", "id": "12" }
        ]
      }
    }
  }],
  "included": [{
    "type": "people",
    "id": "9",
    "attributes": {
      "first-name": "Dan",
      "last-name": "Gebhardt",
      "twitter": "dgeb"
    },
    "links": {
      "self": "http://example.com/people/9"
    }
  }, {
    "type": "comments",
    "id": "5",
    "attributes": {
      "body": "First!"
    },
    "relationships": {
      "author": {
        "data": { "type": "people", "id": "2" }
      }
    },
    "links": {
      "self": "http://example.com/comments/5"
    }
  }, {
    "type": "comments",
    "id": "12",
    "attributes": {
      "body": "I like XML better"
    },
    "relationships": {
      "author": {
        "data": { "type": "people", "id": "9" }
      }
    },
    "links": {
      "self": "http://example.com/comments/12"
    }
  }]
}
\end{lstlisting}


对于每个typy和id对，一个复合文档不能包含超过一个资源对象。


\subsection{Meta Information}


在指定位置，meta键可用于包含非标准元信息。每个meta键的值必须是一个对象("meta object")。

任何键都可以包含在meta对象中。

例如:


\begin{lstlisting}[language=JavaScript]
{
  "meta": {
    "copyright": "Copyright 2015 Example Corp.",
    "authors": [
      "Yehuda Katz",
      "Steve Klabnik",
      "Dan Gebhardt",
      "Tyler Kellen"
    ]
  },
  "data": {
    // ...
  }
}
\end{lstlisting}


\subsection{Links Object}

在指定位置，links键可用于表示链接。每个links键的值必须是一个对象("links object")。

每个链接对象的键是一个"link"。一个链接必须是以下形其中之一：

\begin{compactitem}
\item 一个包含链接的URL的字符串.
\item 一个可以包含以下键的对象("link object"):

\begin{compactenum}
\item href: 一个包含此链接URL的字符串
\item meta: 包含与此链接相关非标准元信息的元对象.
\end{compactenum}
\end{compactitem}

以下self链接是一个简单的URL:


\begin{lstlisting}[language=JavaScript]
"links": {
  "self": "http://example.com/posts"
}
\end{lstlisting}

以下related链接包含一个URL和与资源集合相关的元信息：

\begin{lstlisting}[language=JavaScript]
"links": {
  "related": {
    "href": "http://example.com/articles/1/comments",
    "meta": {
      "count": 10
    }
  }
}
\end{lstlisting}


\section{JSON API Object}

一个JSON API文档可能在top level jsonapi键下包含与其实现相关的信息。如果它出现，jsonapi键的值必须是一个对象("jsonapi object")。jsonapi对象可能包含version键，其值是一个表明被支持的最高JSON API版本的字符串。此对象也可能包含一个meta键，其值是一个包含非标准元信息的meta对象。

\begin{lstlisting}[language=JavaScript]
{
  "jsonapi": {
    "version": "1.0"
  }
}
\end{lstlisting}


如果version键未出现，客户端则假设服务器是遵循此规范最新版本1.0。

\subsection{Key Name}

一个JSON API文档中使用的键名称对于客户端和服务器来说必须是大小写敏感的，并且必须满足以下规则：

\begin{compactitem}
\item 键名称必须包含至少一个字符.
\item 键名称必须只包含以下列举的合法字符.
\item 键名称必须以以下定义的“globally allowed character”开始和结束.
\end{compactitem}

为了确保键名称能便利地映射到URL，推荐使用RFC 3986中指定的非保留URL安全字符。

\subsection{Valid Character}

以下“globally allowed characters”可以被用于键名称中:

\begin{compactitem}
\item U+0061 to U+007A, “a-z”
\item U+0041 to U+005A, “A-Z”
\item U+0030 to U+0039, “0-9”
\item U+0080 and above (非ASCII Unicode 字符; 非URL安全字符，不推荐)
\end{compactitem}

此外，以下字符也在键名称中也是合法的，只是不能出现在首位或末位:

\begin{compactitem}
\item U+002D HYPHEN-MINUS, “-“
\item U+005F LOW LINE, “\_”
\item U+0020 SPACE, “ “ (非URL安全字符，不推荐)
\end{compactitem}


\subsection{Reserved characters}

以下字符不能被用于键名称中:

\begin{compactitem}
\item U+002B PLUS SIGN, “+” (用于排序)
\item U+002C COMMA, “,” (用于关联路径的分隔符)
\item U+002E PERIOD, “.” (用于关联路径中的分隔符)
\item U+005B LEFT SQUARE BRACKET, “[” (用于稀疏字段集合)
\item U+005D RIGHT SQUARE BRACKET, “]” (用于稀疏字段集合)
\item U+0021 EXCLAMATION MARK, “!”
\item U+0022 QUOTATION MARK, ‘”’
\item U+0023 NUMBER SIGN, “\#”
\item U+0024 DOLLAR SIGN, “\$”
\item U+0025 PERCENT SIGN, “\%”
\item U+0026 AMPERSAND, “\&”
\item U+0027 APOSTROPHE, “’”
\item U+0028 LEFT PARENTHESIS, “(“
\item U+0029 RIGHT PARENTHESIS, “)”
\item U+002A ASTERISK, “*”
\item U+002F SOLIDUS, “/”
\item U+003A COLON, “:”
\item U+003B SEMICOLON, “;”
\item U+003C LESS-THAN SIGN, “<”
\item U+003D EQUALS SIGN, “=”
\item U+003E GREATER-THAN SIGN, “>”
\item U+003F QUESTION MARK, “?”
\item U+0040 COMMERCIAL AT, “@”
\item U+005C REVERSE SOLIDUS, “”
\item U+005E CIRCUMFLEX ACCENT, “\^{}”
\item U+0060 GRAVE ACCENT, “\texttt{`}”
\item U+007B LEFT CURLY BRACKET, “\{“

\begin{compactenum}
\item U+007C VERTICAL LINE, “”
\end{compactenum}


\item U+007D RIGHT CURLY BRACKET, “}”
\item U+007E TILDE, “\~{}”
\item U+007F DELETE
\item U+0000 to U+001F (C0 Controls)
\end{compactitem}

\subsection{Data Fetch}


数据包括资源和关联，可以通过向后端发送GET请求获取数据。

响应可以通过以下描述的可选特征进一步提取。

\subsection{Resource Fetch}

服务器必须支持通过URL获取资源，URL可以通过以下形式提供：

\begin{compactitem}
\item top-level链接对象中的self链接.
\item resource-level链接对象中的self链接.
\item relationship-level链接对象中的related链接.
\end{compactitem}

例如，以下请求获取一个文献集合：


\begin{lstlisting}[language=JavaScript]
GET /articles HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

以下请求获取一篇文献：


\begin{lstlisting}[language=JavaScript]
GET /articles/1 HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

以下请求获取一篇文献的作者:


\begin{lstlisting}[language=JavaScript]
GET /articles/1/author HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


\section{Response}

\subsection{200}

如果服务器通过请求成功获取一个单独资源或资源集合，服务器必须以200 OK状态码回复。

如果服务器通过请求成功获取一个资源集合，服务器必须将一个资源对象的列表或空列表([])作为响应文档的主数据。

例如，对于一个针对文献集合的GET请求可以回复：



\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "http://example.com/articles"
  },
  "data": [{
    "type": "articles",
    "id": "1",
    "attributes": {
      "title": "JSON API paints my bikeshed!"
    }
  }, {
    "type": "articles",
    "id": "2",
    "attributes": {
      "title": "Rails is Omakase"
    }
  }]
}
\end{lstlisting}


一个空集合的相似回复可以是以下形式:

\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "http://example.com/articles"
  },
  "data": []
}
\end{lstlisting}

如果服务器可以通过请求成功获取一个单独资源，服服务器必须将一个资源对象或null作为响应文档的主数据。

只有当请求URL可能指向、但当前并不指向一个单独资源时，null才应当作为响应。

例如，一个针对一篇文献的请求可以通过以下形式回复:


\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "http://example.com/articles/1"
  },
  "data": {
    "type": "articles",
    "id": "1",
    "attributes": {
      "title": "JSON API paints my bikeshed!"
    },
    "relationships": {
      "author": {
        "links": {
          "related": "http://example.com/articles/1/author"
        }
      }
    }
  }
}
\end{lstlisting}


如果以上文献的作者是缺失的，相关资源的GET请求可以通过以下形式回复：


\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "http://example.com/articles/1/author"
  },
  "data": null
}
\end{lstlisting}

\subsection{404}


当通过一个请求获取一个不存在的单独资源时，服务器必须以404 Not Found状态码回复，除非请求允许null作为200 OK状态码响应的主数据(见后文描述)。

服务器可以回复其他HTTP状态码。

服务器可以在错误响应中包含错误详情。

服务器和客户端必须依据HTTP语义分别生成和解析响应。

\section{Relation Fetch}

服务器必须支持通过关联URL获取关联数据，关联URL可以通过关联的links对象中的self链接提供。

例如，以下请求获取文献的评论数据:

\begin{lstlisting}[language=JavaScript]
GET /articles/1/relationships/comments HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


以下请求获取文献的作者数据:

\begin{lstlisting}[language=JavaScript]
GET /articles/1/relationships/author HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

\subsection{200}


当服务器通过请求成功获取关联时，服务器应该以200 OK状态码回复。

响应文档的主数据必须是与资源连接相匹配的值，如上文对关联对象的描述。

Top-level链接对象可以包含self和related链接，如上文对关联对象的描述。

例如，一个来自单对象关联链接的GET请求可以通过以下形式回复:





\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "/articles/1/relationships/author",
    "related": "/articles/1/author"
  },
  "data": {
    "type": "people",
    "id": "12"
  }
}
\end{lstlisting}


如果以上关联为空，相同URL的GET请求可以通过以下形式回复:

\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "/articles/1/relationships/author",
    "related": "/articles/1/author"
  },
  "data": null
}
\end{lstlisting}

一个来自多对象关联链接的GET请求可以通过以下形式回复:




\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "/articles/1/relationships/tags",
    "related": "/articles/1/tags"
  },
  "data": [
    { "type": "tags", "id": "2" },
    { "type": "tags", "id": "3" }
  ]
}
\end{lstlisting}


如果以上关联为空，相同URL的GET请求可以通过以下形式回复:


\begin{lstlisting}[language=JavaScript]
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
  "links": {
    "self": "/articles/1/relationships/tags",
    "related": "/articles/1/tags"
  },
  "data": []
}
\end{lstlisting}

\subsection{404}

当通过一个请求获取一个不存在的关联链接URL时，服务器必须以404 Not Found状态码回复。

如果关联链接URL存在但是关联为空，如前文所述，服务器必须以200 OK状态码回复。

服务器可以回复其他HTTP状态码。

服务器可以在错误响应中包含错误详情。

服务器和客户端必须依据HTTP语义分别生成和解析响应。

\section{Inline resources}


后端可以默认回复与主数据相关的资源。

后端也可以支持include请求参数以保证客户端可以指定需要回复的相关资源。

如果后端不支持include参数，必须以400 Bad Request状态码回复任何包含此参数的请求。

如果后端支持include参数并且客户端使用了此参数，服务器不能在复合文档的included部分包含任何未请求的资源对象。

include参数的值必须是一个由逗号分隔符(U+002C COMMA, “,”) 分割的关联路径列表。关联路径是由点号分隔符(U+002E FULL-STOP, “.”) 分割的关联名称。

如果服务器不能识别关联路径或不能通过路径支持内联资源，必须以400 Bad Request状态码回复。

例如，可以同时请求评论和文献:



\begin{lstlisting}[language=JavaScript]
GET /articles/1?include=comments HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


可以通过如下形式为每个关联名称定义逗号分割路径，以请求与其他资源相关的资源：

\begin{lstlisting}[language=JavaScript]
GET /articles/1?include=comments.author HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


可以通过逗号分割列表请求多个相关资源:


\begin{lstlisting}[language=JavaScript]
GET /articles/1?include=author,comments.author HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

此外，可以向关联后端请求相关资源:


\begin{lstlisting}[language=JavaScript]
GET /articles/1/relationships/comments?include=comments.author HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

在这种情况下，主数据应该是代表此文献的评论连接的资源标识符对象集合，所有评论和评论作者将会作为相关数据返回。

\section{Sparse field group}

客户端可能通过fields[TYPE]参数,请求后端返回只包含特定字段的响应。

fields参数的值必须用逗号分隔开,用来表示需要返回字段的名称。

如果客户端请求了一组给定类型的字段,那么后端不能包括资源对象内此类型的附加字段。

\begin{lstlisting}[language=JavaScript]
GET /articles?include=author&fields[articles]=title,body&fields[people]=name HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


\section{Sort}

服务器可以选择性支持，根据一个或多个条件(排序字段)对资源集合排序。

后端可能支持带有sort查询参数的请求,来排序主要数据。sort的值必须代表排序字段。





\begin{lstlisting}[language=JavaScript]
GET /people?sort=age HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


后端可能支持带有多个排序字段的请求,允许用逗号分隔排序字段。排序字段应该被按照特定顺序执行。

\begin{lstlisting}[language=JavaScript]
GET /people?sort=age,name HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}

每个排序字段必须按升序排列。除非它带有-前缀,这种情况下将按降序排列。

\begin{lstlisting}[language=JavaScript]
GET /articles?sort=-created,title HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}



以上的例子应首先返回最新的条目。在同一天创建的条目讲按照标题的字母升序排列。

如果服务器不支持查询参数sort指定的排序,必须返回400 Bad Request。

如果服务器支持排序,并且客户端通过查询参数sort进行排序,服务器必须返回根据指定条件排序的, 上层data数组的元素。


\section{Pagination}

服务器可以选择性限制响应返回的资源数量,为所有可获取资源的子集("page")。

服务器可以提供传送分页后数据集的连接("pagination links")。

pagination links必须出现在集合相关的连接对象中。需要在上层links对象中提供pagination links。

下面的键必须被用于pagination links: * first: 第一页数据 * last: 最后一页数据 * prev: 前一页数据 * next: 后一页数据

如需表示特定的连接不可用,这些键必须被省略,或者值为null。

分页的排序,必须与JSON API的排序规则一致。

查询参数page是分页的保留字,服务器和客户端应该用这个参数进行分页。

\section{Filter}

查询参数filter是过滤的保留字,服务器和客户端应该用这个参数进行过滤。

\section{Resource}


服务器可能支持给定类型资源的创建，服务器也可能允许已存在资源的更新和删除。

服务器允许单次请求，更新多个资源，如下所述。多个资源更新必须完全成功或者失败，不允许部分更新成功。

任何包含内容的请求，必须包含Content-Type:application/vnd.api+json请求头。

\subsection{Create}

向表示待创建资源所属资源集的URL，发出POST请求，创建一个或多个资源。 请求必须包含单一资源对象作为主数据。资源对象必须包含至少一个type成员。

例如，新photo可以通过如下请求创建：

\begin{lstlisting}[language=JavaScript]
POST /photos HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "photos",
    "attributes": {
      "title": "Ember Hamster",
      "src": "http://example.com/images/productivity.png"
    },
    "relationships": {
      "photographer": {
        "data": { "type": "people", "id": "9" }
      }
    }
  }
}
\end{lstlisting}


如果资源对象在relationships提供了关系,它的值必须是一个有data成员的关系对象。 这个键的值代表新资源将要有的连接。

\subsection{UUID}

服务器可能接受创建资源的请求中有客户端生成的ID。ID必须被id键指定,它的值必须是通用唯一识别码。 客户端应该使用 RGC4122 RGC4122中描述的合适的UUID。

\begin{lstlisting}[language=JavaScript]
POST /photos HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "photos",
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "attributes": {
      "title": "Ember Hamster",
      "src": "http://example.com/images/productivity.png"
    }
  }
}
\end{lstlisting}

服务器必须对不支持的带有客户端生成ID的创建请求返回403 Forbidden。

\section{Response}

\subsection{201}

如果POST请求不包括客户端生成的ID,并且请求的资源成功被创建,服务器必须返回201 Created状态码。

响应应该包含Location头，用以标示请求创建所有资源的位置。

响应必须含有一个文档，用以存储所创建的主要资源。

如果响应返回的资源对象在links成员里包含self键,并且响应数据头提供了Location, 那么self的值必须匹配Location的值。


\begin{lstlisting}[language=JavaScript]
HTTP/1.1 201 Created
Location: http://example.com/photos/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/vnd.api+json

{
  "data": {
    "type": "photos",
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "attributes": {
      "title": "Ember Hamster",
      "src": "http://example.com/images/productivity.png"
    },
    "links": {
      "self": "http://example.com/photos/550e8400-e29b-41d4-a716-446655440000"
    }
  }
}
\end{lstlisting}



\subsection{202}


如果创建资源的请求被接受处理,但在服务器响应时处理并未完成,那么服务器必须返回202 Accepted状态码。

\subsection{204}

如果POST请求包括客户端生成的ID,并且请求的资源成功被创建,那么服务器必须返回201 Created状态码和响应文档(如上所述), ,或者只返回204 No Content状态码,没有响应文档。

\subsection{403}

服务器可能向不支持的创建资源的请求返回403 Forbidden的响应。

\subsection{404}

如果创建请求引用的相关资源不存在,服务器必须返回404 Not Found的响应。

\subsection{409}

如果创建请求中,客户端生成的ID已经存在,服务器必须返回409 Conflict的响应。

如果创建请求中,资源对象的type不在后端支持的类型里,服务器必须返回409 Conflict的响应。

服务器应该在响应中包括错误详情和足够的信息以识别冲突原因。

服务器响应可能没有状态码。

服务器可能响应包括错误详情的错误响应。

服务器与客户端必须依照HTTP的语义准备和解译响应。

\section{Update Resource}

向表示资源的URL发出PATCH请求，即可进行资源更新。

资源的URL可以从资源对象的self的值获得。或者,当GET请求返回了一个资源对象作为主资源, 同样的请求URL可被用来更新资源。

PATCH请求必须包括一个资源对象作为主资源。资源对象必须包含type和id成员。


\begin{lstlisting}[language=JavaScript]
PATCH /articles/1 HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "articles",
    "id": "1",
    "attributes": {
      "title": "To TDD or Not"
    }
  }
}
\end{lstlisting}


\subsection{Update Resource Property}

资源的任何一个,或者所有属性,可能被包括在PATCH请求的资源对象中。

如果请求不包括资源所有的属性,那么服务器解译请求时必须添加这些属性,并赋予当前的值。 服务器不能给缺失的属性赋值为null。

比如,下面的PATCH请求被解译为只更新title和text两个属性:

\begin{lstlisting}[language=JavaScript]
PATCH /articles/1 HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "articles",
    "id": "1",
    "attributes": {
      "title": "To TDD or Not",
      "text": "TLDR; It's complicated... but check your test coverage regardless."
    }
  }
}
\end{lstlisting}

\subsection{Update Resource association}


资源的所有或者任何一个关联都可能包括在PATCH请求的资源对象中。

如果一个请求不包括资源所有的关联,那么服务器解译请求时必须添加这些属性,并赋予当前的值。 服务器不能给缺失的属性赋值为null或者为空。

如果关联是被PATCH请求的资源对象中relationships给出的,那么它的值必须是一个有data成员的关联对象。 关联的值将被这个成员定义的值代替。

比如,下面的PATCH请求将会更新author关联:

\begin{lstlisting}[language=JavaScript]
PATCH /articles/1 HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "articles",
    "id": "1",
    "relationships": {
      "author": {
        "data": { "type": "people", "id": "1" }
      }
    }
  }
}
\end{lstlisting}


相似的,下面的PATCH请求会更新整个tags关联:


\begin{lstlisting}[language=JavaScript]
PATCH /articles/1 HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {
    "type": "articles",
    "id": "1",
    "relationships": {
      "tags": {
        "data": [
          { "type": "tags", "id": "2" },
          { "type": "tags", "id": "3" }
        ]
      }
    }
  }
}
\end{lstlisting}

服务器可能拒绝更新多对象关联的请求。在这种情况,服务器必须阻止整个更新,并返回403 Forbidden状态码。


\subsection{202}

如果服务器接受更新,但在服务器响应时更新并未完成,那么服务器必须返回202 Accepted状态码。

\subsection{204}

如果更新成功，且服务器没有更新任何未提供的属性，那么服务器必须或者返回204 No Content状态码和响应文档,或者只返回204 No Content状态码,没有响应文档。

\subsection{200}


如果服务器接受更新，但是在请求指定内容之外做了资源修改，必须响应200 OK以及更新的资源实例，像是向此URL发出GET请求。

如果更新成功,客户端当前属性保持更新,并且服务器只响应最上层元数据,那么服务器必须返回200 OK状态码。 这种情况下,服务器不能包括更新后的资源。

服务器使用其它HTTP错误状态码反映错误。 客户端必须依据HTTP规范处理这些错误信息。 如下所述，错误细节可能会一并返回。

\section{Update Association}

虽然关联可以通过资源被更新(如上所述),JSON API也支持单独通过Relationship Links更新关联。

\subsection{Update To-One Association}

PATCH请求必须包括上层名为data的成员,包括:

相关新资源的资源表示对象

或者

null,用来删除关联。

比如,下面的请求更新author关联:


\begin{lstlisting}[language=JavaScript]
PATCH /articles/1/relationships/author HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": { "type": "people", "id": "12" }
}
\end{lstlisting}


而下面的请求会清除author关联:

\begin{lstlisting}[language=JavaScript]
PATCH /articles/1/relationships/author HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": null
}
\end{lstlisting}


如果关联被成功更新,服务器必须返回一个成功的响应。

\subsection{Update To-Many Association}

对所有请求类型,主体必须包括一个data成员,其值是一个空数组,或是一个资源标识对象的数组。

如果客户端向一个to-many关联连接的URL发出PATCH请求,服务器必须或者完全更改关联的每一个成员, 如果资源不存在或者无法使用,返回合适的错误状态码,如果服务器不允许完全更改,则返回403 Forbidden。

比如,下面的请求会更改所有的tag:

\begin{lstlisting}[language=JavaScript]
PATCH /articles/1/relationships/tags HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": [
    { "type": "tags", "id": "2" },
    { "type": "tags", "id": "3" }
  ]
}
\end{lstlisting}


而下面的请求会清除所有的tag:



\begin{lstlisting}[language=JavaScript]
PATCH /articles/1/relationships/tags HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": []
}
\end{lstlisting}


如果客户端向一个关联连接的URL发出POST请求,那么服务器必须向关联添加新增的成员, 除非他们已经存在。如果所给的type和id已经存在,服务器不能再添加他们。

如果所有指定的资源都可以被添加到关联,或者已经存在在关联里,那么服务器必须返回一个成功响应。

在下面的例子中,ID为123的评论被添加到评论列表内ID为1的条目中。

\begin{lstlisting}[language=JavaScript]
POST /articles/1/relationships/comments HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": [
    { "type": "comments", "id": "123" }
  ]
}
\end{lstlisting}

如果客户端向一个关联连接的URL发出DELETE请求,那么服务器必须在关联中删除指定的成员,或者返回403 Forbidden响应。 如果所有指定的资源都可以从关联中删除,或者未存在在关联中,那么服务器必须返回一个成功响应。

关联成员是被与POST请求同样的方式指定的。

在下面的例子中,ID为12和13的评论被从评论列表内ID为1的条目中删除:



\begin{lstlisting}[language=JavaScript]
DELETE /articles/1/relationships/comments HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": [
    { "type": "comments", "id": "12" },
    { "type": "comments", "id": "13" }
  ]
}
\end{lstlisting}


\subsection{202}

如果服务器接受关联更新请求,但在服务器响应时更新并未完成,那么服务器必须返回202 Accepted状态码。

\subsection{204}

如果更新成功，并且请求中的资源与结果相符，那么服务器必须或者返回204 No Content状态码。

\subsection{200}

如果服务器接受更新,但用在请求指定以外的方式更改了目标关联,那么b必须返回200 OK响应。 响应文档必须包括被更新关联的代表。

如果更新成功,客户端当前数据保持更新,并且服务器只响应最上层元数据,那么服务器必须返回200 OK状态码。 这种情况下,服务器不能包括更新后的资源。

\subsection{403}

服务器必须向不支持的更新关联请求发出403 Forbidden响应。

服务器可能使用其它HTTP错误状态码反映错误。

服务器可能响应包括错误详情的错误响应。

服务器与客户端必须依照HTTP的语义准备和解译响应。


\section{Resource Delete}


向资源URL发出DELETE请求即可删除单个资源。




\begin{lstlisting}[language=JavaScript]
DELETE /photos/1 HTTP/1.1
Accept: application/vnd.api+json
\end{lstlisting}


\subsection{202}

如果删除资源的请求被接受处理,但在服务器响应时处理并未完成,那么服务器必须返回202 Accepted状态码。

\subsection{204}

如果删除请求成功，服务器必须返回204 No Content 状态码,并且没有返回内容

\subsection{200}

如果删除请求成功,服务器必须返回200 OK状态码,并且返回上层的元数据。


\subsection{404}

如果因为资源不存在,删除请求失败,那么服务器应该返回404 Not Found状态码。

服务器可能使用其它HTTP错误状态码反映错误。

服务器可能响应包括错误详情的错误响应。

服务器与客户端必须依照HTTP的语义准备和解译响应。

\section{Query String}

查询参数必须遵守成员命名的规则,同时必须包含至少一个非a-z字符(U+0061 to U+007A)。推荐使用 U+002D HYPHEN-MINUS, “-“, U+005F LOW LINE, “\_”, 或者大写字母(如camelCasing)。

如果服务器获取到不遵从以上命名规则的查询参数,并且不知道如何处理,那么服务器必须返回400 Bad Request。


\section{Error Handling}


当遇到一个问题时,服务器可以选择停止处理,也可以继续处理,遇到多个问题。 比如,服务器可能处理多个属性,并在一个响应中返回多个验证问题。

当服务器在一个请求中遇到多个问题,在响应中应该使用HTTP最通用的错误状态码。 比如,400 Bad Request可被用于多个4xx错误,500 Internal Server Error可被用于多个5xx错误。


\subsection{Error Object}

错误对象提供执行操作时遇到问题的额外信息。 在JSON API文档顶层，错误对象必须被作为errors键对应的数组返回。

错误对象可能有以下成员：

\begin{compactitem}
\item id - 特定问题的唯一标识符。
\item links - 一个包括以下成员的连接对象:

\begin{compactenum}
\item about - 指向特定问题更多具体内容的连接。
\end{compactenum}

\item status - 适用于这个问题的HTTP状态码，使用字符串表示。
\item code - 应用特定的错误码，以字符串表示。
\item title - 简短的，可读性高的问题总结。除了国际化本地化处理之外，不同场景下，相同的问题，值是不应该变动的。
\item detail - 针对该问题的高可读性解释。与title相同,这个值可以被本地化。
\item source - 包括错误资源的引用的对象。它也可以包括以下任意成员:

\begin{compactenum}
\item pointer - 一个指向请求文档中相关实体的JSON Pointer。
\item parameter - 指出引起错误的查询对象的字符串。
\end{compactenum}

\item meta - 一个包括关于错误的非标准元信息的元对象。
\end{compactitem}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}



\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}




\begin{lstlisting}[language=JavaScript]

\end{lstlisting}





\begin{lstlisting}[language=JavaScript]

\end{lstlisting}

